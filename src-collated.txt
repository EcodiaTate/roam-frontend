

===== src/app/auth/callback/page.tsx =====

// src/app/auth/callback/page.tsx
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { supabase } from "@/lib/supabase/client";

/**
 * OAuth redirect landing page.
 *
 * After Google OAuth completes, Supabase redirects here with a code/token
 * in the URL hash. The Supabase client automatically exchanges it for a
 * session (because detectSessionInUrl: true). We just wait for the session
 * to appear, then redirect to /trip.
 */
export default function AuthCallbackPage() {
  const router = useRouter();

  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (event === "SIGNED_IN" && session) {
        router.replace("/trip");
      }
    });

    // Fallback: if session already exists (fast redirect), go immediately
    supabase.auth.getSession().then(({ data }) => {
      if (data.session) router.replace("/trip");
    });

    return () => subscription.unsubscribe();
  }, [router]);

  return (
    <div style={{ display: "flex", alignItems: "center", justifyContent: "center", height: "100vh" }}>
      <div style={{ textAlign: "center" }}>
        <div style={{ fontSize: 18, fontWeight: 600, marginBottom: 8 }}>Signing you in…</div>
        <div style={{ color: "var(--roam-muted, #888)" }}>Please wait</div>
      </div>
    </div>
  );
}

===== src/app/guide/ClientPage.tsx =====

// src/app/guide/ClientPage.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";

import { haptic } from "@/lib/native/haptics";
import { useGeolocation } from "@/lib/native/geolocation";
import { getCurrentPlanId, getOfflinePlan, type OfflinePlanRecord } from "@/lib/offline/plansStore";
import { getAllPacks, hasCorePacks } from "@/lib/offline/packsStore";
import { unpackAndStoreBundle } from "@/lib/offline/unpackBundle";

import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay } from "@/lib/types/navigation";
import type { PlacesPack, PlaceItem } from "@/lib/types/places";
import type { OfflineBundleManifest } from "@/lib/types/bundle";
import type { GuidePack, GuideContext, TripProgress } from "@/lib/types/guide";

import { createGuidePack, guideSendMessage } from "@/lib/guide/guideEngine";
import { computeTripProgress } from "@/lib/guide/tripProgress";
import { addPlaceToTrip } from "@/lib/guide/addToTrip";

import { GuideView } from "@/components/trip/GuideView";

import { ArrowLeft, Wifi, WifiOff, Satellite, AlertTriangle } from "lucide-react";

// ──────────────────────────────────────────────────────────────
// Online status hook
// ──────────────────────────────────────────────────────────────

function useOnlineStatus() {
  const [online, setOnline] = useState<boolean>(() =>
    typeof navigator !== "undefined" ? navigator.onLine : true,
  );
  useEffect(() => {
    const on = () => setOnline(true);
    const off = () => setOnline(false);
    window.addEventListener("online", on);
    window.addEventListener("offline", off);
    return () => {
      window.removeEventListener("online", on);
      window.removeEventListener("offline", off);
    };
  }, []);
  return online;
}

// ──────────────────────────────────────────────────────────────
// Component
// ──────────────────────────────────────────────────────────────

export default function GuideClientPage(props: {
  initialPlanId: string | null;
  initialFocusPlaceId: string | null;
}) {
  const router = useRouter();
  const sp = useSearchParams();
  const isOnline = useOnlineStatus();

  const planIdFromUrl = sp.get("plan_id");
  const focusFromUrl = sp.get("focus_place_id");

  const desiredPlanId = useMemo(
    () => props.initialPlanId ?? planIdFromUrl ?? null,
    [props.initialPlanId, planIdFromUrl],
  );
  const desiredFocusPlaceId = useMemo(
    () => props.initialFocusPlaceId ?? focusFromUrl ?? null,
    [props.initialFocusPlaceId, focusFromUrl],
  );

  // ── Geolocation ──────────────────────────────────────────────
  const geo = useGeolocation({ autoStart: true, highAccuracy: true });

  // ── Data state ───────────────────────────────────────────────
  const [plan, setPlan] = useState<OfflinePlanRecord | null>(null);
  const [navpack, setNavpack] = useState<NavPack | null>(null);
  const [corridor, setCorridor] = useState<CorridorGraphPack | null>(null);
  const [places, setPlaces] = useState<PlacesPack | null>(null);
  const [traffic, setTraffic] = useState<TrafficOverlay | null>(null);
  const [hazards, setHazards] = useState<HazardOverlay | null>(null);
  const [manifest, setManifest] = useState<OfflineBundleManifest | null>(null);

  const [focusedPlaceId, setFocusedPlaceId] = useState<string | null>(desiredFocusPlaceId);

  // ── Trip progress ────────────────────────────────────────────
  const [tripProgress, setTripProgress] = useState<TripProgress | null>(null);

  // ── Guide state ──────────────────────────────────────────────
  const [guideKey, setGuideKey] = useState<string | null>(null);
  const [guidePack, setGuidePack] = useState<GuidePack | null>(null);
  const [guideContext, setGuideContext] = useState<GuideContext | null>(null);

  const [busy, setBusy] = useState<null | "boot" | "chat" | "add">(null);
  const [err, setErr] = useState<string | null>(null);

  const didBootstrapRef = useRef(false);

  useEffect(() => setFocusedPlaceId(desiredFocusPlaceId), [desiredFocusPlaceId]);

  // ── Boot packs from IDB ──────────────────────────────────────
  useEffect(() => {
    let cancelled = false;

    async function boot() {
      setBusy("boot");
      setErr(null);
      try {
        const id = desiredPlanId ?? (await getCurrentPlanId());
        if (!id || cancelled) return;

        const rec = await getOfflinePlan(id);
        if (!rec || cancelled) return;

        const has = await hasCorePacks(rec.plan_id);
        if (!has) await unpackAndStoreBundle(rec);

        const packs = await getAllPacks(rec.plan_id);
        if (cancelled) return;

        setPlan(rec);
        setNavpack((packs as any).navpack ?? null);
        setCorridor((packs as any).corridor ?? null);
        setPlaces((packs as any).places ?? null);
        setTraffic((packs as any).traffic ?? null);
        setHazards((packs as any).hazards ?? null);
        setManifest((packs as any).manifest ?? null);
      } catch (e: any) {
        setErr(e?.message ?? String(e));
      } finally {
        if (!cancelled) setBusy(null);
      }
    }

    boot();
    return () => {
      cancelled = true;
      didBootstrapRef.current = false;
    };
  }, [desiredPlanId]);

  // ── Compute trip progress when position updates ──────────────
  useEffect(() => {
    if (!geo.position || !plan) return;

    const stops = (navpack?.req?.stops ?? plan.preview?.stops ?? []) as any[];
    if (stops.length === 0) return;

    const progress = computeTripProgress({
      position: geo.position,
      stops,
      navpack,
      prevProgress: tripProgress,
    });

    setTripProgress(progress);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [geo.position, plan, navpack]);

  // ── Bootstrap Guide pack (with IDB restore) ──────────────────
  useEffect(() => {
    let cancelled = false;

    async function bootstrapGuide() {
      if (didBootstrapRef.current) return;
      if (!plan) return;

      const stops = (navpack?.req?.stops ?? plan.preview?.stops ?? []) as any[];
      if (!stops || stops.length === 0) return;

      didBootstrapRef.current = true;
      try {
        const { guideKey, pack, context } = await createGuidePack({
          planId: plan.plan_id,
          label: plan.label ?? null,
          stops,
          navpack,
          corridor,
          places,
          traffic,
          hazards,
          manifest,
          progress: tripProgress,
        });

        if (cancelled) return;

        setGuideKey(guideKey);
        setGuidePack(pack);
        setGuideContext(context);
      } catch (e: any) {
        if (!cancelled) setErr(e?.message ?? String(e));
      }
    }

    bootstrapGuide();
    return () => {
      cancelled = true;
    };
  }, [plan, navpack, corridor, places, traffic, hazards, manifest, tripProgress]);

  // ── Handlers ─────────────────────────────────────────────────

  const handleSendMessage = useCallback(
    async (text: string, preferredCategories: string[]) => {
      if (!guideKey || !guidePack || !guideContext) return;

      setBusy("chat");
      setErr(null);
      try {
        // Recompute progress right before sending for freshest position
        let latestProgress = tripProgress;
        if (geo.position && plan) {
          const stops = (navpack?.req?.stops ?? plan.preview?.stops ?? []) as any[];
          if (stops.length > 0) {
            latestProgress = computeTripProgress({
              position: geo.position,
              stops,
              navpack,
              prevProgress: tripProgress,
            });
            setTripProgress(latestProgress);
          }
        }

        // Update context with latest progress
        const freshContext: GuideContext = {
          ...guideContext,
          progress: latestProgress,
        };

        // CRITICAL: Pass corridor places so the intent mapper can pre-filter them
        const corridorPlaces: PlaceItem[] = places?.items ?? [];

        const res = await guideSendMessage({
          planId: plan?.plan_id ?? null,
          guideKey,
          pack: guidePack,
          context: freshContext,
          userText: text,
          preferredCategories,
          maxSteps: 4,
          progress: latestProgress,
          corridorPlaces,
        });

        setGuidePack(res.pack);
        setGuideContext(freshContext);
        return res.assistantText;
      } catch (e: any) {
        setErr(e?.message ?? String(e));
        throw e;
      } finally {
        setBusy(null);
      }
    },
    [guideKey, guidePack, guideContext, tripProgress, geo.position, plan, navpack, places],
  );

  const handleAddStop = useCallback(
    async (place: PlaceItem) => {
      if (!plan || !navpack) return;
      setBusy("add");
      setErr(null);
      try {
        haptic.medium();
        await addPlaceToTrip({
          plan,
          place,
          navpack,
          corridor,
          profile: navpack.req.profile ?? "drive",
          mode: "auto",
        });
        haptic.success();
        router.push(`/trip?plan_id=${encodeURIComponent(plan.plan_id)}`);
      } catch (e: any) {
        haptic.error();
        setErr(e?.message ?? String(e));
      } finally {
        setBusy(null);
      }
    },
    [plan, navpack, corridor, router],
  );

  const handleShowOnMap = useCallback(
    (placeId: string) => {
      haptic.selection();
      if (!plan) return;
      router.push(
        `/trip?plan_id=${encodeURIComponent(plan.plan_id)}&focus_place_id=${encodeURIComponent(placeId)}`,
      );
    },
    [plan, router],
  );

  // ── Render ───────────────────────────────────────────────────

  const headerTitle = plan?.label ?? "Guide";

  if (!plan) {
    return (
      <div
        style={{
          display: "grid",
          placeItems: "center",
          height: "100dvh",
          background: "var(--roam-bg)",
          color: "var(--roam-text)",
        }}
      >
        <div
          style={{
            color: "var(--roam-text-muted)",
            fontSize: 16,
            fontWeight: 800,
          }}
        >
          {busy === "boot" ? "Loading guide…" : "No plan loaded"}
        </div>
      </div>
    );
  }

  return (
    <div
      style={{
        minHeight: "100dvh",
        background: "var(--roam-bg)",
        color: "var(--roam-text)",
        display: "flex",
        flexDirection: "column",
      }}
    >
      {/* ── Sticky header ───────────────────────────────────────── */}
      <div
        style={{
          position: "sticky",
          top: 0,
          zIndex: 50,
          padding: "16px 14px 12px",
          background: "linear-gradient(to bottom, var(--roam-bg) 78%, rgba(0,0,0,0))",
          backdropFilter: "blur(10px)",
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
     

          <div style={{ minWidth: 0, flex: 1 }}>
           
            <div
              className="trip-truncate"
              style={{
                fontSize: 18,
                fontWeight: 950,
                letterSpacing: "-0.2px",
              }}
            >
              {headerTitle}
            </div>
          </div>

          <div
            style={{
              padding: "8px 10px",
              borderRadius: 999,
              fontSize: 12,
              fontWeight: 900,
              background: isOnline ? "rgba(0,200,120,0.12)" : "rgba(255,180,0,0.12)",
              color: isOnline ? "rgba(0,160,90,1)" : "rgba(200,130,0,1)",
              whiteSpace: "nowrap",
              display: "inline-flex",
              alignItems: "center",
              gap: 6,
            }}
          >
            {isOnline ? <Wifi size={14} /> : <WifiOff size={14} />}
            {isOnline ? "Online" : "Offline"}
          </div>
        </div>

        {/* ── Progress bar ────────────────────────────────────── */}
        {tripProgress && tripProgress.total_km > 0 ? (
          <div style={{ marginTop: 10 }}>
            <div
              style={{
                display: "flex",
                justifyContent: "space-between",
                fontSize: 11,
                fontWeight: 900,
                color: "var(--roam-text-muted)",
                marginBottom: 4,
              }}
            >
              <span>{tripProgress.km_from_start.toFixed(0)} km travelled</span>
              <span>{tripProgress.km_remaining.toFixed(0)} km to go</span>
            </div>

            <div
              style={{
                height: 6,
                borderRadius: 3,
                background: "var(--roam-surface-hover)",
                overflow: "hidden",
                position: "relative",
              }}
            >
              <div
                style={{
                  position: "absolute",
                  left: 0,
                  top: 0,
                  bottom: 0,
                  width: `${Math.min(100, (tripProgress.km_from_start / tripProgress.total_km) * 100)}%`,
                  background: "var(--roam-accent)",
                  borderRadius: 3,
                  transition: "width 0.5s ease-out",
                }}
              />

              {/* Stop markers on the progress bar */}
              {(() => {
                const stops = (navpack?.req?.stops ?? plan.preview?.stops ?? []) as any[];
                const legs = navpack?.primary?.legs ?? [];
                if (stops.length < 2 || legs.length === 0) return null;

                let cumKm = 0;
                const markers: { pct: number; visited: boolean; name: string }[] = [];

                markers.push({
                  pct: 0,
                  visited: tripProgress.visited_stop_ids.includes(stops[0]?.id),
                  name: stops[0]?.name ?? "",
                });

                for (let i = 0; i < legs.length; i++) {
                  cumKm += legs[i].distance_m / 1000;
                  const stop = stops[i + 1];
                  if (stop) {
                    markers.push({
                      pct: (cumKm / tripProgress.total_km) * 100,
                      visited: tripProgress.visited_stop_ids.includes(stop.id),
                      name: stop.name ?? "",
                    });
                  }
                }

                return markers.map((m, idx) => (
                  <div
                    key={idx}
                    title={m.name}
                    style={{
                      position: "absolute",
                      left: `${Math.min(100, m.pct)}%`,
                      top: -1,
                      width: 8,
                      height: 8,
                      borderRadius: 4,
                      background: m.visited ? "var(--roam-accent)" : "var(--roam-surface)",
                      border: "2px solid var(--roam-surface-hover)",
                      transform: "translateX(-50%)",
                      zIndex: 2,
                    }}
                  />
                ));
              })()}
            </div>
          </div>
        ) : null}

        {/* ── GPS status ──────────────────────────────────────── */}
        {geo.loading ? (
          <div
            style={{
              marginTop: 8,
              fontSize: 11,
              fontWeight: 900,
              color: "var(--roam-text-muted)",
              display: "inline-flex",
              alignItems: "center",
              gap: 6,
            }}
          >
            <Satellite size={14} />
            Getting GPS fix…
          </div>
        ) : geo.error ? (
          <div
            style={{
              marginTop: 8,
              fontSize: 11,
              fontWeight: 900,
              color: "rgba(200,100,0,1)",
              display: "inline-flex",
              alignItems: "center",
              gap: 6,
            }}
          >
            <AlertTriangle size={14} />
            {geo.error}
          </div>
        ) : null}

        {err ? (
          <div
            style={{
              marginTop: 10,
              padding: 12,
              borderRadius: 14,
              background: "rgba(255,0,0,0.08)",
              color: "rgba(200,0,0,1)",
              fontWeight: 850,
              fontSize: 13,
              display: "inline-flex",
              alignItems: "center",
              gap: 8,
            }}
          >
            <AlertTriangle size={16} />
            {err}
          </div>
        ) : null}
      </div>

      {/* ── Content ─────────────────────────────────────────────── */}
      <div
        style={{
          padding: "0 14px",
          paddingBottom: "calc(var(--bottom-nav-height, 80px) + 24px)",
        }}
      >
        <GuideView
          places={places}
          focusedPlaceId={focusedPlaceId}
          onFocusPlace={setFocusedPlaceId}
          isOnline={isOnline}
          guideReady={!!(guideKey && guidePack && guideContext)}
          guidePack={guidePack}
          tripProgress={tripProgress}
          onSendMessage={handleSendMessage}
          chatBusy={busy === "chat"}
          onAddStop={handleAddStop}
          onShowOnMap={handleShowOnMap}
        />
      </div>
    </div>
  );
}


===== src/app/guide/page.tsx =====

// src/app/guide/page.tsx
import GuideClientPage from "./ClientPage";

export const dynamic = "force-static";

export default function GuidePage() {
  return (
    <GuideClientPage
      initialPlanId={null}
      initialFocusPlaceId={null}
    />
  );
}


===== src/app/layout.tsx =====

// src/app/layout.tsx
import "./globals.css";

import type { Metadata, Viewport } from "next";
import { Plus_Jakarta_Sans } from "next/font/google";

import { BottomTabBar } from "@/components/ui/BottomTabBar";
import { AuthProvider } from "@/lib/supabase/auth";
import { SyncBootstrap } from "@/components/auth/SyncBootstrap";
import { NativeBootstrap } from "@/components/native/NativeBootstrap";
import { BasemapBootstrap } from "@/components/native/BasemapBootstrap";

const outbackFont = Plus_Jakarta_Sans({
  subsets: ["latin"],
  weight: ["400", "500", "600", "700", "800"],
  display: "swap",
  variable: "--font-sans",
});

export const metadata: Metadata = {
  title: "Roam",
  description: "Offline-first outback routing and navigation",

  //  Updated for static manifest
  manifest: "/manifest.webmanifest",

  // Ensures installable feel on mobile web too
  applicationName: "Roam",
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "Roam",
  },

  formatDetection: {
    telephone: false,
  },
};

export const viewport: Viewport = {
  width: "device-width",
  height: "device-height", // Add this
  initialScale: 1,
  maximumScale: 1,         // Add this to be extra safe
  userScalable: false,
  viewportFit: "cover",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className={outbackFont.variable}>
      <head>
        {/* Ensures PWA + native splash tint alignment */}
        <meta name="theme-color" content="#0a0a0a" />
        <link rel="manifest" href="/manifest.webmanifest" />
      </head>

      <body
        className={outbackFont.className}
        style={{
          overscrollBehavior: "none",
          backgroundColor: "#0a0a0a",
        }}
      >
        <AuthProvider>
          <NativeBootstrap />
          <SyncBootstrap />
          <BasemapBootstrap />

          <div className="roam-shell">
            <main className="roam-main">{children}</main>
            <BottomTabBar />
          </div>
        </AuthProvider>
      </body>
    </html>
  );
}

===== src/app/login/page.tsx =====

// src/app/login/page.tsx
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { Capacitor } from "@capacitor/core";
import { useAuth } from "@/lib/supabase/auth";

export default function LoginPage() {
  const {
    session,
    loading,
    signInWithGoogle,
    signInWithEmail,
    signUpWithEmail,
    signInWithAppleNative,
  } = useAuth();

  const router = useRouter();

  const [mode, setMode] = useState<"login" | "signup">("login");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);
  const [signupSuccess, setSignupSuccess] = useState(false);

  const isNative = useMemo(() => Capacitor.isNativePlatform(), []);

  // If already authenticated, go to /trip
  useEffect(() => {
    if (!loading && session) router.replace("/trip");
  }, [loading, session, router]);

  const handleGoogle = useCallback(async () => {
    setError(null);
    setBusy(true);
    const { error: err } = await signInWithGoogle();
    if (err) setError(err.message);
    setBusy(false);
  }, [signInWithGoogle]);

  const handleApple = useCallback(async () => {
    setError(null);
    setBusy(true);
    try {
      const { error: err } = await signInWithAppleNative();
      if (err) setError(err.message);
      // success -> session updates -> redirect effect fires
    } catch (e: any) {
      setError(e?.message ?? "Apple Sign-In failed");
    } finally {
      setBusy(false);
    }
  }, [signInWithAppleNative]);

  const handleEmailSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      setError(null);
      setSignupSuccess(false);

      const e1 = email.trim();
      if (!e1 || !password) {
        setError("Email and password are required");
        return;
      }
      if (password.length < 6) {
        setError("Password must be at least 6 characters");
        return;
      }

      setBusy(true);
      try {
        if (mode === "login") {
          const { error: err } = await signInWithEmail(e1, password);
          if (err) setError(err.message);
        } else {
          const { error: err } = await signUpWithEmail(e1, password);
          if (err) setError(err.message);
          else setSignupSuccess(true);
        }
      } finally {
        setBusy(false);
      }
    },
    [email, password, mode, signInWithEmail, signUpWithEmail],
  );

  if (loading) {
    return (
      <div style={styles.page}>
        <div style={{ color: "var(--roam-muted, #888)" }}>Loading…</div>
      </div>
    );
  }

  return (
    <div style={styles.page}>
      <div style={styles.card}>
        <div style={styles.title}>Roam</div>
        <div style={styles.subtitle}>Navigate anywhere. Even offline.</div>

        {/* Apple (native only, true in-app system UI) */}
        {isNative && (
          <button
            type="button"
            onClick={handleApple}
            disabled={busy}
            style={{
              ...styles.appleBtn,
              ...(busy ? styles.btnDisabled : null),
            }}
          >
            <AppleMark />
            <span style={styles.appleBtnText}>Sign in with Apple</span>
          </button>
        )}

        {/* Google OAuth (browser-based) */}
        <button
          type="button"
          onClick={handleGoogle}
          disabled={busy}
          style={{
            ...styles.googleBtn,
            ...(busy ? styles.btnDisabled : null),
          }}
        >
          <GoogleG />
          <span>Continue with Google</span>
        </button>

        <div style={styles.divider}>
          <div style={styles.dividerLine} />
          <span style={styles.dividerText}>or</span>
          <div style={styles.dividerLine} />
        </div>

        <form onSubmit={handleEmailSubmit} style={{ display: "contents" }}>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Email"
            autoComplete="email"
            inputMode="email"
            style={styles.input}
            disabled={busy}
          />
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Password"
            autoComplete={mode === "signup" ? "new-password" : "current-password"}
            style={styles.input}
            disabled={busy}
          />

          <button
            type="submit"
            disabled={busy}
            style={{
              ...styles.primaryBtn,
              ...(busy ? styles.btnDisabled : null),
            }}
          >
            {busy ? "…" : mode === "login" ? "Sign in" : "Create account"}
          </button>
        </form>

        {error && <div style={styles.error}>{error}</div>}
        {signupSuccess && (
          <div style={styles.success}>
            Check your email for a confirmation link, then sign in.
          </div>
        )}

        <button
          type="button"
          onClick={() => {
            setMode(mode === "login" ? "signup" : "login");
            setError(null);
            setSignupSuccess(false);
          }}
          style={styles.toggleBtn}
          disabled={busy}
        >
          {mode === "login"
            ? "Don't have an account? Sign up"
            : "Already have an account? Sign in"}
        </button>

        {!isNative && (
          <div style={styles.note}>
            Apple Sign-In is available in the installed iOS app.
          </div>
        )}
      </div>
    </div>
  );
}

function AppleMark() {
  return (
    <svg
      width="18"
      height="18"
      viewBox="0 0 24 24"
      aria-hidden="true"
      style={{ marginRight: 10, flexShrink: 0 }}
    >
      <path
        fill="currentColor"
        d="M16.365 1.43c0 1.14-.48 2.22-1.26 3.06-.81.87-2.14 1.55-3.31 1.46-.15-1.1.43-2.27 1.19-3.07.84-.89 2.24-1.54 3.38-1.45ZM20.39 17.13c-.54 1.24-.8 1.8-1.5 2.9-.98 1.52-2.36 3.41-4.06 3.43-1.51.02-1.9-.99-3.96-.98-2.06.01-2.49 1.0-4 .98-1.7-.02-3-1.73-3.98-3.25-2.74-4.24-3.03-9.22-1.34-11.82 1.2-1.86 3.1-2.96 4.89-2.96 1.83 0 2.98 1.0 4.49 1.0 1.47 0 2.36-1.0 4.47-1.0 1.6 0 3.3.87 4.5 2.36-3.95 2.16-3.31 7.78.49 9.34Z"
      />
    </svg>
  );
}

function GoogleG() {
  return (
    <svg
      width="18"
      height="18"
      viewBox="0 0 24 24"
      aria-hidden="true"
      style={{ marginRight: 10, flexShrink: 0 }}
    >
      <path
        d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 01-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"
        fill="#4285F4"
      />
      <path
        d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
        fill="#34A853"
      />
      <path
        d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
        fill="#FBBC05"
      />
      <path
        d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
        fill="#EA4335"
      />
    </svg>
  );
}

/* ── Inline styles ─────────────────────── */

const styles: Record<string, React.CSSProperties> = {
  page: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    minHeight: "100vh",
    padding: 20,
    background: "var(--roam-bg, #0b0d10)",
  },
  card: {
    display: "flex",
    flexDirection: "column",
    gap: 12,
    width: "100%",
    maxWidth: 360,
  },
  title: {
    fontSize: 28,
    fontWeight: 800,
    textAlign: "center",
    letterSpacing: "-0.02em",
    color: "var(--roam-text, #fff)",
  },
  subtitle: {
    fontSize: 14,
    textAlign: "center",
    color: "var(--roam-muted, #9aa0a6)",
    marginBottom: 8,
  },

  // Apple: match native “Sign in with Apple” feel
  appleBtn: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "100%",
    height: 44, // iOS standard control height
    padding: "0 16px",
    borderRadius: 10,
    border: "1px solid rgba(255,255,255,0.12)",
    background: "#000000",
    color: "#ffffff",
    fontSize: 16,
    fontWeight: 700,
    cursor: "pointer",
    WebkitTapHighlightColor: "transparent",
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
    letterSpacing: "-0.01em",
    userSelect: "none",
  },
  appleBtnText: {
    lineHeight: 1,
    transform: "translateY(0.5px)", // tiny optical alignment with mark
  },

  googleBtn: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "100%",
    height: 44,
    padding: "0 16px",
    borderRadius: 10,
    border: "1px solid var(--roam-border, rgba(255,255,255,0.12))",
    background: "var(--roam-surface, rgba(255,255,255,0.06))",
    color: "var(--roam-text, #eee)",
    fontSize: 15,
    fontWeight: 600,
    cursor: "pointer",
    WebkitTapHighlightColor: "transparent",
    userSelect: "none",
  },

  btnDisabled: {
    opacity: 0.6,
    cursor: "not-allowed",
  },

  divider: {
    display: "flex",
    alignItems: "center",
    gap: 12,
    margin: "6px 0",
  },
  dividerLine: {
    flex: 1,
    height: 1,
    background: "var(--roam-border, rgba(255,255,255,0.12))",
  },
  dividerText: {
    fontSize: 12,
    color: "var(--roam-muted, #9aa0a6)",
  },

  input: {
    width: "100%",
    height: 44,
    padding: "0 14px",
    borderRadius: 10,
    border: "1px solid var(--roam-border, rgba(255,255,255,0.12))",
    background: "var(--roam-surface, rgba(255,255,255,0.06))",
    color: "var(--roam-text, #eee)",
    fontSize: 15,
    outline: "none",
    boxSizing: "border-box",
  },

  primaryBtn: {
    width: "100%",
    height: 44,
    padding: "0 16px",
    borderRadius: 10,
    border: "none",
    background: "var(--roam-accent, #3b82f6)",
    color: "#fff",
    fontSize: 15,
    fontWeight: 800,
    cursor: "pointer",
    WebkitTapHighlightColor: "transparent",
    userSelect: "none",
  },

  error: {
    padding: "10px 12px",
    borderRadius: 10,
    background: "rgba(239,68,68,0.14)",
    color: "#ff9aa0",
    fontSize: 13,
    textAlign: "center",
    border: "1px solid rgba(239,68,68,0.22)",
  },
  success: {
    padding: "10px 12px",
    borderRadius: 10,
    background: "rgba(34,197,94,0.14)",
    color: "#7CFFB0",
    fontSize: 13,
    textAlign: "center",
    border: "1px solid rgba(34,197,94,0.22)",
  },

  toggleBtn: {
    background: "none",
    border: "none",
    color: "var(--roam-accent, #3b82f6)",
    fontSize: 13,
    cursor: "pointer",
    textAlign: "center",
    padding: "8px 0",
  },

  note: {
    marginTop: 4,
    fontSize: 12,
    color: "var(--roam-muted, #9aa0a6)",
    textAlign: "center",
  },
};


===== src/app/new/ClientPage.tsx =====

"use client";

import { useCallback, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";

import type { NavPack } from "@/lib/types/navigation";

import { navApi } from "@/lib/api/nav";
import { haptic } from "@/lib/native/haptics";
import { useBundleBuilder } from "@/lib/hooks/useBundleBuilder";

import { useNewTripDraft } from "@/components/trips/new/useNewTripDraft";
import { NewTripMap } from "@/components/trips/new/NewTripMap";
import { StopsEditor } from "@/components/trips/new/StopsEditor";
import { PlaceSearchModal } from "@/components/trips/new/PlaceSearchModal";
import {
  MapStyleSwitcher,
  type MapBaseMode,
  type VectorTheme,
} from "@/components/trips/new/MapStyleSwitcher";
import { InviteCodeModal } from "@/components/plans/InviteCodeModal";

function genPlanId() {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) return (crypto as any).randomUUID();
  return `plan_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`;
}

export default function NewTripClientPage() {
  const router = useRouter();
  const draft = useNewTripDraft();
  const bundle = useBundleBuilder();

  const [navPack, setNavPack] = useState<NavPack | null>(null);
  const [routing, setRouting] = useState(false);
  const [routeError, setRouteError] = useState<string | null>(null);

  const [searchOpen, setSearchOpen] = useState(false);
  const [searchTargetStopId, setSearchTargetStopId] = useState<string | null>(null);

  const [baseMode, setBaseMode] = useState<MapBaseMode>("vector");
  const [vectorTheme, setVectorTheme] = useState<VectorTheme>("bright");

  // Invite modal
  const [inviteOpen, setInviteOpen] = useState(false);

  const styleId = useMemo(() => {
    if (baseMode === "hybrid") return "roam-basemap-hybrid";
    return vectorTheme === "dark" ? "roam-basemap-vector-dark" : "roam-basemap-vector-bright";
  }, [baseMode, vectorTheme]);

  const canRoute = useMemo(() => {
    const s = draft.stops;
    return s.length >= 2 && s.some((x) => x.type === "start") && s.some((x) => x.type === "end");
  }, [draft.stops]);

  const planIdRef = useRef<string | null>(null);

  /* ── Route preview (quick, no bundle) ──────────────────────────────── */

  const requestRoute = useCallback(async () => {
    if (!canRoute) return;
    setRouteError(null);
    setRouting(true);
    try {
      const pack = await navApi.route({
        profile: draft.profile,
        prefs: draft.prefs,
        avoid: draft.avoid,
        stops: draft.stops,
        depart_at: draft.depart_at ?? null,
      });
      setNavPack(pack);
    } catch (e: any) {
      setNavPack(null);
      setRouteError(e?.message ?? "Failed to build route");
    } finally {
      setRouting(false);
    }
  }, [canRoute, draft]);

  /* ── Search modal ──────────────────────────────────────────────────── */

  const openSearchForStop = useCallback((stopId: string) => {
    setSearchTargetStopId(stopId);
    setSearchOpen(true);
  }, []);

  const onPickPlace = useCallback(
    (args: { stopId: string; name: string; lat: number; lng: number }) => {
      draft.updateStop(args.stopId, { name: args.name, lat: args.lat, lng: args.lng });
      setSearchOpen(false);
      setSearchTargetStopId(null);
      setNavPack(null);
      setRouteError(null);
      bundle.reset();
    },
    [draft, bundle],
  );

  /* ── Clear route + artifacts on any stop/profile change ────────────── */

  const clearRouteState = useCallback(() => {
    setNavPack(null);
    setRouteError(null);
    bundle.reset();
  }, [bundle]);

  /* ── Full offline save (extracted pipeline) ────────────────────────── */

  const saveTripOfflineReady = useCallback(async () => {
    if (!canRoute) return;

    haptic.medium();

    const plan_id: string = planIdRef.current ?? genPlanId();
    planIdRef.current = plan_id;

    try {
      const result = await bundle.build({
        plan_id,
        stops: draft.stops,
        profile: draft.profile,
        prefs: draft.prefs,
        avoid: draft.avoid,
        depart_at: draft.depart_at,
        styleId,
        existingNavPack: navPack,
      });

      setNavPack(result.navPack);
      router.replace(`/trip?plan_id=${encodeURIComponent(plan_id)}`);
    } catch {
      // bundle hook already populates bundle.error / bundle.phase
    }
  }, [canRoute, draft, styleId, navPack, bundle, router]);

  /* ── Render ────────────────────────────────────────────────────────── */

  return (
    <div className="trip-app-container">
      <NewTripMap
        stops={draft.stops}
        navPack={navPack}
        styleId={styleId}
        onMapCenterChanged={draft.setMapCenter}
      />

      <MapStyleSwitcher
        mode={baseMode}
        vectorTheme={vectorTheme}
        onChange={(next) => {
          setBaseMode(next.mode);
          setVectorTheme(next.vectorTheme);
          bundle.reset();
        }}
      />

      <StopsEditor
        profile={draft.profile}
        onProfileChange={(p) => {
          draft.setProfile(p);
          clearRouteState();
        }}
        stops={draft.stops}
        onAddStop={(t) => {
          draft.addStop(t as any);
          clearRouteState();
        }}
        onRemoveStop={(id) => {
          draft.removeStop(id);
          clearRouteState();
        }}
        onReorderStop={(a, b) => {
          draft.reorderStop(a, b);
          clearRouteState();
        }}
        onEditStop={(id, patch) => {
          draft.updateStop(id, patch);
          clearRouteState();
        }}
        onUseMyLocation={() => {
          draft.useMyLocationForStart();
          clearRouteState();
        }}
        onSearchStop={openSearchForStop}
        onJoinPlan={() => {
          setInviteOpen(true);
        }}
        onBuildRoute={requestRoute}
        canBuildRoute={canRoute}
        routing={routing}
        error={routeError}
        onBuildOffline={saveTripOfflineReady}
        onDownloadOffline={() => {}}
        onSaveOffline={() => {}}
        onResetOffline={() => {
          planIdRef.current = null;
          bundle.reset();
        }}
        offlinePhase={bundle.phase as any}
        offlineError={bundle.error}
        offlineManifest={bundle.result?.manifest ?? null}
        canDownloadOffline={false}
        savingOffline={bundle.building}
        savedOffline={bundle.isReady}
      />

      {/* Status overlay */}
      {(bundle.building || bundle.phase !== "idle") && (
        <div
          style={{
            position: "absolute",
            left: 12,
            right: 12,
            bottom: 12,
            zIndex: 50,
            pointerEvents: "none",
          }}
        >
          <div
            style={{
              width: "100%",
              borderRadius: 14,
              padding: "12px 14px",
              background: "rgba(0,0,0,0.55)",
              backdropFilter: "blur(10px)",
              color: "white",
              fontSize: 13,
              fontWeight: 900,
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              gap: 10,
            }}
          >
            <span style={{ opacity: 0.95 }}>{bundle.statusText}</span>
            <span style={{ opacity: 0.75, fontWeight: 800 }}>
              {bundle.building ? "…" : bundle.isReady ? "✓" : ""}
            </span>
          </div>
        </div>
      )}

      <PlaceSearchModal
        open={searchOpen}
        stopId={searchTargetStopId}
        onClose={() => {
          setSearchOpen(false);
          setSearchTargetStopId(null);
        }}
        mapCenter={draft.mapCenter}
        onPick={onPickPlace}
      />

      {/* ── Invite modal (redeem-only from /new) ─────────────────────── */}
      <InviteCodeModal
        open={inviteOpen}
        planId={null}
        mode="redeem"
        onClose={() => setInviteOpen(false)}
        onRedeemed={(joinedPlanId) => {
          setInviteOpen(false);
        }}
      />
    </div>
  );
}

===== src/app/new/page.tsx =====

// src/app/(shell)/new/page.tsx
import NewTripClientPage from "./ClientPage";

export default function Page() {
  return <NewTripClientPage />;
}


===== src/app/not-found.tsx =====

import { NotFoundClient } from "@/components/ui/NotFoundClient";

export default function NotFound() {
  return <NotFoundClient />;
}

===== src/app/page.tsx =====

// src/app/(shell)/page.tsx
import { redirect } from "next/navigation";

export default function Page() {
  redirect("/trip");
}


===== src/app/plans/ClientPage.tsx =====

// src/app/plans/PlansClientPage.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import {
  MapPin,
  Plus,
  Navigation,
  Clock,
  HardDrive,
  Trash2,
  ChevronRight,
  Pencil,
  Check,
  X,
  Star,
  Route,
  Share2,
  Link2,
  Users,
} from "lucide-react";

import type { OfflinePlanRecord } from "@/lib/offline/plansStore";
import {
  deleteOfflinePlan,
  getCurrentPlanId,
  listOfflinePlans,
  renameOfflinePlan,
  setCurrentPlanId,
} from "@/lib/offline/plansStore";
import { haptic } from "@/lib/native/haptics";
import { InviteCodeModal } from "@/components/plans/InviteCodeModal";

/* ── Formatters ──────────────────────────────────────────────────────── */

function fmtBytes(n?: number) {
  if (!n || n <= 0) return "—";
  const kb = n / 1024;
  if (kb < 1024) return `${kb.toFixed(0)} KB`;
  const mb = kb / 1024;
  if (mb < 1024) return `${mb.toFixed(1)} MB`;
  return `${(mb / 1024).toFixed(2)} GB`;
}

function fmtKm(m?: number) {
  if (!m) return "—";
  const km = m / 1000;
  return km >= 100 ? `${km.toFixed(0)} km` : `${km.toFixed(1)} km`;
}

function fmtDuration(s?: number) {
  if (!s) return "—";
  const h = Math.floor(s / 3600);
  const m = Math.round((s % 3600) / 60);
  if (h === 0) return `${m} min`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function fmtRelativeTime(iso: string): string {
  const diff = Date.now() - new Date(iso).getTime();
  const mins = Math.floor(diff / 60_000);
  if (mins < 1) return "Just now";
  if (mins < 60) return `${mins}m ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs}h ago`;
  const days = Math.floor(hrs / 24);
  if (days === 1) return "Yesterday";
  if (days < 7) return `${days}d ago`;
  return new Date(iso).toLocaleDateString([], { month: "short", day: "numeric" });
}

function routeLabel(p: OfflinePlanRecord): string {
  const stops = p.preview?.stops;
  if (!stops || stops.length === 0) return "Unnamed route";
  const start = stops.find((s) => s.type === "start");
  const end = stops.find((s) => s.type === "end");
  const startName = start?.name?.replace(/^My location$/i, "Current location") || "?";
  const endName = end?.name || "?";
  if (startName === endName) return startName;
  return `${startName} → ${endName}`;
}

function stopCount(p: OfflinePlanRecord): number {
  const stops = p.preview?.stops;
  if (!stops) return 0;
  return stops.filter((s) => s.type !== "start" && s.type !== "end").length;
}

/* ── Inline rename component ─────────────────────────────────────────── */

function InlineRename({
  planId,
  currentLabel,
  fallback,
  onDone,
}: {
  planId: string;
  currentLabel: string | null | undefined;
  fallback: string;
  onDone: (newLabel: string | null) => void;
}) {
  const [editing, setEditing] = useState(false);
  const [value, setValue] = useState(currentLabel?.trim() || "");
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (editing) {
      inputRef.current?.focus();
      inputRef.current?.select();
    }
  }, [editing]);

  const save = useCallback(async () => {
    const trimmed = value.trim();
    try {
      await renameOfflinePlan(planId, trimmed);
      haptic.light();
      onDone(trimmed || null);
    } catch {
      // revert silently
    }
    setEditing(false);
  }, [planId, value, onDone]);

  const cancel = useCallback(() => {
    setValue(currentLabel?.trim() || "");
    setEditing(false);
  }, [currentLabel]);

  if (!editing) {
    return (
      <button
        type="button"
        onClick={(e) => {
          e.stopPropagation();
          haptic.light();
          setValue(currentLabel?.trim() || "");
          setEditing(true);
        }}
        style={{
          all: "unset",
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
          gap: 6,
          maxWidth: "100%",
        }}
      >
        <span
          style={{
            fontSize: 15,
            fontWeight: 700,
            color: "var(--roam-text)",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
          }}
        >
          {currentLabel?.trim() || fallback}
        </span>
        <Pencil
          size={13}
          style={{ flexShrink: 0, color: "var(--roam-text-muted)", opacity: 0.5 }}
        />
      </button>
    );
  }

  return (
    <div
      style={{ display: "flex", alignItems: "center", gap: 6, width: "100%" }}
      onClick={(e) => e.stopPropagation()}
    >
      <input
        ref={inputRef}
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === "Enter") save();
          if (e.key === "Escape") cancel();
        }}
        maxLength={100}
        placeholder="Trip name…"
        style={{
          flex: 1,
          fontSize: 15,
          fontWeight: 700,
          color: "var(--roam-text)",
          background: "var(--roam-surface-raised, var(--roam-surface))",
          border: "1.5px solid var(--brand-sky, #3b82f6)",
          borderRadius: 8,
          padding: "6px 10px",
          outline: "none",
          minWidth: 0,
        }}
      />
      <button
        type="button"
        onClick={save}
        style={{
          all: "unset",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: 30,
          height: 30,
          borderRadius: 8,
          background: "var(--brand-sky, #3b82f6)",
          color: "white",
          flexShrink: 0,
        }}
      >
        <Check size={16} />
      </button>
      <button
        type="button"
        onClick={cancel}
        style={{
          all: "unset",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: 30,
          height: 30,
          borderRadius: 8,
          background: "var(--roam-surface)",
          border: "1px solid var(--roam-border)",
          color: "var(--roam-text-muted)",
          flexShrink: 0,
        }}
      >
        <X size={16} />
      </button>
    </div>
  );
}

/* ── Status dot ──────────────────────────────────────────────────────── */

function StatusDot({ status }: { status?: string }) {
  const color =
    status === "ready"
      ? "#22c55e"
      : status === "error"
        ? "#ef4444"
        : "var(--roam-text-muted)";

  return (
    <span
      style={{
        display: "inline-block",
        width: 7,
        height: 7,
        borderRadius: "50%",
        background: color,
        flexShrink: 0,
      }}
    />
  );
}

/* ── Plan Card ───────────────────────────────────────────────────────── */

function PlanCard({
  plan,
  isCurrent,
  busy,
  onOpen,
  onSetActive,
  onDelete,
  onShare,
  onLabelChanged,
}: {
  plan: OfflinePlanRecord;
  isCurrent: boolean;
  busy: boolean;
  onOpen: () => void;
  onSetActive: () => void;
  onDelete: () => void;
  onShare: () => void;
  onLabelChanged: (label: string | null) => void;
}) {
  const stops = stopCount(plan);
  const label = routeLabel(plan);

  return (
    <div
      style={{
        background: "var(--roam-card-bg, var(--roam-surface))",
        borderRadius: 16,
        border: isCurrent
          ? "2px solid var(--brand-sky, #3b82f6)"
          : "1px solid var(--roam-border)",
        overflow: "hidden",
        transition: "border-color 0.2s, box-shadow 0.2s",
        boxShadow: isCurrent
          ? "0 0 0 3px rgba(59,130,246,0.12)"
          : "0 1px 3px rgba(0,0,0,0.06)",
      }}
    >
      {/* ── Main content (tappable to open) ──────────────────── */}
      <div
        role="button"
        tabIndex={0}
        onClick={onOpen}
        onKeyDown={(e) => e.key === "Enter" && onOpen()}
        style={{
          padding: "16px 16px 12px",
          cursor: "pointer",
          WebkitTapHighlightColor: "transparent",
        }}
      >
        {/* Top row: label + badges */}
        <div
          style={{
            display: "flex",
            alignItems: "flex-start",
            justifyContent: "space-between",
            gap: 8,
            marginBottom: 8,
          }}
        >
          <div style={{ flex: 1, minWidth: 0 }}>
            <InlineRename
              planId={plan.plan_id}
              currentLabel={plan.label}
              fallback={label}
              onDone={onLabelChanged}
            />
          </div>
          <div style={{ display: "flex", gap: 4, flexShrink: 0 }}>
            {plan.is_shared && (
              <span
                style={{
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 3,
                  padding: "3px 7px",
                  borderRadius: 6,
                  background: "rgba(168,85,247,0.12)",
                  color: "#a855f7",
                  fontSize: 11,
                  fontWeight: 800,
                  letterSpacing: 0.3,
                  textTransform: "uppercase",
                  whiteSpace: "nowrap",
                }}
              >
                <Users size={9} />
                Shared
              </span>
            )}
            {isCurrent && (
              <span
                style={{
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 4,
                  padding: "3px 8px",
                  borderRadius: 6,
                  background: "rgba(59,130,246,0.12)",
                  color: "var(--brand-sky, #3b82f6)",
                  fontSize: 11,
                  fontWeight: 800,
                  letterSpacing: 0.3,
                  textTransform: "uppercase",
                  whiteSpace: "nowrap",
                }}
              >
                <Star size={10} fill="currentColor" />
                Active
              </span>
            )}
          </div>
        </div>

        {/* Route summary (when custom label is set) */}
        {plan.label?.trim() ? (
          <div
            style={{
              fontSize: 12,
              color: "var(--roam-text-muted)",
              marginBottom: 8,
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap",
            }}
          >
            {label}
          </div>
        ) : null}

        {/* Stats row */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: 14,
            fontSize: 12,
            color: "var(--roam-text-muted)",
            fontWeight: 500,
          }}
        >
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <Route size={12} />
            {fmtKm(plan.preview?.distance_m)}
          </span>
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <Clock size={12} />
            {fmtDuration(plan.preview?.duration_s)}
          </span>
          {stops > 0 && (
            <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
              <MapPin size={12} />
              {stops} stop{stops !== 1 ? "s" : ""}
            </span>
          )}
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <HardDrive size={12} />
            {fmtBytes(plan.zip_bytes)}
          </span>
        </div>

        {/* Bundle readiness row */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: 10,
            marginTop: 10,
            fontSize: 11,
            color: "var(--roam-text-muted)",
            fontWeight: 500,
          }}
        >
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <StatusDot status={plan.corridor_status} /> Corridor
          </span>
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <StatusDot status={plan.places_status} /> Places
          </span>
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <StatusDot status={plan.traffic_status} /> Traffic
          </span>
          <span style={{ display: "inline-flex", alignItems: "center", gap: 4 }}>
            <StatusDot status={plan.hazards_status} /> Hazards
          </span>
          <span style={{ marginLeft: "auto", opacity: 0.6, fontSize: 11 }}>
            {fmtRelativeTime(plan.saved_at)}
          </span>
        </div>
      </div>

      {/* ── Actions bar ──────────────────────────────────────── */}
      <div style={{ display: "flex", borderTop: "1px solid var(--roam-border)" }}>
        {!isCurrent && (
          <button
            type="button"
            disabled={busy}
            onClick={(e) => {
              e.stopPropagation();
              onSetActive();
            }}
            style={{
              all: "unset",
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: 6,
              padding: "11px 0",
              fontSize: 13,
              fontWeight: 700,
              color: "var(--brand-sky, #3b82f6)",
              cursor: busy ? "default" : "pointer",
              opacity: busy ? 0.4 : 1,
              borderRight: "1px solid var(--roam-border)",
              WebkitTapHighlightColor: "transparent",
            }}
          >
            <Star size={13} />
            Set Active
          </button>
        )}

        <button
          type="button"
          disabled={busy}
          onClick={(e) => {
            e.stopPropagation();
            onOpen();
          }}
          style={{
            all: "unset",
            flex: 1,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: 6,
            padding: "11px 0",
            fontSize: 13,
            fontWeight: 700,
            color: "var(--roam-text)",
            cursor: busy ? "default" : "pointer",
            opacity: busy ? 0.4 : 1,
            borderRight: "1px solid var(--roam-border)",
            WebkitTapHighlightColor: "transparent",
          }}
        >
          <Navigation size={13} />
          Open
          <ChevronRight size={14} style={{ opacity: 0.4 }} />
        </button>

        {/* Share button */}
        <button
          type="button"
          disabled={busy}
          onClick={(e) => {
            e.stopPropagation();
            onShare();
          }}
          style={{
            all: "unset",
            flex: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: "11px 14px",
            fontSize: 13,
            fontWeight: 700,
            color: "#a855f7",
            cursor: busy ? "default" : "pointer",
            opacity: busy ? 0.4 : 1,
            borderRight: "1px solid var(--roam-border)",
            WebkitTapHighlightColor: "transparent",
          }}
        >
          <Share2 size={14} />
        </button>

        <button
          type="button"
          disabled={busy}
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
          style={{
            all: "unset",
            flex: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: "11px 16px",
            fontSize: 13,
            fontWeight: 700,
            color: "var(--roam-danger, #ef4444)",
            cursor: busy ? "default" : "pointer",
            opacity: busy ? 0.4 : 1,
            WebkitTapHighlightColor: "transparent",
          }}
        >
          <Trash2 size={14} />
        </button>
      </div>
    </div>
  );
}

/* ── Main Page ───────────────────────────────────────────────────────── */

export function PlansClientPage() {
  const router = useRouter();

  const [plans, setPlans] = useState<OfflinePlanRecord[]>([]);
  const [currentId, setCurrentIdLocal] = useState<string | null>(null);
  const [busyId, setBusyId] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const [loaded, setLoaded] = useState(false);

  // Invite modal state
  const [inviteOpen, setInviteOpen] = useState(false);
  const [inviteMode, setInviteMode] = useState<"create" | "redeem">("redeem");
  const [invitePlanId, setInvitePlanId] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    try {
      const [p, cur] = await Promise.all([listOfflinePlans(), getCurrentPlanId()]);
      setPlans(p);
      setCurrentIdLocal(cur);
    } catch (e: any) {
      setErr(e?.message ?? "Failed to load plans");
    } finally {
      setLoaded(true);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  const hasPlans = plans.length > 0;

  const sorted = useMemo(() => {
    const cur = currentId;
    const copy = [...plans];
    copy.sort((a, b) => {
      const ac = a.plan_id === cur ? -1 : 0;
      const bc = b.plan_id === cur ? -1 : 0;
      if (ac !== bc) return ac - bc;
      return (b.saved_at ?? "").localeCompare(a.saved_at ?? "");
    });
    return copy;
  }, [plans, currentId]);

  const handleSetActive = useCallback(async (planId: string) => {
    haptic.medium();
    setBusyId(planId);
    setErr(null);
    try {
      await setCurrentPlanId(planId);
      setCurrentIdLocal(planId);
    } catch (e: any) {
      setErr(e?.message ?? "Failed to set active");
    } finally {
      setBusyId(null);
    }
  }, []);

  const handleDelete = useCallback(
    async (planId: string) => {
      if (!window.confirm("Delete this plan and all its offline data from this device?")) return;
      haptic.medium();
      setBusyId(planId);
      setErr(null);
      try {
        await deleteOfflinePlan(planId);
        haptic.success();
        await refresh();
      } catch (e: any) {
        setErr(e?.message ?? "Failed to delete");
        haptic.error();
      } finally {
        setBusyId(null);
      }
    },
    [refresh],
  );

  const handleOpen = useCallback(
    (planId: string) => {
      haptic.light();
      router.push(`/trip?plan_id=${encodeURIComponent(planId)}`);
    },
    [router],
  );

  const handleShare = useCallback((planId: string) => {
    haptic.light();
    setInvitePlanId(planId);
    setInviteMode("create");
    setInviteOpen(true);
  }, []);

  const handleJoin = useCallback(() => {
    haptic.light();
    setInvitePlanId(null);
    setInviteMode("redeem");
    setInviteOpen(true);
  }, []);

  const handleLabelChanged = useCallback((planId: string, label: string | null) => {
    setPlans((prev) => prev.map((p) => (p.plan_id === planId ? { ...p, label } : p)));
  }, []);

  return (
    <div className="trip-app-container" style={{ overflowY: "auto" }}>
      <div
        style={{
          padding: "20px 16px",
          paddingBottom: "calc(var(--bottom-nav-height, 80px) + 40px)",
          maxWidth: 480,
          margin: "0 auto",
          display: "flex",
          flexDirection: "column",
          gap: 12,
        }}
      >
        {/* ── Header ─────────────────────────────────────────── */}
        <div
          style={{
            display: "flex",
            alignItems: "flex-end",
            justifyContent: "space-between",
            marginBottom: 4,
          }}
        >
          <div>
            <h1
              style={{
                fontSize: 26,
                fontWeight: 900,
                color: "var(--roam-text)",
                margin: 0,
                letterSpacing: -0.5,
              }}
            >
              Plans
            </h1>
            <p
              style={{
                fontSize: 13,
                color: "var(--roam-text-muted)",
                margin: "4px 0 0",
                fontWeight: 500,
              }}
            >
              {hasPlans
                ? `${plans.length} saved trip${plans.length !== 1 ? "s" : ""}`
                : "No offline plans yet"}
            </p>
          </div>

          {/* Header action buttons */}
          <div style={{ display: "flex", gap: 8 }}>
            {/* Join Plan button */}
            <button
              type="button"
              onClick={handleJoin}
              aria-label="Join Plan"
              style={{
                all: "unset",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 5,
                height: 40,
                padding: "0 14px",
                borderRadius: 12,
                background: "var(--roam-surface)",
                border: "1px solid var(--roam-border)",
                color: "var(--roam-text)",
                fontSize: 13,
                fontWeight: 700,
                WebkitTapHighlightColor: "transparent",
                transition: "transform 0.1s",
              }}
            >
              <Link2 size={15} />
              Join
            </button>

            {/* New Plan button */}
            <button
              type="button"
              onClick={() => {
                haptic.light();
                router.push("/new");
              }}
              aria-label="New Plan"
              style={{
                all: "unset",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                width: 40,
                height: 40,
                borderRadius: 12,
                background: "var(--brand-sky, #3b82f6)",
                color: "white",
                boxShadow: "0 2px 8px rgba(59,130,246,0.3)",
                WebkitTapHighlightColor: "transparent",
                transition: "transform 0.1s",
              }}
            >
              <Plus size={22} strokeWidth={2.5} />
            </button>
          </div>
        </div>

        {/* ── Error banner ───────────────────────────────────── */}
        {err && (
          <div
            style={{
              padding: "10px 14px",
              borderRadius: 10,
              background: "rgba(239,68,68,0.08)",
              border: "1px solid rgba(239,68,68,0.2)",
              color: "var(--roam-danger, #ef4444)",
              fontSize: 13,
              fontWeight: 600,
            }}
          >
            {err}
          </div>
        )}

        {/* ── Empty state ────────────────────────────────────── */}
        {loaded && !hasPlans && (
          <div
            style={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              textAlign: "center",
              padding: "48px 24px",
              gap: 16,
            }}
          >
            <div
              style={{
                width: 64,
                height: 64,
                borderRadius: 20,
                background: "var(--roam-surface)",
                border: "1px solid var(--roam-border)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              <Navigation size={28} style={{ color: "var(--roam-text-muted)", opacity: 0.5 }} />
            </div>
            <div>
              <div
                style={{
                  fontSize: 17,
                  fontWeight: 700,
                  color: "var(--roam-text)",
                  marginBottom: 6,
                }}
              >
                No trips saved yet
              </div>
              <div
                style={{
                  fontSize: 13,
                  color: "var(--roam-text-muted)",
                  lineHeight: 1.5,
                  maxWidth: 260,
                }}
              >
                Build a route in <strong>New</strong>, then hit{" "}
                <strong>Build Offline</strong> to save it here. Or{" "}
                <strong>join a shared plan</strong> from your travel partner.
              </div>
            </div>
            <div style={{ display: "flex", gap: 10 }}>
              <button
                type="button"
                onClick={() => router.push("/new")}
                style={{
                  all: "unset",
                  cursor: "pointer",
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 6,
                  padding: "10px 20px",
                  borderRadius: 10,
                  background: "var(--brand-sky, #3b82f6)",
                  color: "white",
                  fontSize: 14,
                  fontWeight: 700,
                  boxShadow: "0 2px 8px rgba(59,130,246,0.25)",
                  WebkitTapHighlightColor: "transparent",
                }}
              >
                <Plus size={16} />
                Plan a trip
              </button>
              <button
                type="button"
                onClick={handleJoin}
                style={{
                  all: "unset",
                  cursor: "pointer",
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 6,
                  padding: "10px 20px",
                  borderRadius: 10,
                  background: "var(--roam-surface)",
                  border: "1px solid var(--roam-border)",
                  color: "var(--roam-text)",
                  fontSize: 14,
                  fontWeight: 700,
                  WebkitTapHighlightColor: "transparent",
                }}
              >
                <Link2 size={16} />
                Join plan
              </button>
            </div>
          </div>
        )}

        {/* ── Plans list ─────────────────────────────────────── */}
        {sorted.map((p) => (
          <PlanCard
            key={p.plan_id}
            plan={p}
            isCurrent={p.plan_id === currentId}
            busy={busyId === p.plan_id}
            onOpen={() => handleOpen(p.plan_id)}
            onSetActive={() => handleSetActive(p.plan_id)}
            onDelete={() => handleDelete(p.plan_id)}
            onShare={() => handleShare(p.plan_id)}
            onLabelChanged={(label) => handleLabelChanged(p.plan_id, label)}
          />
        ))}
      </div>

      {/* ── Invite modal (create or redeem) ──────────────────────────── */}
      <InviteCodeModal
        open={inviteOpen}
        planId={invitePlanId}
        mode={inviteMode}
        onClose={() => {
          setInviteOpen(false);
          setInvitePlanId(null);
        }}
        onRedeemed={(joinedPlanId) => {
          setInviteOpen(false);
          setInvitePlanId(null);
          // Refresh the list to show the newly joined plan
          refresh();
        }}
      />
    </div>
  );
}

===== src/app/plans/page.tsx =====

// src/app/plans/page.tsx
import { PlansClientPage } from "./ClientPage";

export default function PlansPage() {
  return <PlansClientPage />;
}


===== src/app/sos/ClientPage.tsx =====

// src/app/sos/ClientPage.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { haptic } from "@/lib/native/haptics";
import { useAuth } from "@/lib/supabase/auth";
import { listEmergencyContacts } from "@/lib/offline/emergencyStore";
import { emergencySyncOnce } from "@/lib/offline/emergencySync";
import { saveEmergencyContactLocalFirst, deleteEmergencyContactLocalFirst } from "@/lib/emergency/emergencyActions";

import type { EmergencyContactLocal } from "@/lib/types/emergency";
import { PhoneCall, MessageSquareText, Plus, Pencil, Trash2, Satellite, MapPin } from "lucide-react";

function nowIso() {
  return new Date().toISOString();
}

function randomId() {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) return (crypto as any).randomUUID();
  return `em_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
}

function useOnlineStatus() {
  const [online, setOnline] = useState<boolean>(() =>
    typeof navigator !== "undefined" ? navigator.onLine : true,
  );
  useEffect(() => {
    const on = () => setOnline(true);
    const off = () => setOnline(false);
    window.addEventListener("online", on);
    window.addEventListener("offline", off);
    return () => {
      window.removeEventListener("online", on);
      window.removeEventListener("offline", off);
    };
  }, []);
  return online;
}

function telHref(phone: string) {
  const trimmed = (phone ?? "").trim();
  const normalized = trimmed.replace(/[^\d+]/g, "");
  return `tel:${normalized}`;
}

function smsHref(phones: string[], body: string) {
  const normalizedPhones = (phones ?? [])
    .map((p) => (p ?? "").trim().replace(/[^\d+]/g, ""))
    .filter(Boolean);

  const to = normalizedPhones.join(",");
  return `sms:${to}?body=${encodeURIComponent(body ?? "")}`;
}

function fmt5(x: number) {
  return (Math.round(x * 1e5) / 1e5).toFixed(5);
}

function mapsLink(lat: number, lon: number) {
  return `https://maps.google.com/?q=${encodeURIComponent(`${lat},${lon}`)}`;
}

async function getPositionNative(timeoutMs = 120_000): Promise<{ lat: number; lon: number; accuracy_m: number | null }> {
  // Try Capacitor plugin dynamically (native)
  try {
    const mod: any = await import("@capacitor/geolocation");
    if (mod?.Geolocation?.getCurrentPosition) {
      const res = await mod.Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: timeoutMs,
        maximumAge: 5_000,
      });
      return {
        lat: res.coords.latitude,
        lon: res.coords.longitude,
        accuracy_m: typeof res.coords.accuracy === "number" ? res.coords.accuracy : null,
      };
    }
  } catch {
    // ignore
  }

  // Fallback: browser geolocation
  if (typeof navigator === "undefined" || !navigator.geolocation) {
    throw new Error("Geolocation not available on this device.");
  }

  const pos = await new Promise<GeolocationPosition>((resolve, reject) => {
    const t = setTimeout(() => reject(new Error("Location timeout.")), timeoutMs);
    navigator.geolocation.getCurrentPosition(
      (p) => {
        clearTimeout(t);
        resolve(p);
      },
      (e) => {
        clearTimeout(t);
        reject(new Error(e?.message || "Could not get location."));
      },
      { enableHighAccuracy: true, maximumAge: 5_000, timeout: timeoutMs },
    );
  });

  return {
    lat: pos.coords.latitude,
    lon: pos.coords.longitude,
    accuracy_m: typeof pos.coords.accuracy === "number" ? pos.coords.accuracy : null,
  };
}

export default function EmergencyClientPage() {
  const isOnline = useOnlineStatus();
  const { user } = useAuth();

  const [items, setItems] = useState<EmergencyContactLocal[]>([]);
  const [selectedIds, setSelectedIds] = useState<Record<string, boolean>>({});

  const [busy, setBusy] = useState<null | "boot" | "save" | "delete" | "sync" | "loc">(null);
  const [err, setErr] = useState<string | null>(null);
  const [elapsedWait, setElapsedWait] = useState(0); // Tracks seconds spent waiting for coaching msgs

  const [editingId, setEditingId] = useState<string | null>(null);
  const editing = useMemo(() => items.find((x) => x.id === editingId) ?? null, [items, editingId]);

  const [name, setName] = useState("");
  const [phone, setPhone] = useState("");
  const [relationship, setRelationship] = useState("");
  const [notes, setNotes] = useState("");

  const [lat, setLat] = useState<number | null>(null);
  const [lon, setLon] = useState<number | null>(null);
  const [accuracyM, setAccuracyM] = useState<number | null>(null);

  const didBootRef = useRef(false);
  const syncInFlightRef = useRef(false);
  const locInFlightRef = useRef(false);
  const timerDisplayRef = useRef<HTMLSpanElement>(null); // Fast DOM update ref

  const isLocating = lat == null || lon == null ? (busy === "boot" || busy === "loc") : false;

  // High-performance countdown timer & elapsed tracker
  useEffect(() => {
    if (!isLocating) {
      setElapsedWait(0);
      return;
    }

    const startTime = Date.now();
    const durationMs = 120_000; // 2 minutes
    const endTime = startTime + durationMs;
    let frameId: number;
    let lastSecond = 0;

    const updateTimer = () => {
      const now = Date.now();
      const remaining = Math.max(0, endTime - now);
      const elapsed = Math.floor((now - startTime) / 1000);

      // Update React state only once per second for dynamic coaching messages
      if (elapsed !== lastSecond) {
        setElapsedWait(elapsed);
        lastSecond = elapsed;
      }

      // Update the countdown DOM directly every frame for buttery smooth ms
      if (timerDisplayRef.current) {
        const mins = Math.floor(remaining / 60000);
        const secs = Math.floor((remaining % 60000) / 1000);
        const ms = Math.floor(remaining % 1000);

        const formattedTime = 
          String(mins).padStart(2, '0') + ':' + 
          String(secs).padStart(2, '0') + '.' + 
          String(ms).padStart(3, '0');

        timerDisplayRef.current.textContent = formattedTime;
      }

      if (remaining > 0) {
        frameId = requestAnimationFrame(updateTimer);
      }
    };

    frameId = requestAnimationFrame(updateTimer);

    return () => cancelAnimationFrame(frameId);
  }, [isLocating]);

  const refresh = useCallback(async () => {
    const next = await listEmergencyContacts();
    setItems(next);

    // Auto-select ALL contacts by default (emergency-first)
    setSelectedIds((prev) => {
      const hasAnyPrev = Object.keys(prev || {}).length > 0;
      if (hasAnyPrev) {
        const still: Record<string, boolean> = {};
        for (const c of next) if (prev[c.id]) still[c.id] = true;
        return still;
      }
      const all: Record<string, boolean> = {};
      for (const c of next) all[c.id] = true;
      return all;
    });
  }, []);

  const runAutoSync = useCallback(async () => {
    if (!user || !isOnline) return;
    if (syncInFlightRef.current) return;

    syncInFlightRef.current = true;
    setBusy((b) => (b ? b : "sync"));
    try {
      await emergencySyncOnce(user);
      await refresh();
    } catch (e: any) {
      setErr(e?.message ?? String(e));
    } finally {
      syncInFlightRef.current = false;
      setBusy((b) => (b === "sync" ? null : b));
    }
  }, [user, isOnline, refresh]);

  const fetchLocationAuto = useCallback(async () => {
    if (locInFlightRef.current) return;
    locInFlightRef.current = true;

    setBusy((b) => (b ? b : "loc"));
    setErr(null);
    try {
      const p = await getPositionNative(120_000); // 2 full minutes to allow hardware cold lock
      setLat(p.lat);
      setLon(p.lon);
      setAccuracyM(p.accuracy_m);
    } catch (e: any) {
      setErr(e?.message ?? String(e));
    } finally {
      locInFlightRef.current = false;
      setBusy((b) => (b === "loc" ? null : b));
    }
  }, []);

  // Boot: contacts + sync + location
  useEffect(() => {
    let cancelled = false;

    async function boot() {
      if (didBootRef.current) return;
      didBootRef.current = true;

      setBusy("boot");
      setErr(null);
      try {
        await refresh();
        if (cancelled) return;
        await runAutoSync();
        if (cancelled) return;

        // Immediate location fetch on load
        await fetchLocationAuto();
      } catch (e: any) {
        setErr(e?.message ?? String(e));
      } finally {
        if (!cancelled) setBusy(null);
      }
    }

    boot();
    return () => {
      cancelled = true;
    };
  }, [refresh, runAutoSync, fetchLocationAuto]);

  // Autosync loop
  useEffect(() => {
    runAutoSync();
  }, [runAutoSync]);

  useEffect(() => {
    if (!user || !isOnline) return;
    const t = setInterval(() => runAutoSync(), 30_000);
    return () => clearInterval(t);
  }, [user, isOnline, runAutoSync]);

  // Auto-refresh location periodically
  useEffect(() => {
    const t = setInterval(() => {
      fetchLocationAuto();
    }, 20_000);
    return () => clearInterval(t);
  }, [fetchLocationAuto]);

  // Populate editor
  useEffect(() => {
    if (!editing) {
      setName("");
      setPhone("");
      setRelationship("");
      setNotes("");
      return;
    }
    setName(editing.name ?? "");
    setPhone(editing.phone ?? "");
    setRelationship(editing.relationship ?? "");
    setNotes(editing.notes ?? "");
  }, [editingId]);

  const callEmergency = useCallback(() => {
    if (!confirm("Call 000 now?")) return;
    haptic.heavy();
    window.location.href = "tel:000";
  }, []);

  const toggleSelected = useCallback((id: string) => {
    haptic.selection();
    setSelectedIds((prev) => ({ ...prev, [id]: !prev[id] }));
  }, []);

  const selectedContacts = useMemo(() => {
    const map = selectedIds ?? {};
    return items.filter((c) => !!map[c.id]);
  }, [items, selectedIds]);

  const sendLocationToSelected = useCallback(async () => {
    if (selectedContacts.length === 0) {
      setErr("Select at least one contact.");
      haptic.error();
      return;
    }

    let useLat = lat;
    let useLon = lon;
    let acc = accuracyM;

    if (useLat == null || useLon == null) {
      setErr(null);
      setBusy("loc"); // Trigger the UI waiting state so they know it's working
      setElapsedWait(0);
      try {
        haptic.medium();
        const p = await getPositionNative(120_000); // 2 full minutes here too
        useLat = p.lat;
        useLon = p.lon;
        acc = p.accuracy_m;
        setLat(useLat);
        setLon(useLon);
        setAccuracyM(acc);
      } catch (e: any) {
        haptic.error();
        setErr(e?.message ?? String(e));
        setBusy(null);
        return;
      }
      setBusy(null);
    }

    const coords = `${fmt5(useLat!)}, ${fmt5(useLon!)}${acc ? ` (±${Math.round(acc)}m)` : ""}`;
    const link = mapsLink(useLat!, useLon!);
    const time = new Date().toLocaleString();

    const msg =
      `ROAM SAFETY: I need help.\n` +
      `Your coordinates are: ${coords}\n` +
      `Map: ${link}\n` +
      `Time: ${time}`;

    haptic.heavy();
    window.location.href = smsHref(selectedContacts.map((c) => c.phone), msg);
  }, [selectedContacts, lat, lon, accuracyM]);

  const startNew = useCallback(() => {
    haptic.selection();
    setErr(null);
    setEditingId("__new__");
    setName("");
    setPhone("");
    setRelationship("");
    setNotes("");
  }, []);

  const cancelEdit = useCallback(() => {
    haptic.selection();
    setErr(null);
    setEditingId(null);
  }, []);

  const save = useCallback(async () => {
    setBusy("save");
    setErr(null);
    try {
      haptic.medium();
      const id = editingId && editingId !== "__new__" ? editingId : randomId();

      await saveEmergencyContactLocalFirst({
        user,
        isOnline,
        contact: {
          id,
          name: name.trim(),
          phone: phone.trim(),
          relationship: relationship.trim() || null,
          notes: notes.trim() || null,
          updated_at: nowIso(),
        },
      });

      await refresh();
      setEditingId(null);
      runAutoSync();
      haptic.success();
    } catch (e: any) {
      haptic.error();
      setErr(e?.message ?? String(e));
    } finally {
      setBusy(null);
    }
  }, [editingId, name, phone, relationship, notes, user, isOnline, refresh, runAutoSync]);

  const remove = useCallback(
    async (id: string) => {
      if (!confirm("Delete this contact?")) return;
      setBusy("delete");
      setErr(null);
      try {
        haptic.heavy();
        await deleteEmergencyContactLocalFirst({ user, isOnline, id });
        await refresh();
        if (editingId === id) setEditingId(null);
        runAutoSync();
        haptic.success();
      } catch (e: any) {
        haptic.error();
        setErr(e?.message ?? String(e));
      } finally {
        setBusy(null);
      }
    },
    [user, isOnline, refresh, editingId, runAutoSync],
  );

  // ==== UI (BIG, SOLID, OBVIOUS - MAPPED TO GLOBALS.CSS) ====
  const S = {
    page: {
      height: "100dvh",
      background: "var(--bg-sand)",
      color: "var(--text-main)",
      overflowY: "auto",
      overflowX: "hidden",
      WebkitOverflowScrolling: "touch",
      padding: "calc(var(--roam-safe-top) + 16px) 16px calc(var(--bottom-nav-height, 80px) + 24px) 16px",
      display: "grid",
      alignContent: "start",
      gap: "16px",
      boxSizing: "border-box",
    } as React.CSSProperties,

    call000: {
      width: "100%",
      height: 120,
      background: "var(--brand-ochre)",
      color: "#ffffff",
      borderRadius: "var(--radius-lg)",
      fontWeight: 900,
      fontSize: 40,
      letterSpacing: "-0.5px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: 16,
      border: "none",
      boxShadow: "var(--shadow-heavy)",
      textTransform: "uppercase",
    } as React.CSSProperties,

    locBlock: {
      borderRadius: "var(--radius-lg)",
      background: "var(--surface-card)",
      padding: 20,
      display: "flex",
      flexDirection: "column",
      gap: 12,
      boxShadow: "var(--shadow-soft)",
      minHeight: 100,
      justifyContent: "center",
    } as React.CSSProperties,
    
    locLabel: { fontSize: 14, fontWeight: 700, color: "var(--text-muted)", textTransform: "uppercase", letterSpacing: "1px" } as React.CSSProperties,
    
    locValue: {
      fontSize: 24,
      fontWeight: 800,
      color: "var(--brand-ochre)",
      lineHeight: 1.1,
      wordBreak: "break-word",
      display: "flex",
      alignItems: "center",
      gap: 12,
    } as React.CSSProperties,

    locWaitText: {
      fontSize: 22,
      fontWeight: 800,
      color: "var(--brand-sky)", 
      lineHeight: 1.2,
      fontVariantNumeric: "tabular-nums", // Prevents the text from jittering
      fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace",
    } as React.CSSProperties,

    msgBtn: {
      width: "100%",
      height: 88,
      background: "var(--brand-sky)",
      color: "#ffffff",
      borderRadius: "var(--radius-lg)",
      fontWeight: 800,
      fontSize: 20,
      letterSpacing: "-0.3px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: 12,
      border: "none",
      boxShadow: "var(--shadow-button)",
      textTransform: "uppercase",
      transition: "opacity 0.2s var(--ease-out)",
    } as React.CSSProperties,

    err: {
      padding: 16,
      background: "var(--bg-error)",
      color: "var(--text-error)",
      borderRadius: "var(--radius-md)",
      fontWeight: 700,
      fontSize: 16,
      lineHeight: 1.25,
      boxShadow: "var(--shadow-soft)",
    } as React.CSSProperties,

    sectionTitle: {
      fontSize: 22,
      fontWeight: 800,
      color: "var(--text-main)",
      marginTop: 8,
      marginBottom: 0,
      letterSpacing: "-0.3px",
    } as React.CSSProperties,

    addBtn: {
      width: "100%",
      height: 64,
      borderRadius: "var(--radius-md)",
      background: "var(--surface-card)",
      color: "var(--text-main)",
      fontWeight: 800,
      fontSize: 18,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: 12,
      border: "none",
      boxShadow: "var(--shadow-button)",
      textTransform: "uppercase",
    } as React.CSSProperties,

    contactRow: {
      padding: 16,
      borderRadius: "var(--radius-lg)",
      background: "var(--surface-card)",
      display: "flex",
      flexDirection: "column",
      gap: 16,
      boxShadow: "var(--shadow-soft)",
    } as React.CSSProperties,
    
    contactTop: { display: "flex", alignItems: "center", gap: 16 } as React.CSSProperties,
    
    selectBtn: (on: boolean): React.CSSProperties => ({
      width: 56,
      height: 56,
      borderRadius: "var(--radius-md)",
      background: on ? "var(--brand-eucalypt)" : "var(--surface-muted)",
      color: on ? "#ffffff" : "var(--text-muted)",
      fontWeight: 900,
      fontSize: 24,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      border: "none",
      boxShadow: on ? "var(--tab-center-glow)" : "none",
      transition: "all 0.2s var(--spring)"
    }),
    
    contactName: { fontWeight: 800, fontSize: 22, letterSpacing: "-0.3px", color: "var(--text-main)" } as React.CSSProperties,
    contactMeta: { fontWeight: 600, fontSize: 16, color: "var(--text-muted)", marginTop: 4 } as React.CSSProperties,

    actionGrid: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12 } as React.CSSProperties,
    
    actionBtn: (bg: string, color: string): React.CSSProperties => ({
      height: 56,
      borderRadius: "var(--radius-md)",
      background: bg,
      color: color,
      fontWeight: 800,
      fontSize: 16,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: 8,
      border: "none",
      boxShadow: "var(--shadow-button)",
      textTransform: "uppercase",
    }),

    editor: {
      padding: 20,
      borderRadius: "var(--radius-lg)",
      background: "var(--surface-card)",
      display: "flex",
      flexDirection: "column",
      gap: 16,
      boxShadow: "var(--shadow-heavy)",
    } as React.CSSProperties,
    
    label: { fontSize: 14, fontWeight: 700, color: "var(--text-muted)", textTransform: "uppercase", letterSpacing: "0.5px" } as React.CSSProperties,
    
    input: {
      height: 56,
      borderRadius: "var(--radius-md)",
      background: "var(--surface-muted)",
      color: "var(--text-main)",
      fontSize: 18,
      fontWeight: 700,
      padding: "0 16px",
      border: "none",
      outline: "none",
    } as React.CSSProperties,
    
    textarea: {
      borderRadius: "var(--radius-md)",
      background: "var(--surface-muted)",
      color: "var(--text-main)",
      fontSize: 18,
      fontWeight: 700,
      padding: 16,
      border: "none",
      outline: "none",
      resize: "vertical",
    } as React.CSSProperties,
    
    editorActions: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12, marginTop: 8 } as React.CSSProperties,
    
    saveBtn: {
      height: 64,
      borderRadius: "var(--radius-md)",
      background: "var(--brand-eucalypt)",
      color: "#ffffff",
      fontWeight: 800,
      fontSize: 18,
      textTransform: "uppercase",
      border: "none",
      boxShadow: "var(--shadow-button)",
    } as React.CSSProperties,
    
    cancelBtn: {
      height: 64,
      borderRadius: "var(--radius-md)",
      background: "var(--surface-muted)",
      color: "var(--text-main)",
      fontWeight: 800,
      fontSize: 18,
      textTransform: "uppercase",
      border: "none",
    } as React.CSSProperties,
  };

  const selectedCount = selectedContacts.length;

  // Dynamic coaching logic based on time elapsed
  let waitMessage = "Acquiring GPS lock...";
  if (elapsedWait > 5) waitMessage = "Searching satellites. Ensure a clear view of the sky...";
  if (elapsedWait > 15) waitMessage = "Offline GPS cold lock (can take up to 2 mins)...";

  return (
    <div style={S.page}>
      {err ? <div style={S.err}>{err}</div> : null}

      {/* 1) TOP PRIORITY */}
      <button type="button" className="trip-interactive" onClick={callEmergency} style={S.call000}>
        <PhoneCall size={40} />
        CALL 000
      </button>

      {/* 2) AUTO LOCATION (WITH UX TIMER) */}
      <div style={S.locBlock}>
        <div style={S.locLabel}>Your coordinates are:</div>
        <div style={S.locValue}>
          {isLocating ? (
            <div style={{ display: "flex", flexDirection: "column", gap: 8, marginTop: 4 }}>
              <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
                <Satellite size={28} className="animate-pulse" color="var(--brand-sky)" />
                {/* Fast UI DOM ref for the countdown */}
                <span ref={timerDisplayRef} style={S.locWaitText}>02:00.000</span>
              </div>
              <div style={{ fontSize: 14, color: "var(--text-muted)", fontWeight: 600 }}>
                {waitMessage}
              </div>
            </div>
          ) : lat == null || lon == null ? (
            "Location unavailable"
          ) : (
            <>
              <MapPin size={28} />
              {fmt5(lat)}, {fmt5(lon)}{accuracyM ? ` (±${Math.round(accuracyM)}m)` : ""}
            </>
          )}
        </div>
      </div>

      {/* 3) BIG SECOND ACTION */}
      <button
        type="button"
        className="trip-interactive"
        onClick={sendLocationToSelected}
        disabled={items.length === 0}
        style={{ ...S.msgBtn, opacity: items.length === 0 ? 0.6 : 1 }}
        title={items.length === 0 ? "Add a contact first" : "Send location by SMS"}
      >
        <MessageSquareText size={28} />
        {selectedCount > 0 ? `MESSAGE ${selectedCount} CONTACT${selectedCount === 1 ? "" : "S"}` : "SELECT CONTACTS BELOW"}
      </button>

      {/* CONTACTS (SECONDARY) */}
      <div style={S.sectionTitle}>Contacts</div>

      <button type="button" className="trip-interactive" onClick={startNew} style={S.addBtn}>
        <Plus size={22} />
        Add Contact
      </button>

      {editingId ? (
        <div style={S.editor}>
          <div style={{ fontWeight: 800, fontSize: 20, color: "var(--text-main)" }}>
            {editingId === "__new__" ? "Add contact" : "Edit contact"}
          </div>

          <label style={{ display: "grid", gap: 6 }}>
            <div style={S.label}>Name</div>
            <input value={name} onChange={(e) => setName(e.target.value)} style={S.input} placeholder="Mum" />
          </label>

          <label style={{ display: "grid", gap: 6 }}>
            <div style={S.label}>Phone</div>
            <input
              value={phone}
              onChange={(e) => setPhone(e.target.value)}
              style={S.input}
              placeholder="04xx xxx xxx"
              inputMode="tel"
            />
          </label>

          <label style={{ display: "grid", gap: 6 }}>
            <div style={S.label}>Relationship (optional)</div>
            <input
              value={relationship}
              onChange={(e) => setRelationship(e.target.value)}
              style={S.input}
              placeholder="Partner / Friend"
            />
          </label>

          <label style={{ display: "grid", gap: 6 }}>
            <div style={S.label}>Notes (optional)</div>
            <textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              style={S.textarea}
              rows={3}
              placeholder="Any instructions…"
            />
          </label>

          <div style={S.editorActions}>
            <button
              type="button"
              className="trip-interactive"
              onClick={save}
              disabled={busy === "save" || !name.trim() || !phone.trim()}
              style={{ ...S.saveBtn, opacity: busy === "save" || !name.trim() || !phone.trim() ? 0.7 : 1 }}
            >
              Save
            </button>

            <button type="button" className="trip-interactive" onClick={cancelEdit} style={S.cancelBtn}>
              Cancel
            </button>
          </div>
        </div>
      ) : null}

      {items.length === 0 ? (
        <div style={{ color: "var(--text-muted)", fontWeight: 700, fontSize: 16, textAlign: "center", padding: "20px 0" }}>
          No contacts saved.
        </div>
      ) : (
        items.map((c) => {
          const sel = !!selectedIds[c.id];
          return (
            <div key={c.id} style={S.contactRow}>
              <div style={S.contactTop}>
                <button
                  type="button"
                  className="trip-interactive"
                  onClick={() => toggleSelected(c.id)}
                  style={S.selectBtn(sel)}
                  aria-pressed={sel}
                  title={sel ? "Selected" : "Tap to select"}
                >
                  {sel ? "✓" : "+"}
                </button>

                <div style={{ minWidth: 0, flex: 1 }}>
                  <div style={S.contactName}>{c.name}</div>
                  <div style={S.contactMeta}>
                    {c.phone}
                    {c.relationship ? ` • ${c.relationship}` : ""}
                    {c.notes ? ` • ${c.notes}` : ""}
                  </div>
                </div>
              </div>

              <div style={S.actionGrid}>
                <a
                  href={telHref(c.phone)}
                  onClick={(e) => {
                    e.preventDefault();
                    if (!confirm(`Call ${c.name} (${c.phone})?`)) return;
                    haptic.heavy();
                    window.location.href = telHref(c.phone);
                  }}
                  className="trip-interactive"
                  style={S.actionBtn("var(--brand-eucalypt)", "#ffffff")}
                >
                  <PhoneCall size={20} />
                  Call
                </a>

                <button
                  type="button"
                  className="trip-interactive"
                  onClick={() => {
                    if (!lat || !lon) {
                      setErr("Location unavailable right now.");
                      haptic.error();
                      return;
                    }
                    const coords = `${fmt5(lat)}, ${fmt5(lon)}${accuracyM ? ` (±${Math.round(accuracyM)}m)` : ""}`;
                    const link = mapsLink(lat, lon);
                    const time = new Date().toLocaleString();

                    const msg =
                      `ROAM SAFETY: I need help.\n` +
                      `Your coordinates are: ${coords}\n` +
                      `Map: ${link}\n` +
                      `Time: ${time}`;

                    haptic.heavy();
                    window.location.href = smsHref([c.phone], msg);
                  }}
                  style={S.actionBtn("var(--brand-sky)", "#ffffff")}
                >
                  <MessageSquareText size={20} />
                  Text
                </button>

                <button
                  type="button"
                  className="trip-interactive"
                  onClick={() => {
                    haptic.selection();
                    setEditingId(c.id);
                  }}
                  style={S.actionBtn("var(--surface-muted)", "var(--text-main)")}
                >
                  <Pencil size={18} />
                  Edit
                </button>

                <button
                  type="button"
                  className="trip-interactive"
                  onClick={() => remove(c.id)}
                  disabled={busy === "delete"}
                  style={{ ...S.actionBtn("var(--bg-error)", "var(--text-error)"), opacity: busy === "delete" ? 0.7 : 1 }}
                >
                  <Trash2 size={18} />
                  Delete
                </button>
              </div>
            </div>
          );
        })
      )}
    </div>
  );
}

===== src/app/sos/page.tsx =====

import EmergencyClientPage from "./ClientPage";

export const dynamic = "force-static";

export default function EmergencyPage() {
  return <EmergencyClientPage />;
}


===== src/app/template.tsx =====

"use client";

import React from "react";

export default function Template({ children }: { children: React.ReactNode }) {
  return (
    <div className="trip-page-transition">
      {children}
    </div>
  );
}

===== src/app/trip/ClientPage.tsx =====

// src/app/trip/ClientPage.tsx
"use client";

import { useEffect, useMemo, useRef, useState, useCallback } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import type { Map as MLMap } from "maplibre-gl";

import { TripMap } from "@/components/trip/TripMap";
import { TripView, type TripEditorRebuildMode } from "@/components/trip/TripView";
import type { AlertHighlightEvent } from "@/components/trip/TripAlertsPanel";
import { SyncStatusBadge } from "@/components/ui/SyncStatusBadge";
import { InviteCodeModal } from "@/components/plans/InviteCodeModal";
import { BasemapDownloadCard } from "@/components/basemap/BasemapDownloadCard";
import { FuelPressureIndicator } from "@/components/fuel/FuelPressureIndicator";
import { FuelLastChanceToast } from "@/components/fuel/FuelLastChanceToast";
import { VehicleFuelSettings } from "@/components/fuel/VehicleFuelSettings";

// ── Active navigation components ──
import { NavigationHUD } from "@/components/nav/NavigationHUD";
import { NavigationBar } from "@/components/nav/NavigationBar";
import { NavigationControls } from "@/components/nav/NavigationControls";
import { OffRouteBanner } from "@/components/nav/OffRouteBanner";
import { StartNavigationButton } from "@/components/nav/StartNavigationButton";
import { ElevationStrip } from "@/components/nav/ElevationStrip";

// ── Hooks ──
import { useGeolocation } from "@/lib/native/geolocation";
import { useKeepAwake } from "@/lib/native/keepAwake";
import { useActiveNavigation } from "@/lib/hooks/useActiveNavigation";
import { useMapNavigationMode } from "@/lib/hooks/useMapNavigationMode";

import { haptic } from "@/lib/native/haptics";
import { getCurrentPlanId, getOfflinePlan, type OfflinePlanRecord } from "@/lib/offline/plansStore";
import { getAllPacks, hasCorePacks, putPack } from "@/lib/offline/packsStore";
import { unpackAndStoreBundle } from "@/lib/offline/unpackBundle";
import { getVehicleFuelProfile } from "@/lib/offline/fuelProfileStore";

import { navApi } from "@/lib/api/nav";

import { analyzeFuel, computeFuelTracking } from "@/lib/nav/fuelAnalysis";
import { decodePolyline6 } from "@/lib/nav/polyline6";
import { cumulativeKm, snapToPolyline } from "@/lib/nav/snapToRoute";

import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay, ElevationResponse } from "@/lib/types/navigation";
import type { PlacesPack, PlaceItem } from "@/lib/types/places";
import type { TripStop } from "@/lib/types/trip";
import type { FuelAnalysis, FuelTrackingState, VehicleFuelProfile } from "@/lib/types/fuel";

import { UserRound, Users, UserPlus, Compass, List, MapPinned } from "lucide-react";

/* ── Constants ────────────────────────────────────────────────────────── */

/** Poll overlays every 90 seconds */
const OVERLAY_POLL_INTERVAL_MS = 90_000;

/* ── Boot phases ──────────────────────────────────────────────────────── */

type BootPhase = "resolving" | "no-plan" | "hydrating" | "ready" | "error";

/* ── Component ────────────────────────────────────────────────────────── */

export function TripClientPage(props: { initialPlanId: string | null }) {
  const router = useRouter();
  const sp = useSearchParams();

  const planIdFromUrl = sp.get("plan_id");
  const focusPlaceFromUrl = sp.get("focus_place_id");

  const desiredPlanId = useMemo(
    () => props.initialPlanId ?? planIdFromUrl ?? null,
    [props.initialPlanId, planIdFromUrl],
  );

  // Native hooks
  const geo = useGeolocation({ autoStart: true, highAccuracy: true });
  useKeepAwake({ auto: true });

  // Boot state
  const [phase, setPhase] = useState<BootPhase>("resolving");
  const [bootError, setBootError] = useState<string | null>(null);

  // Data state
  const [plan, setPlan] = useState<OfflinePlanRecord | null>(null);
  const [navpack, setNavpack] = useState<NavPack | null>(null);
  const [corridor, setCorridor] = useState<CorridorGraphPack | null>(null);
  const [places, setPlaces] = useState<PlacesPack | null>(null);

  // Overlay state
  const [traffic, setTraffic] = useState<TrafficOverlay | null>(null);
  const [hazards, setHazards] = useState<HazardOverlay | null>(null);

  // Fuel state
  const [fuelAnalysis, setFuelAnalysis] = useState<FuelAnalysis | null>(null);
  const [fuelTracking, setFuelTracking] = useState<FuelTrackingState | null>(null);
  const [fuelSettingsOpen, setFuelSettingsOpen] = useState(false);

  // Elevation state
  const [elevation, setElevation] = useState<ElevationResponse | null>(null);

  // UI State
  const [focusedStopId, setFocusedStopId] = useState<string | null>(null);
  const [focusedPlaceId, setFocusedPlaceId] = useState<string | null>(null);
  const [highlightedAlertId, setHighlightedAlertId] = useState<string | null>(null);

  // Invite modal state
  const [inviteOpen, setInviteOpen] = useState(false);
  const [inviteMode, setInviteMode] = useState<"create" | "redeem">("create");

  // Fluid Bottom Sheet Drag State
  const sheetRef = useRef<HTMLDivElement>(null);
  const [offsetY, setOffsetY] = useState(0);
  const [dragOffset, setDragOffset] = useState(0);
  const isDragging = useRef(false);
  const dragData = useRef({ startY: 0 });

  // Overlay polling ref
  const overlayTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);

  // ── MapLibre instance ref (shared between TripMap and useMapNavigationMode) ──
  const mapInstanceRef = useRef<MLMap | null>(null);

  // ── Active Navigation ──
  const activeNav = useActiveNavigation(navpack);

  // ── Map Navigation Mode (heading-up camera tracking) ──
  const effectiveBbox = navpack?.primary?.bbox ?? plan?.preview?.bbox ?? null;
  const mapNavMode = useMapNavigationMode({
    mapRef: mapInstanceRef,
    position: activeNav.isActive ? activeNav.lastPosition : null,
    active: activeNav.isActive,
    bbox: effectiveBbox,
  });

  // ── Sheet position when entering/exiting navigation ──
  const prevActiveRef = useRef(false);
  useEffect(() => {
    if (activeNav.isActive && !prevActiveRef.current) {
      // Entering navigation mode → collapse sheet to just the peek handle
      setOffsetY(0);
      setDragOffset(0);
    }
    prevActiveRef.current = activeNav.isActive;
  }, [activeNav.isActive]);

  // ── Boot logic ──────────────────────────────────────────────────
  useEffect(() => {
    let cancelled = false;

    async function boot() {
      try {
        const resolvedId = desiredPlanId ?? (await getCurrentPlanId());
        if (cancelled) return;
        if (!resolvedId) { setPhase("no-plan"); return; }

        const rec = await getOfflinePlan(resolvedId);
        if (cancelled) return;
        if (!rec) { setPhase("no-plan"); return; }

        setPhase("hydrating");

        const has = await hasCorePacks(rec.plan_id);
        if (!has) await unpackAndStoreBundle(rec);

        const packs = await getAllPacks(rec.plan_id);
        if (cancelled) return;

        setPlan(rec);
        setNavpack(packs.navpack ?? null);
        setCorridor(packs.corridor ?? null);
        setPlaces(packs.places ?? null);
        setTraffic(packs.traffic ?? null);
        setHazards(packs.hazards ?? null);

        // ── Elevation: load from IDB ──
        if (packs.elevation) {
          setElevation(packs.elevation);
        }

        // ── Fuel analysis: load from IDB or compute fresh ──
        if (packs.fuel_analysis) {
          setFuelAnalysis(packs.fuel_analysis);
        } else if (packs.navpack?.primary?.geometry && packs.places?.items) {
          try {
            const fuelProfile = await getVehicleFuelProfile();
            const analysis = analyzeFuel(
              packs.navpack.primary.geometry,
              packs.places.items,
              fuelProfile,
              packs.navpack.primary.route_key,
            );
            setFuelAnalysis(analysis);
            putPack(rec.plan_id, "fuel_analysis", analysis).catch(() => {});
          } catch (e) {
            console.warn("[Trip] fuel analysis compute failed:", e);
          }
        }

        setPhase("ready");
      } catch (e: any) {
        if (cancelled) return;
        console.error("[Trip] boot error:", e);
        setBootError(e?.message ?? "Failed to load trip");
        setPhase("error");
      }
    }

    boot();
    return () => { cancelled = true; };
  }, [desiredPlanId]);

  // Redirect if no plan
  useEffect(() => {
    if (phase !== "no-plan") return;
    router.replace("/plans");
  }, [phase, router]);

  // Focus place from URL
  useEffect(() => {
    if (!focusPlaceFromUrl) return;
    setFocusedPlaceId(focusPlaceFromUrl);
    if (sheetRef.current) {
      const h = sheetRef.current.clientHeight;
      const maxUp = -(h - 180);
      setOffsetY(Math.max(maxUp, Math.round(maxUp * 0.6)));
    }
  }, [focusPlaceFromUrl]);

  // ── Live fuel tracking from GPS ──────────────────────────────────
  // Use active nav position if navigating, else regular geo
  const effectivePosition = activeNav.isActive ? activeNav.lastPosition : geo.position;

  useEffect(() => {
    if (!fuelAnalysis || !effectivePosition || !navpack?.primary?.geometry) return;

    try {
      const decoded = decodePolyline6(navpack.primary.geometry);
      const cumKm = cumulativeKm(decoded);
      const snap = snapToPolyline(
        { lat: effectivePosition.lat, lng: effectivePosition.lng },
        decoded,
        cumKm,
      );

      // Only track if within 2km of the route
      if (snap.distance_m > 2000) {
        setFuelTracking(null);
        return;
      }

      const tracking = computeFuelTracking(fuelAnalysis, snap.km, fuelAnalysis.profile);
      setFuelTracking(tracking);
    } catch {
      // Non-fatal — just skip this update
    }
  }, [fuelAnalysis, effectivePosition, navpack]);

  // ── Overlay polling ─────────────────────────────────────────────
  const pollOverlays = useCallback(async () => {
    if (typeof navigator !== "undefined" && !navigator.onLine) return;
    if (!navpack?.primary?.bbox) return;

    const bbox = navpack.primary.bbox;
    const currentPlanId = plan?.plan_id;

    try {
      const [trafficRes, hazardsRes] = await Promise.allSettled([
        navApi.trafficPoll({ bbox, cache_seconds: 90 }),
        navApi.hazardsPoll({ bbox, cache_seconds: 90 }),
      ]);

      if (trafficRes.status === "fulfilled") {
        setTraffic(trafficRes.value);
        if (currentPlanId) putPack(currentPlanId, "traffic", trafficRes.value).catch(() => {});
      }
      if (hazardsRes.status === "fulfilled") {
        setHazards(hazardsRes.value);
        if (currentPlanId) putPack(currentPlanId, "hazards", hazardsRes.value).catch(() => {});
      }
    } catch (e) {
      console.warn("[Trip] overlay poll failed:", e);
    }
  }, [navpack, plan]);

  // Start polling when navpack is ready
  useEffect(() => {
    if (phase !== "ready" || !navpack?.primary?.bbox) return;

    pollOverlays();

    overlayTimerRef.current = setInterval(pollOverlays, OVERLAY_POLL_INTERVAL_MS);

    return () => {
      if (overlayTimerRef.current) {
        clearInterval(overlayTimerRef.current);
        overlayTimerRef.current = null;
      }
    };
  }, [phase, navpack, pollOverlays]);

  // ── Rebuild handler ─────────────────────────────────────────────
  const handleRebuild = useCallback(async (args: { stops: TripStop[]; mode: TripEditorRebuildMode }) => {
    const result = await navApi.route({
      profile: navpack?.primary?.profile ?? "drive",
      stops: args.stops,
    });
    setNavpack(result);

    // Recompute fuel analysis for new route
    if (places?.items && result?.primary?.geometry) {
      try {
        const fuelProfile = await getVehicleFuelProfile();
        const analysis = analyzeFuel(
          result.primary.geometry,
          places.items,
          fuelProfile,
          result.primary.route_key,
        );
        setFuelAnalysis(analysis);
        if (plan?.plan_id) {
          putPack(plan.plan_id, "fuel_analysis", analysis).catch(() => {});
        }
      } catch (e) {
        console.warn("[Trip] fuel recompute on rebuild failed:", e);
      }
    }

    // Fetch elevation for new route
    if (result?.primary?.geometry) {
      try {
        const elevRes = await navApi.elevation({
          geometry: result.primary.geometry,
          route_key: result.primary.route_key,
        });
        setElevation(elevRes);
        if (plan?.plan_id) {
          putPack(plan.plan_id, "elevation", elevRes).catch(() => {});
        }
      } catch (e) {
        console.warn("[Trip] elevation fetch on rebuild failed:", e);
      }
    }

    if (result?.primary?.bbox) {
      try {
        const [t, h] = await Promise.allSettled([
          navApi.trafficPoll({ bbox: result.primary.bbox, cache_seconds: 90 }),
          navApi.hazardsPoll({ bbox: result.primary.bbox, cache_seconds: 90 }),
        ]);
        if (t.status === "fulfilled") {
          setTraffic(t.value);
          if (plan?.plan_id) putPack(plan.plan_id, "traffic", t.value).catch(() => {});
        }
        if (h.status === "fulfilled") {
          setHazards(h.value);
          if (plan?.plan_id) putPack(plan.plan_id, "hazards", h.value).catch(() => {});
        }
      } catch {}
    }
  }, [navpack, plan, places]);

  // ── Fuel settings saved handler ──────────────────────────────────
  const handleFuelProfileSaved = useCallback(async (newProfile: VehicleFuelProfile) => {
    if (!navpack?.primary?.geometry || !places?.items) return;
    try {
      const analysis = analyzeFuel(
        navpack.primary.geometry,
        places.items,
        newProfile,
        navpack.primary.route_key,
      );
      setFuelAnalysis(analysis);
      if (plan?.plan_id) {
        putPack(plan.plan_id, "fuel_analysis", analysis).catch(() => {});
      }
    } catch (e) {
      console.warn("[Trip] fuel recompute on settings change failed:", e);
    }
  }, [navpack, places, plan]);

  // ── Guide navigation handler ────────────────────────────────────
  const handleNavigateToGuide = useCallback((placeId: string) => {
    if (!plan) return;
    router.push(`/guide?plan_id=${encodeURIComponent(plan.plan_id)}&focus_place_id=${encodeURIComponent(placeId)}`);
  }, [plan, router]);

  // ── Alert highlight handler ─────────────────────────────────────
  const highlightTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const handleHighlightAlert = useCallback((ev: AlertHighlightEvent) => {
    haptic.selection();
    setHighlightedAlertId(ev.id);

    if (highlightTimerRef.current) clearTimeout(highlightTimerRef.current);
    highlightTimerRef.current = setTimeout(() => {
      setHighlightedAlertId(null);
      highlightTimerRef.current = null;
    }, 4000);
  }, []);

  // ── Off-route reroute handler ───────────────────────────────────
  const handleOffRouteReroute = useCallback(async () => {
    // TODO: implement corridor A* reroute from current position
    // For now, rebuild the route from current position through remaining stops
    if (!activeNav.lastPosition || !navpack) return;

    const currentPos = activeNav.lastPosition;
    const allStops = navpack.req.stops;

    // Find which stops are still ahead (use kmAlongRoute from nav state)
    // For simplicity: keep all stops but prepend current location
    const remainingStops: TripStop[] = [
      {
        id: "__reroute_origin",
        name: "Current Location",
        type: "start" as any,
        lat: currentPos.lat,
        lng: currentPos.lng,
      },
      // Keep all non-start stops
      ...allStops.filter((s) => s.type !== "start"),
    ];

    try {
      const result = await navApi.route({
        profile: navpack.primary.profile,
        stops: remainingStops,
      });
      setNavpack(result);
      activeNav.applyReroute(result);
    } catch (e) {
      console.warn("[Trip] reroute failed:", e);
    }
  }, [activeNav, navpack]);

  // ── Bottom Sheet Handlers ───────────────────────────────────────
  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    isDragging.current = true;
    dragData.current = { startY: e.clientY };
    e.currentTarget.setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!isDragging.current || !sheetRef.current) return;
    const totalDelta = e.clientY - dragData.current.startY;
    const sheetHeight = sheetRef.current.clientHeight;
    const maxUp = -(sheetHeight - 180);
    let proposedOffset = offsetY + totalDelta;
    if (proposedOffset < maxUp) proposedOffset = maxUp;
    if (proposedOffset > 0) proposedOffset = 0;
    setDragOffset(proposedOffset - offsetY);
  };

  const handlePointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
    isDragging.current = false;
    try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
    setOffsetY((prev) => prev + dragOffset);
    setDragOffset(0);
  };

  // ── Derived values ─────────────────────────────────────────────
  const peekBase = `calc(100% - 180px - var(--roam-safe-bottom, 0px))`;
  const sheetTransform = activeNav.isActive
    ? `translateY(calc(100% - 60px))` // Collapsed to just the drag handle during navigation
    : `translateY(clamp(0px, calc(${peekBase} + ${offsetY + dragOffset}px), ${peekBase}))`;

  const effectiveStops = navpack?.req?.stops ?? plan?.preview?.stops ?? [];
  const effectiveGeom = navpack?.primary?.geometry ?? plan?.preview?.geometry ?? null;

  // Current km along route for fuel tracking + elevation strip
  const currentKm = useMemo(() => {
    if (!fuelTracking) return 0;
    return fuelTracking.km_since_last_fuel + (fuelTracking.last_passed_station?.km_along_route ?? 0);
  }, [fuelTracking]);

  // ── Render gates ────────────────────────────────────────────────
  if (phase === "resolving" || phase === "no-plan") {
    return (
      <div style={{ display: "grid", placeItems: "center", height: "100dvh", width: "100%", background: "var(--roam-bg)", color: "var(--roam-text)" }}>
        <div style={{ color: "var(--roam-text-muted)", fontSize: 16, fontWeight: 900 }}>
          {phase === "resolving" ? "Loading…" : "Redirecting…"}
        </div>
      </div>
    );
  }

  if (phase === "error") {
    return (
      <div style={{ display: "grid", placeItems: "center", height: "100dvh", width: "100%", background: "var(--roam-bg)", color: "var(--roam-text)", padding: 32, textAlign: "center" }}>
        <div>
          <div style={{ fontSize: 16, fontWeight: 950, color: "var(--roam-danger)", marginBottom: 12 }}>
            Failed to load trip
          </div>
          {bootError && <div style={{ fontSize: 13, color: "var(--roam-text-muted)", marginBottom: 20 }}>{bootError}</div>}
          <button
            type="button"
            className="trip-interactive"
            style={{ borderRadius: 999, minHeight: 42, padding: "0 20px", fontWeight: 950, background: "var(--roam-accent)", color: "white", boxShadow: "var(--shadow-button)" }}
            onClick={() => router.replace("/plans")}
          >
            Go to Plans
          </button>
        </div>
      </div>
    );
  }

  if (phase === "hydrating" || !plan || !effectiveGeom || !effectiveBbox) {
    return (
      <div style={{ display: "grid", placeItems: "center", height: "100dvh", width: "100%", background: "var(--roam-bg)", color: "var(--roam-text)" }}>
        <div style={{ color: "var(--roam-text-muted)", fontSize: 16, fontWeight: 900 }}>Loading trip map…</div>
      </div>
    );
  }

  // ── Ready ──────────────────────────────────────────────────────
  return (
    <div
      className="trip-app-container"
      style={{ position: "relative", width: "100%", height: "100dvh", overflow: "hidden", background: "var(--roam-bg)", color: "var(--roam-text)" }}
    >
      {/* Map Layer */}
      <div style={{ position: "absolute", inset: 0, zIndex: 1 }}>
        <TripMap
          styleId="roam-basemap-hybrid"
          stops={effectiveStops}
          geometry={effectiveGeom}
          bbox={effectiveBbox}
          focusedStopId={focusedStopId}
          onStopPress={(id) => { haptic.selection(); setFocusedStopId(id); }}
          suggestions={places?.items ?? null}
          focusedSuggestionId={focusedPlaceId}
          onSuggestionPress={(id) => { haptic.selection(); setFocusedPlaceId(id); }}
          traffic={traffic}
          hazards={hazards}
          onTrafficEventPress={(id) => { haptic.selection(); }}
          onHazardEventPress={(id) => { haptic.selection(); }}
          userPosition={activeNav.isActive ? activeNav.lastPosition : geo.position}
          planId={plan.plan_id}
          onNavigateToGuide={handleNavigateToGuide}
          highlightedAlertId={highlightedAlertId}
          fuelStations={fuelAnalysis?.stations ?? null}
          fuelTracking={fuelTracking}
          navigationMode={activeNav.isActive}
          mapInstanceRef={mapInstanceRef}
        />
      </div>

      {/* ── Active Navigation Overlays ── */}

      {/* Turn-by-turn HUD — top of map */}
      <NavigationHUD
        nav={activeNav.nav}
        visible={activeNav.isActive && activeNav.nav.status !== "off_route"}
      />

      {/* Off-route banner — replaces HUD when off route */}
      <OffRouteBanner
        visible={activeNav.nav.status === "off_route"}
        distFromRoute_m={activeNav.nav.distFromRoute_m}
        hasCorridorGraph={!!corridor}
        onReroute={handleOffRouteReroute}
      />

      {/* Navigation controls — right side of map */}
      <NavigationControls
        visible={activeNav.isActive}
        isMuted={activeNav.isMuted}
        onToggleMute={activeNav.toggleMute}
        onOverview={mapNavMode.showOverview}
        onRecenter={mapNavMode.recenter}
        onEnd={activeNav.stop}
      />

      {/* Navigation bar — bottom ETA/distance/fatigue */}
      <NavigationBar
        nav={activeNav.nav}
        fuelTracking={fuelTracking}
        visible={activeNav.isActive}
        onTap={() => {
          // Tapping the bar expands the sheet briefly to show trip details
          if (sheetRef.current) {
            const h = sheetRef.current.clientHeight;
            setOffsetY(-(h - 300));
            setTimeout(() => setOffsetY(0), 8000); // auto-collapse after 8s
          }
        }}
      />

      {/* Fuel pressure indicator — floating pill on map (hidden during active nav, bar shows fuel) */}
      {!activeNav.isActive && <FuelPressureIndicator tracking={fuelTracking} />}

      {/* Fuel last-chance toast */}
      <FuelLastChanceToast tracking={fuelTracking} currentKm={currentKm} />

      {/* Fuel settings modal */}
      <VehicleFuelSettings
        open={fuelSettingsOpen}
        onClose={() => setFuelSettingsOpen(false)}
        onSaved={handleFuelProfileSaved}
      />

      {/* Basemap download card — floats above map, below sheet (hidden during nav) */}
      {!activeNav.isActive && (
        <div style={{ position: "absolute", top: 12, left: 12, right: 12, zIndex: 15, pointerEvents: "auto" }}>
          <BasemapDownloadCard region="australia" compact />
        </div>
      )}

      {/* Invite modal */}
      <InviteCodeModal
        open={inviteOpen}
        planId={plan.plan_id}
        mode={inviteMode}
        onClose={() => setInviteOpen(false)}
        onRedeemed={(joinedPlanId) => {
          router.replace(`/trip?plan_id=${encodeURIComponent(joinedPlanId)}`);
        }}
      />

      {/* Bottom Sheet */}
      <div
        ref={sheetRef}
        style={{
          position: "absolute",
          bottom: 0, left: 0, right: 0,
          height: "92vh",
          zIndex: 20,
          background: "var(--roam-surface)",
          borderRadius: "var(--r-card) var(--r-card) 0 0",
          boxShadow: "0 -12px 48px rgba(0,0,0,0.15)",
          display: "flex",
          flexDirection: "column",
          transform: sheetTransform,
          transition: isDragging.current ? "none" : "transform 0.25s cubic-bezier(0.4,0,0.2,1)",
          willChange: "transform",
        }}
      >
        {/* Drag Handle */}
        <div
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
          style={{
            padding: "10px 20px 10px",
            touchAction: "none",
            cursor: "grab",
            background: "var(--roam-surface)",
            borderRadius: "var(--r-card) var(--r-card) 0 0",
          }}
        >
          <div
            className="trip-drag-handle"
            style={{ width: 48, height: 6, borderRadius: 10, background: "var(--roam-surface-hover)", margin: "0 auto" }}
          />
        </div>

        {/* Header */}
        <div
          className="trip-sheet-header"
          style={{ padding: "0 20px 12px", background: "var(--roam-surface)" }}
        >
          {/* Title row */}
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "flex-start", gap: 12 }}>
            <div style={{ minWidth: 0 }}>
              <div
                style={{
                  fontSize: 22, fontWeight: 950, margin: 0,
                  display: "flex", alignItems: "center", gap: 10,
                  color: "var(--roam-text)", letterSpacing: "-0.3px",
                }}
              >
                <span style={{ overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>
                  {plan.label ?? "Trip Plan"}
                </span>
                <SyncStatusBadge />
              </div>
              <div style={{ marginTop: 4, fontSize: 12, fontWeight: 850, color: "var(--roam-text-muted)" }}>
                Itinerary
              </div>
            </div>

            <button
              type="button"
              className="trip-interactive trip-btn-icon"
              aria-label="Account"
              onClick={() => { haptic.selection(); router.push("/login"); }}
              style={{
                borderRadius: 999, width: 42, height: 42,
                display: "grid", placeItems: "center",
                background: "var(--roam-surface-hover)",
                boxShadow: "var(--shadow-button)", flexShrink: 0,
              }}
            >
              <UserRound size={18} />
            </button>
          </div>

          {/* Action row */}
          <div style={{ display: "flex", gap: 10, marginTop: 12, alignItems: "center", overflowX: "auto", WebkitOverflowScrolling: "touch" }}>
            {[
              { icon: <List size={16} />, label: "Peek", onClick: () => setOffsetY(0) },
              { icon: <Compass size={16} />, label: "Guide", onClick: () => router.push(`/guide?plan_id=${encodeURIComponent(plan.plan_id)}`) },
              { icon: <Users size={16} />, label: "Share", onClick: () => { setInviteMode("create"); setInviteOpen(true); } },
              { icon: <UserPlus size={16} />, label: "Join", onClick: () => { setInviteMode("redeem"); setInviteOpen(true); } },
            ].map((btn) => (
              <button
                key={btn.label}
                type="button"
                className="trip-btn-sm trip-interactive"
                onClick={() => { haptic.selection(); btn.onClick(); }}
                style={{
                  borderRadius: 999, minHeight: 42, padding: "0 14px",
                  fontWeight: 950, background: "var(--roam-surface-hover)",
                  color: "var(--roam-text)", boxShadow: "var(--shadow-button)",
                  whiteSpace: "nowrap", display: "inline-flex", alignItems: "center", gap: 8,
                  flexShrink: 0,
                }}
              >
                {btn.icon} {btn.label}
              </button>
            ))}

            <button
              type="button"
              className="trip-btn-sm trip-interactive"
              onClick={() => { haptic.selection(); router.push("/plans"); }}
              style={{
                marginLeft: "auto", borderRadius: 999, minHeight: 42, padding: "0 14px",
                fontWeight: 950, background: "var(--roam-surface-hover)",
                color: "var(--roam-text)", boxShadow: "var(--shadow-button)",
                whiteSpace: "nowrap", display: "inline-flex", alignItems: "center", gap: 8,
                flexShrink: 0,
              }}
            >
              <MapPinned size={16} /> All Plans
            </button>
          </div>

          {/* ── Start Navigation button (shown when NOT actively navigating) ── */}
          {!activeNav.isActive && navpack && (
            <div style={{ marginTop: 14 }}>
              <StartNavigationButton
                onStart={activeNav.start}
                disabled={!navpack?.primary?.legs?.some((l) => l.steps && l.steps.length > 0)}
              />
              {!navpack?.primary?.legs?.some((l) => l.steps && l.steps.length > 0) && (
                <div style={{ marginTop: 6, fontSize: 11, fontWeight: 700, color: "var(--roam-text-muted)", textAlign: "center" }}>
                  Turn-by-turn data not available. Rebuild route to enable navigation.
                </div>
              )}
            </div>
          )}

          {/* ── Elevation strip (shown below action bar) ── */}
          {elevation?.profile && (
            <div style={{ marginTop: 12 }}>
              <ElevationStrip
                profile={elevation.profile}
                gradeSegments={elevation.grade_segments}
                currentKm={activeNav.isActive ? activeNav.nav.kmAlongRoute : currentKm || null}
                compact
              />
            </div>
          )}
        </div>

        {/* Scrollable content */}
        <div style={{ flex: 1, overflow: "hidden" }}>
          <div
            style={{
              height: "100%",
              overflowY: "auto",
              padding: "0 20px calc(var(--bottom-nav-height) + 20px)",
              WebkitOverflowScrolling: "touch",
              overscrollBehavior: "contain",
            }}
          >
            <TripView
              planId={plan.plan_id}
              navpack={navpack}
              corridor={corridor}
              places={places}
              traffic={traffic}
              hazards={hazards}
              focusedStopId={focusedStopId}
              onFocusStop={setFocusedStopId}
              focusedPlaceId={focusedPlaceId}
              onFocusPlace={setFocusedPlaceId}
              onRebuildRequested={handleRebuild}
              highlightedAlertId={highlightedAlertId}
              onHighlightAlert={handleHighlightAlert}
              userPosition={effectivePosition}
              fuelAnalysis={fuelAnalysis}
              onOpenFuelSettings={() => setFuelSettingsOpen(true)}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

===== src/app/trip/page.tsx =====

// src/app/trip/page.tsx
import { TripClientPage } from "./ClientPage";

export const dynamic = "force-static";

export default function TripPage() {
  // Static export friendly: no access to searchParams here.
  return <TripClientPage initialPlanId={null} />;
}


===== src/components/auth/AuthGate.tsx =====

// src/components/auth/AuthGate.tsx
"use client";

import { useEffect, type ReactNode } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/lib/supabase/auth";

/**
 * Wrap any page/section that requires authentication.
 *
 * While loading the initial session, shows a spinner.
 * If no session after load, redirects to /login.
 * Otherwise renders children.
 *
 * Usage:
 *   <AuthGate>
 *     <TripPage />
 *   </AuthGate>
 *
 * NOTE: Offline use still works because the Supabase session JWT is
 * persisted in localStorage. As long as the user signed in at least
 * once, AuthGate will pass them through even without network.
 * The JWT may be expired, but we don't block on that — the sync
 * layer handles token refresh when connectivity returns.
 */
export function AuthGate({ children }: { children: ReactNode }) {
  const { loading, session } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !session) {
      router.replace("/login");
    }
  }, [loading, session, router]);

  if (loading) {
    return (
      <div style={{ display: "flex", alignItems: "center", justifyContent: "center", height: "100vh" }}>
        <div style={{ color: "var(--roam-muted, #888)", fontSize: 14 }}>Loading…</div>
      </div>
    );
  }

  if (!session) return null; // will redirect

  return <>{children}</>;
}

===== src/components/auth/SyncBootstrap.tsx =====

// src/components/auth/SyncBootstrap.tsx
"use client";

import { useEffect } from "react";
import { useAuth } from "@/lib/supabase/auth";
import { networkMonitor } from "@/lib/offline/networkMonitor";
import { planSync } from "@/lib/offline/planSync";

/**
 * Invisible component mounted at the root layout level.
 *
 * Responsibilities:
 *   1. Start NetworkMonitor on mount (always, regardless of auth).
 *   2. Start PlanSync when user is authenticated.
 *   3. Stop PlanSync on sign-out.
 *
 * Renders nothing.
 */
export function SyncBootstrap() {
  const { user, loading } = useAuth();

  // Start network monitor once
  useEffect(() => {
    networkMonitor.start();
    return () => networkMonitor.stop();
  }, []);

  // Start/stop plan sync based on auth state
  useEffect(() => {
    if (loading) return;

    if (user?.id) {
      planSync.start(user.id);
    } else {
      planSync.stop();
    }

    return () => planSync.stop();
  }, [user?.id, loading]);

  return null;
}

===== src/components/basemap/BasemapDownloadCard.tsx =====

// src/components/basemap/BasemapDownloadCard.tsx
//
// Compact card/banner for basemap download status.
// Shows: not installed → downloading (progress) → installed → error
// Designed for the /trip or /new page, above or below the map.

"use client";

import { useCallback, useMemo } from "react";
import { useBasemapPack } from "@/lib/hooks/useBasemapPack";

function formatBytes(bytes: number): string {
  if (bytes <= 0) return "0 B";
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(0)} KB`;
  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
}

type Props = {
  /** Region identifier (default "australia") */
  region?: string;
  /** Compact mode — single line banner */
  compact?: boolean;
  /** Called when basemap becomes ready (server started) */
  onReady?: () => void;
  /** Custom className for the outer container */
  className?: string;
};

export function BasemapDownloadCard({ region = "australia", compact = false, onReady, className }: Props) {
  const { status, isNative, isOfflineReady, download, cancel, remove } = useBasemapPack(region);

  const handleDownload = useCallback(async () => {
    await download();
    onReady?.();
  }, [download, onReady]);

  const progressPct = useMemo(() => {
    if (status.downloadProgress <= 0) return 0;
    return Math.min(Math.round(status.downloadProgress * 100), 100);
  }, [status.downloadProgress]);

  const progressText = useMemo(() => {
    if (status.totalBytes <= 0) return "Preparing…";
    return `${formatBytes(status.downloadedBytes)} / ${formatBytes(status.totalBytes)}`;
  }, [status.downloadedBytes, status.totalBytes]);

  /* ── Installed ────────────────────────────────────────────────────── */

  if (status.state === "installed") {
    if (compact) {
      return (
        <div className={className} style={styles.compactBar}>
          <div style={styles.compactInner}>
            <span style={styles.compactIcon}>✓</span>
            <span style={styles.compactText}>
              Offline map ready ({formatBytes(status.sizeBytes)})
            </span>
            <button onClick={remove} style={styles.compactAction}>
              Remove
            </button>
          </div>
        </div>
      );
    }

    return (
      <div className={className} style={styles.card}>
        <div style={styles.row}>
          <div style={styles.iconCircleGreen}>
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
              <path d="M20 6 9 17l-5-5" />
            </svg>
          </div>
          <div style={{ flex: 1 }}>
            <div style={styles.title}>Offline map installed</div>
            <div style={styles.subtitle}>
              {formatBytes(status.sizeBytes)} · {region.charAt(0).toUpperCase() + region.slice(1)}
            </div>
          </div>
          <button onClick={remove} style={styles.removeBtn}>Remove</button>
        </div>
      </div>
    );
  }

  /* ── Downloading ──────────────────────────────────────────────────── */

  if (status.state === "downloading") {
    return (
      <div className={className} style={styles.card}>
        <div style={styles.row}>
          <div style={styles.iconCircleAmber}>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
              <path d="M12 5v14M19 12l-7 7-7-7" />
            </svg>
          </div>
          <div style={{ flex: 1 }}>
            <div style={styles.title}>Downloading offline map…</div>
            <div style={styles.subtitle}>{progressText}</div>
          </div>
          <button onClick={cancel} style={styles.cancelBtn}>Cancel</button>
        </div>
        {/* Progress bar */}
        <div style={styles.progressTrack}>
          <div
            style={{
              ...styles.progressFill,
              width: `${progressPct}%`,
              transition: "width 0.3s ease-out",
            }}
          />
        </div>
        {progressPct > 0 && (
          <div style={styles.pctText}>{progressPct}%</div>
        )}
      </div>
    );
  }

  /* ── Error ────────────────────────────────────────────────────────── */

  if (status.state === "error") {
    return (
      <div className={className} style={styles.card}>
        <div style={styles.row}>
          <div style={styles.iconCircleRed}>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
              <path d="M18 6 6 18M6 6l12 12" />
            </svg>
          </div>
          <div style={{ flex: 1 }}>
            <div style={styles.title}>Download failed</div>
            <div style={{ ...styles.subtitle, color: "rgba(239,68,68,0.9)" }}>
              {status.error ?? "Unknown error"}
            </div>
          </div>
          <button onClick={handleDownload} style={styles.retryBtn}>Retry</button>
        </div>
      </div>
    );
  }

  /* ── Not installed (prompt to download) ──────────────────────────── */

  // On web (non-native), show a softer informational banner instead of a download prompt
  // since web loads tiles from Supabase directly and doesn't need a local basemap pack.
  if (!isNative) {
    if (compact) {
      return (
        <div className={className} style={styles.compactBar}>
          <div style={styles.compactInner}>
            <span style={styles.compactIcon}>☁</span>
            <span style={styles.compactText}>
              Map tiles streaming online
            </span>
          </div>
        </div>
      );
    }

    return (
      <div className={className} style={styles.card}>
        <div style={styles.row}>
          <div style={styles.iconCircleBlue}>
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
              <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z" />
            </svg>
          </div>
          <div style={{ flex: 1 }}>
            <div style={styles.title}>Map tiles streaming</div>
            <div style={styles.subtitle}>
              Tiles loaded from cloud. Install the native app for offline maps.
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (compact) {
    return (
      <div className={className} style={styles.compactBar}>
        <div style={styles.compactInner}>
          <span style={styles.compactIcon}>↓</span>
          <span style={styles.compactText}>
            Offline map not installed
          </span>
          <button onClick={handleDownload} style={styles.compactDownloadBtn}>
            Download
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className={className} style={styles.card}>
      <div style={styles.row}>
        <div style={styles.iconCircleBlue}>
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <path d="M7 10l5 5 5-5" />
            <path d="M12 15V3" />
          </svg>
        </div>
        <div style={{ flex: 1 }}>
          <div style={styles.title}>Download offline map</div>
          <div style={styles.subtitle}>
            Required for navigation without reception.
            <br />
            Approx. 1 GB · Wi-Fi recommended
          </div>
        </div>
      </div>
      <button onClick={handleDownload} style={styles.downloadBtn}>
        Download Australia Map
      </button>
    </div>
  );
}

/* ── Styles ────────────────────────────────────────────────────────── */

const styles: Record<string, React.CSSProperties> = {
  card: {
    borderRadius: 16,
    padding: "14px 16px",
    background: "rgba(0,0,0,0.55)",
    backdropFilter: "blur(12px)",
    WebkitBackdropFilter: "blur(12px)",
    color: "#fff",
    boxShadow: "0 4px 24px rgba(0,0,0,0.25)",
  },
  row: {
    display: "flex",
    alignItems: "center",
    gap: 12,
  },
  iconCircleGreen: {
    width: 36, height: 36, borderRadius: 10,
    background: "#16a34a",
    display: "grid", placeItems: "center", flexShrink: 0,
  },
  iconCircleAmber: {
    width: 36, height: 36, borderRadius: 10,
    background: "#d97706",
    display: "grid", placeItems: "center", flexShrink: 0,
  },
  iconCircleRed: {
    width: 36, height: 36, borderRadius: 10,
    background: "#dc2626",
    display: "grid", placeItems: "center", flexShrink: 0,
  },
  iconCircleBlue: {
    width: 36, height: 36, borderRadius: 10,
    background: "#2563eb",
    display: "grid", placeItems: "center", flexShrink: 0,
  },
  title: {
    fontSize: 14, fontWeight: 900, letterSpacing: "-0.2px",
  },
  subtitle: {
    fontSize: 12, fontWeight: 600, opacity: 0.7, lineHeight: 1.4, marginTop: 2,
  },
  downloadBtn: {
    display: "block",
    width: "100%",
    marginTop: 12,
    padding: "12px 0",
    border: "none",
    borderRadius: 12,
    cursor: "pointer",
    fontSize: 14,
    fontWeight: 950,
    letterSpacing: "0.2px",
    background: "var(--roam-accent, #4a6c53)",
    color: "#fff",
    boxShadow: "0 2px 12px rgba(74,108,83,0.4)",
  },
  cancelBtn: {
    background: "rgba(255,255,255,0.12)",
    border: "none",
    borderRadius: 8,
    padding: "6px 14px",
    color: "#fff",
    fontSize: 12,
    fontWeight: 800,
    cursor: "pointer",
    flexShrink: 0,
  },
  removeBtn: {
    background: "rgba(255,255,255,0.08)",
    border: "none",
    borderRadius: 8,
    padding: "6px 14px",
    color: "rgba(255,255,255,0.6)",
    fontSize: 12,
    fontWeight: 700,
    cursor: "pointer",
    flexShrink: 0,
  },
  retryBtn: {
    background: "rgba(239,68,68,0.2)",
    border: "none",
    borderRadius: 8,
    padding: "6px 14px",
    color: "#fca5a5",
    fontSize: 12,
    fontWeight: 800,
    cursor: "pointer",
    flexShrink: 0,
  },
  progressTrack: {
    marginTop: 10,
    height: 4,
    borderRadius: 2,
    background: "rgba(255,255,255,0.12)",
    overflow: "hidden",
  },
  progressFill: {
    height: "100%",
    borderRadius: 2,
    background: "linear-gradient(90deg, #d97706, #f59e0b)",
  },
  pctText: {
    marginTop: 4,
    fontSize: 11,
    fontWeight: 800,
    opacity: 0.6,
    textAlign: "right" as const,
  },
  compactBar: {
    borderRadius: 10,
    padding: "8px 12px",
    background: "rgba(0,0,0,0.45)",
    backdropFilter: "blur(8px)",
    WebkitBackdropFilter: "blur(8px)",
    color: "#fff",
  },
  compactInner: {
    display: "flex",
    alignItems: "center",
    gap: 8,
    fontSize: 12,
    fontWeight: 700,
  },
  compactIcon: {
    fontSize: 14,
    fontWeight: 900,
  },
  compactText: {
    flex: 1,
    opacity: 0.85,
  },
  compactAction: {
    background: "none",
    border: "none",
    color: "rgba(255,255,255,0.5)",
    fontSize: 11,
    fontWeight: 700,
    cursor: "pointer",
    padding: "2px 6px",
    flexShrink: 0,
  },
  compactDownloadBtn: {
    background: "var(--roam-accent, #4a6c53)",
    border: "none",
    borderRadius: 6,
    color: "#fff",
    fontSize: 11,
    fontWeight: 900,
    cursor: "pointer",
    padding: "4px 10px",
    flexShrink: 0,
  },
};

===== src/components/fuel/FuelLastChanceToast.tsx =====

// src/components/fuel/FuelLastChanceToast.tsx
"use client";

import { useEffect, useState, useCallback } from "react";
import { Fuel, X } from "lucide-react";
import { haptic } from "@/lib/native/haptics";
import type { FuelWarning, FuelTrackingState } from "@/lib/types/fuel";

/* ── Constants ────────────────────────────────────────────────────────── */

/** Show toast when within this many km of a last-chance station */
const TRIGGER_DISTANCE_KM = 5;

/** Auto-dismiss after this many ms (0 = never) */
const AUTO_DISMISS_MS = 0; // user must dismiss manually for safety

/* ── Styles ────────────────────────────────────────────────────────────── */

const toastContainer: React.CSSProperties = {
  position: "absolute",
  top: 60,
  left: 12,
  right: 12,
  zIndex: 30,
  pointerEvents: "auto",
};

const toastCard: React.CSSProperties = {
  background: "rgba(239,68,68,0.95)",
  backdropFilter: "blur(16px)",
  WebkitBackdropFilter: "blur(16px)",
  borderRadius: 16,
  padding: "14px 16px",
  display: "flex",
  alignItems: "flex-start",
  gap: 10,
  boxShadow: "0 8px 32px rgba(239,68,68,0.35), 0 2px 8px rgba(0,0,0,0.2)",
  animation: "roam-fuel-toast-in 0.35s cubic-bezier(0.34, 1.56, 0.64, 1)",
};

const toastIcon: React.CSSProperties = {
  flexShrink: 0,
  marginTop: 1,
  color: "#fff",
};

const toastContent: React.CSSProperties = {
  flex: 1,
  minWidth: 0,
};

const toastTitle: React.CSSProperties = {
  fontSize: 14,
  fontWeight: 950,
  color: "#fff",
  letterSpacing: "-0.3px",
};

const toastSub: React.CSSProperties = {
  fontSize: 12,
  fontWeight: 700,
  color: "rgba(255,255,255,0.85)",
  marginTop: 3,
  lineHeight: "1.3",
};

const dismissBtn: React.CSSProperties = {
  background: "rgba(255,255,255,0.15)",
  border: "none",
  borderRadius: 8,
  padding: "6px 12px",
  fontSize: 12,
  fontWeight: 900,
  color: "#fff",
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  gap: 4,
  marginTop: 8,
};

/* ── Component ────────────────────────────────────────────────────────── */

export function FuelLastChanceToast({
  tracking,
  currentKm,
}: {
  tracking: FuelTrackingState | null;
  currentKm: number;
}) {
  const [dismissed, setDismissed] = useState<string | null>(null);
  const [visible, setVisible] = useState(false);
  const [activeWarning, setActiveWarning] = useState<FuelWarning | null>(null);

  useEffect(() => {
    if (!tracking || !tracking.active_warning) {
      setVisible(false);
      return;
    }

    const w = tracking.active_warning;
    if (w.type !== "last_chance") {
      setVisible(false);
      return;
    }

    // Don't show if already dismissed for this station
    const stationKey = w.station?.place_id ?? `km-${Math.round(w.at_km)}`;
    if (dismissed === stationKey) {
      setVisible(false);
      return;
    }

    // Check if within trigger distance
    if (w.station && Math.abs(currentKm - w.station.km_along_route) <= TRIGGER_DISTANCE_KM) {
      setActiveWarning(w);
      setVisible(true);
      haptic.warning();
    } else {
      setVisible(false);
    }
  }, [tracking, currentKm, dismissed]);

  const handleDismiss = useCallback(() => {
    haptic.selection();
    const stationKey = activeWarning?.station?.place_id ?? `km-${Math.round(activeWarning?.at_km ?? 0)}`;
    setDismissed(stationKey);
    setVisible(false);
  }, [activeWarning]);

  if (!visible || !activeWarning) return null;

  const station = activeWarning.station;
  const gapKm = activeWarning.gap_km ?? 0;

  return (
    <div style={toastContainer}>
      <div style={toastCard}>
        <Fuel size={20} strokeWidth={2.5} style={toastIcon} />
        <div style={toastContent}>
          <div style={toastTitle}>
            LAST FUEL for {Math.round(gapKm)}km
          </div>
          {station && (
            <div style={toastSub}>
              {station.name}
              {" — "}
              {tracking && tracking.km_to_next_fuel !== null
                ? `${Math.round(Math.abs(currentKm - station.km_along_route))}km ahead`
                : "ahead"}
              {station.side !== "on_route" && `, ${station.side}`}
            </div>
          )}
          <button type="button" style={dismissBtn} onClick={handleDismiss}>
            <X size={12} strokeWidth={2.5} />
            Dismiss
          </button>
        </div>
      </div>

      <style>{`
        @keyframes roam-fuel-toast-in {
          0% { opacity: 0; transform: translateY(-20px) scale(0.95); }
          100% { opacity: 1; transform: translateY(0) scale(1); }
        }
      `}</style>
    </div>
  );
}

===== src/components/fuel/FuelPressureIndicator.tsx =====

// src/components/fuel/FuelPressureIndicator.tsx
"use client";

import { useMemo } from "react";
import { Fuel } from "lucide-react";
import type { FuelTrackingState } from "@/lib/types/fuel";

/* ── Styles ────────────────────────────────────────────────────────────── */

const pillBase: React.CSSProperties = {
  position: "absolute",
  bottom: "calc(var(--roam-tab-h, 72px) + 14px)",
  left: 14,
  zIndex: 25,
  display: "flex",
  alignItems: "center",
  gap: 6,
  padding: "6px 12px",
  borderRadius: 999,
  backdropFilter: "blur(12px)",
  WebkitBackdropFilter: "blur(12px)",
  boxShadow: "0 4px 16px rgba(0,0,0,0.2), 0 1px 4px rgba(0,0,0,0.1)",
  fontWeight: 900,
  fontSize: 12,
  letterSpacing: "-0.2px",
  transition: "all 0.3s ease",
  pointerEvents: "none",
};

/* ── Color schemes ────────────────────────────────────────────────────── */

type PressureLevel = "ok" | "warn" | "critical";

function getLevel(pressure: number): PressureLevel {
  if (pressure >= 0.7) return "critical";
  if (pressure >= 0.3) return "warn";
  return "ok";
}

const LEVEL_STYLES: Record<PressureLevel, {
  bg: string;
  text: string;
  icon: string;
  border: string;
}> = {
  ok: {
    bg: "rgba(22,163,74,0.15)",
    text: "#16a34a",
    icon: "#22c55e",
    border: "1px solid rgba(22,163,74,0.25)",
  },
  warn: {
    bg: "rgba(245,158,11,0.18)",
    text: "#d97706",
    icon: "#f59e0b",
    border: "1px solid rgba(245,158,11,0.3)",
  },
  critical: {
    bg: "rgba(239,68,68,0.2)",
    text: "#ef4444",
    icon: "#ef4444",
    border: "1px solid rgba(239,68,68,0.35)",
  },
};

/* ── Component ────────────────────────────────────────────────────────── */

export function FuelPressureIndicator({
  tracking,
}: {
  tracking: FuelTrackingState | null;
}) {
  const display = useMemo(() => {
    if (!tracking) return null;

    const level = getLevel(tracking.fuel_pressure);
    const style = LEVEL_STYLES[level];

    let label: string;
    if (tracking.km_to_next_fuel !== null) {
      const km = Math.round(tracking.km_to_next_fuel);
      if (level === "critical") {
        label = `FUEL ${km}km`;
      } else {
        label = `Next fuel ${km}km`;
      }
    } else {
      label = "No fuel ahead";
    }

    return { level, style, label };
  }, [tracking]);

  if (!display) return null;

  const { level, style, label } = display;

  return (
    <div
      style={{
        ...pillBase,
        background: style.bg,
        color: style.text,
        border: style.border,
        // Pulse animation for critical
        animation: level === "critical" ? "roam-fuel-pulse 1.5s ease-in-out infinite" : undefined,
      }}
    >
      <Fuel
        size={level === "critical" ? 15 : 13}
        strokeWidth={2.5}
        style={{ color: style.icon }}
      />
      <span>{label}</span>

      {/* Inline keyframes for pulse animation */}
      {level === "critical" && (
        <style>{`
          @keyframes roam-fuel-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.03); }
          }
        `}</style>
      )}
    </div>
  );
}

===== src/components/fuel/FuelSummaryCard.tsx =====

// src/components/fuel/FuelSummaryCard.tsx
"use client";

import { useState, useCallback } from "react";
import { Fuel, AlertTriangle, ChevronDown, ChevronUp, Settings2 } from "lucide-react";
import { haptic } from "@/lib/native/haptics";

import type { FuelAnalysis, FuelWarning } from "@/lib/types/fuel";

/* ── Styles ────────────────────────────────────────────────────────────── */

const card: React.CSSProperties = {
  background: "var(--roam-surface-hover)",
  borderRadius: "var(--r-card, 16px)",
  padding: "14px 16px",
  marginBottom: 10,
};

const headerRow: React.CSSProperties = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  gap: 10,
};

const titleGroup: React.CSSProperties = {
  display: "flex",
  alignItems: "center",
  gap: 8,
  minWidth: 0,
};

const titleText: React.CSSProperties = {
  fontSize: 14,
  fontWeight: 900,
  color: "var(--roam-text)",
  letterSpacing: "-0.2px",
};

const subtitleText: React.CSSProperties = {
  fontSize: 12,
  fontWeight: 700,
  color: "var(--roam-text-muted)",
  marginTop: 4,
};

const statsRow: React.CSSProperties = {
  display: "flex",
  alignItems: "center",
  gap: 12,
  marginTop: 10,
  flexWrap: "wrap",
};

const statPill: React.CSSProperties = {
  fontSize: 11,
  fontWeight: 800,
  padding: "3px 10px",
  borderRadius: 999,
  whiteSpace: "nowrap" as const,
};

const warningBox: React.CSSProperties = {
  marginTop: 10,
  padding: "10px 12px",
  borderRadius: 12,
  display: "flex",
  alignItems: "flex-start",
  gap: 8,
};

const warningText: React.CSSProperties = {
  fontSize: 12,
  fontWeight: 700,
  lineHeight: "1.4",
};

const expandBtn: React.CSSProperties = {
  background: "none",
  border: "none",
  padding: "2px 6px",
  borderRadius: 8,
  display: "inline-flex",
  alignItems: "center",
  gap: 4,
  fontSize: 11,
  fontWeight: 800,
  color: "var(--roam-text-muted)",
  cursor: "pointer",
};

const fuelStripContainer: React.CSSProperties = {
  marginTop: 10,
  padding: "6px 0",
};

const fuelStripBar: React.CSSProperties = {
  display: "flex",
  height: 8,
  borderRadius: 4,
  overflow: "hidden",
  background: "rgba(0,0,0,0.15)",
};

const stationDot: React.CSSProperties = {
  width: 6,
  height: 6,
  borderRadius: 3,
  border: "1.5px solid rgba(255,255,255,0.8)",
  position: "absolute" as const,
  top: 1,
  transform: "translateX(-3px)",
};

const settingsBtn: React.CSSProperties = {
  background: "none",
  border: "none",
  padding: 6,
  borderRadius: 8,
  display: "grid",
  placeItems: "center",
  cursor: "pointer",
  color: "var(--roam-text-muted)",
  flexShrink: 0,
};

/* ── Color helpers ────────────────────────────────────────────────────── */

function severityColor(severity: string): { bg: string; text: string; icon: string } {
  switch (severity) {
    case "critical":
      return { bg: "rgba(239,68,68,0.12)", text: "#ef4444", icon: "#ef4444" };
    case "warn":
      return { bg: "rgba(245,158,11,0.12)", text: "#d97706", icon: "#f59e0b" };
    default:
      return { bg: "rgba(59,130,246,0.1)", text: "#3b82f6", icon: "#3b82f6" };
  }
}

function legColor(leg: { gap_exceeds_range: boolean; gap_exceeds_warn: boolean }): string {
  if (leg.gap_exceeds_range) return "#ef4444";
  if (leg.gap_exceeds_warn) return "#f59e0b";
  return "#22c55e";
}

function rangeStatusColor(analysis: FuelAnalysis): string {
  if (analysis.has_critical_gaps) return "#ef4444";
  if (analysis.warnings.some((w) => w.severity === "warn")) return "#f59e0b";
  return "#22c55e";
}

function rangeStatusLabel(analysis: FuelAnalysis): string {
  if (analysis.has_critical_gaps) return "FUEL GAP";
  if (analysis.warnings.some((w) => w.severity === "warn")) return "Tight";
  return "Range OK";
}

/* ── Component ────────────────────────────────────────────────────────── */

export function FuelSummaryCard({
  analysis,
  onOpenSettings,
}: {
  analysis: FuelAnalysis | null;
  onOpenSettings?: () => void;
}) {
  const [expanded, setExpanded] = useState(false);

  const toggleExpanded = useCallback(() => {
    haptic.selection();
    setExpanded((v) => !v);
  }, []);

  if (!analysis) return null;

  const { stations, legs, warnings, max_gap_km, has_critical_gaps, profile } = analysis;
  const statusColor = rangeStatusColor(analysis);
  const statusLabel = rangeStatusLabel(analysis);

  // Find the worst gap for display
  const worstGap = legs.reduce<{ from: string; to: string; km: number } | null>((best, leg) => {
    if (!best || leg.distance_km > best.km) {
      return {
        from: leg.from_station?.name ?? "Start",
        to: leg.to_station?.name ?? "End",
        km: leg.distance_km,
      };
    }
    return best;
  }, null);

  // Top warnings (critical + warn only)
  const topWarnings = warnings.filter((w) => w.severity === "critical" || w.severity === "warn");

  // Total route km from legs
  const totalKm = legs.reduce((sum, l) => sum + l.distance_km, 0);

  return (
    <div style={card}>
      {/* Header */}
      <div style={headerRow}>
        <div style={titleGroup}>
          <Fuel size={16} strokeWidth={2.5} style={{ color: statusColor, flexShrink: 0 }} />
          <div>
            <div style={titleText}>Fuel Coverage</div>
            <div style={subtitleText}>
              {stations.length} station{stations.length !== 1 ? "s" : ""} along route
              {max_gap_km > 0 && ` · Longest gap ${Math.round(max_gap_km)}km`}
            </div>
          </div>
        </div>
        <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
          {onOpenSettings && (
            <button
              type="button"
              style={settingsBtn}
              onClick={(e) => { e.stopPropagation(); haptic.selection(); onOpenSettings(); }}
              aria-label="Fuel settings"
            >
              <Settings2 size={15} strokeWidth={2.5} />
            </button>
          )}
        </div>
      </div>

      {/* Status pills */}
      <div style={statsRow}>
        <span style={{
          ...statPill,
          background: `${statusColor}18`,
          color: statusColor,
        }}>
          {statusLabel}
        </span>
        <span style={{
          ...statPill,
          background: "rgba(0,0,0,0.08)",
          color: "var(--roam-text-muted)",
        }}>
          Range {profile.tank_range_km}km
        </span>
        {profile.fuel_type !== "unleaded" && (
          <span style={{
            ...statPill,
            background: "rgba(0,0,0,0.08)",
            color: "var(--roam-text-muted)",
          }}>
            {profile.fuel_type.toUpperCase()}
          </span>
        )}
      </div>

      {/* Fuel strip visualization */}
      {legs.length > 0 && totalKm > 0 && (
        <div style={fuelStripContainer}>
          <div style={{ position: "relative" as const }}>
            <div style={fuelStripBar}>
              {legs.map((leg, i) => (
                <div
                  key={i}
                  style={{
                    flex: leg.distance_km / totalKm,
                    background: legColor(leg),
                    opacity: 0.7,
                    minWidth: 2,
                    borderRight: i < legs.length - 1 ? "1px solid rgba(255,255,255,0.3)" : undefined,
                  }}
                />
              ))}
            </div>
            {/* Station dots overlaid on the strip */}
            {stations.map((st) => {
              const pct = totalKm > 0 ? (st.km_along_route / totalKm) * 100 : 0;
              return (
                <div
                  key={st.place_id}
                  style={{
                    ...stationDot,
                    left: `${pct}%`,
                    background: "#fff",
                  }}
                  title={st.name}
                />
              );
            })}
          </div>
          {worstGap && max_gap_km > profile.reserve_warn_km && (
            <div style={{ fontSize: 10, fontWeight: 700, color: "var(--roam-text-muted)", marginTop: 4, textAlign: "center" as const }}>
              {worstGap.from} → {worstGap.to}: {Math.round(worstGap.km)}km
            </div>
          )}
        </div>
      )}

      {/* Top warnings */}
      {topWarnings.length > 0 && (
        <>
          {topWarnings.slice(0, expanded ? undefined : 2).map((w, i) => {
            const clr = severityColor(w.severity);
            return (
              <div key={i} style={{ ...warningBox, background: clr.bg }}>
                <AlertTriangle size={14} strokeWidth={2.5} style={{ color: clr.icon, flexShrink: 0, marginTop: 1 }} />
                <div style={{ ...warningText, color: clr.text }}>{w.message}</div>
              </div>
            );
          })}

          {topWarnings.length > 2 && (
            <button type="button" style={expandBtn} onClick={toggleExpanded}>
              {expanded ? <ChevronUp size={12} /> : <ChevronDown size={12} />}
              {expanded ? "Less" : `${topWarnings.length - 2} more`}
            </button>
          )}
        </>
      )}

      {/* Critical gap recommendation */}
      {has_critical_gaps && worstGap && (
        <div style={{
          marginTop: 8,
          padding: "8px 12px",
          borderRadius: 10,
          background: "rgba(239,68,68,0.06)",
          border: "1px solid rgba(239,68,68,0.15)",
        }}>
          <div style={{ fontSize: 11, fontWeight: 900, color: "#ef4444", marginBottom: 2 }}>
            Recommendation
          </div>
          <div style={{ fontSize: 12, fontWeight: 700, color: "var(--roam-text-muted)", lineHeight: "1.4" }}>
            Fill up and carry a 20L jerry can from {worstGap.from}. The {Math.round(worstGap.km)}km gap
            {worstGap.km > profile.tank_range_km
              ? ` exceeds your ${profile.tank_range_km}km range.`
              : ` leaves only ${Math.round(profile.tank_range_km - worstGap.km)}km margin.`}
          </div>
        </div>
      )}
    </div>
  );
}

===== src/components/fuel/VehicleFuelSettings.tsx =====

// src/components/fuel/VehicleFuelSettings.tsx
"use client";

import { useState, useCallback, useEffect } from "react";
import { X, Fuel, Zap, Flame, PlugZap } from "lucide-react";
import { haptic } from "@/lib/native/haptics";
import { getVehicleFuelProfile, setVehicleFuelProfile } from "@/lib/offline/fuelProfileStore";
import { DEFAULT_FUEL_PROFILE, type VehicleFuelProfile, type FuelType } from "@/lib/types/fuel";

/* ── Styles ────────────────────────────────────────────────────────────── */

const overlay: React.CSSProperties = {
  position: "fixed",
  inset: 0,
  zIndex: 100,
  background: "rgba(0,0,0,0.5)",
  backdropFilter: "blur(8px)",
  WebkitBackdropFilter: "blur(8px)",
  display: "grid",
  placeItems: "center",
  padding: 20,
};

const panel: React.CSSProperties = {
  width: "100%",
  maxWidth: 380,
  maxHeight: "80vh",
  overflowY: "auto",
  background: "var(--roam-surface)",
  borderRadius: 20,
  padding: "20px 20px 24px",
  boxShadow: "0 16px 64px rgba(0,0,0,0.25)",
  animation: "roam-fuel-settings-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)",
};

const headerRow: React.CSSProperties = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  marginBottom: 20,
};

const titleText: React.CSSProperties = {
  fontSize: 18,
  fontWeight: 950,
  color: "var(--roam-text)",
  letterSpacing: "-0.3px",
};

const closeBtn: React.CSSProperties = {
  background: "var(--roam-surface-hover)",
  border: "none",
  borderRadius: 999,
  width: 36,
  height: 36,
  display: "grid",
  placeItems: "center",
  cursor: "pointer",
  color: "var(--roam-text-muted)",
};

const sectionLabel: React.CSSProperties = {
  fontSize: 12,
  fontWeight: 900,
  color: "var(--roam-text-muted)",
  marginBottom: 8,
  marginTop: 18,
  letterSpacing: "0.3px",
  textTransform: "uppercase" as const,
};

const segmentRow: React.CSSProperties = {
  display: "flex",
  gap: 6,
  flexWrap: "wrap" as const,
};

const segmentBtn = (active: boolean): React.CSSProperties => ({
  flex: 1,
  minWidth: 70,
  padding: "10px 12px",
  borderRadius: 12,
  border: active ? "2px solid var(--roam-accent)" : "2px solid transparent",
  background: active ? "rgba(59,130,246,0.1)" : "var(--roam-surface-hover)",
  color: active ? "var(--roam-accent)" : "var(--roam-text-muted)",
  fontWeight: 900,
  fontSize: 12,
  cursor: "pointer",
  display: "flex",
  flexDirection: "column" as const,
  alignItems: "center",
  gap: 4,
  transition: "all 0.15s ease",
});

const sliderGroup: React.CSSProperties = {
  display: "flex",
  flexDirection: "column" as const,
  gap: 6,
};

const sliderLabel: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  fontSize: 13,
  fontWeight: 800,
  color: "var(--roam-text)",
};

const sliderValue: React.CSSProperties = {
  fontSize: 13,
  fontWeight: 900,
  color: "var(--roam-accent)",
};

const sliderInput: React.CSSProperties = {
  width: "100%",
  accentColor: "var(--roam-accent, #3b82f6)",
  height: 6,
};

const saveButton: React.CSSProperties = {
  width: "100%",
  marginTop: 24,
  padding: "12px 20px",
  borderRadius: 12,
  background: "var(--roam-accent)",
  color: "#fff",
  border: "none",
  fontWeight: 950,
  fontSize: 14,
  cursor: "pointer",
  boxShadow: "var(--shadow-button)",
};

/* ── Fuel type configs ────────────────────────────────────────────────── */

const FUEL_TYPES: Array<{ type: FuelType; label: string; icon: React.ReactNode }> = [
  { type: "unleaded", label: "Unleaded", icon: <Fuel size={16} strokeWidth={2.5} /> },
  { type: "diesel", label: "Diesel", icon: <Flame size={16} strokeWidth={2.5} /> },
  { type: "lpg", label: "LPG", icon: <Zap size={16} strokeWidth={2.5} /> },
  { type: "ev", label: "EV", icon: <PlugZap size={16} strokeWidth={2.5} /> },
];

/* ── Component ────────────────────────────────────────────────────────── */

export function VehicleFuelSettings({
  open,
  onClose,
  onSaved,
}: {
  open: boolean;
  onClose: () => void;
  onSaved?: (profile: VehicleFuelProfile) => void;
}) {
  const [profile, setProfile] = useState<VehicleFuelProfile>({ ...DEFAULT_FUEL_PROFILE });
  const [loaded, setLoaded] = useState(false);

  // Load current profile from IDB on open
  useEffect(() => {
    if (!open) return;
    let cancelled = false;
    getVehicleFuelProfile().then((p) => {
      if (!cancelled) { setProfile(p); setLoaded(true); }
    });
    return () => { cancelled = true; };
  }, [open]);

  const updateField = useCallback(<K extends keyof VehicleFuelProfile>(
    key: K,
    value: VehicleFuelProfile[K],
  ) => {
    haptic.selection();
    setProfile((prev) => ({ ...prev, [key]: value }));
  }, []);

  const handleSave = useCallback(async () => {
    haptic.medium();
    try {
      await setVehicleFuelProfile(profile);
      onSaved?.(profile);
      onClose();
      haptic.success();
    } catch (e) {
      console.error("[FuelSettings] save failed:", e);
      haptic.error();
    }
  }, [profile, onSaved, onClose]);

  if (!open) return null;

  return (
    <div style={overlay} onClick={onClose}>
      <div style={panel} onClick={(e) => e.stopPropagation()}>
        {/* Header */}
        <div style={headerRow}>
          <div style={titleText}>Vehicle Fuel Settings</div>
          <button type="button" style={closeBtn} onClick={onClose}>
            <X size={16} strokeWidth={2.5} />
          </button>
        </div>

        {/* Fuel type */}
        <div style={sectionLabel}>Fuel Type</div>
        <div style={segmentRow}>
          {FUEL_TYPES.map(({ type, label, icon }) => (
            <button
              key={type}
              type="button"
              style={segmentBtn(profile.fuel_type === type)}
              onClick={() => updateField("fuel_type", type)}
            >
              {icon}
              {label}
            </button>
          ))}
        </div>

        {/* Tank range */}
        <div style={sectionLabel}>Tank Range</div>
        <div style={sliderGroup}>
          <div style={sliderLabel}>
            <span>Full tank range</span>
            <span style={sliderValue}>{profile.tank_range_km} km</span>
          </div>
          <input
            type="range"
            min={100}
            max={1500}
            step={10}
            value={profile.tank_range_km}
            onChange={(e) => updateField("tank_range_km", Number(e.target.value))}
            style={sliderInput}
          />
          <div style={{ display: "flex", justifyContent: "space-between", fontSize: 10, fontWeight: 700, color: "var(--roam-text-muted)" }}>
            <span>100 km</span>
            <span>1500 km</span>
          </div>
        </div>

        {/* Reserve warning */}
        <div style={sectionLabel}>Reserve Warning</div>
        <div style={sliderGroup}>
          <div style={sliderLabel}>
            <span>Warning threshold</span>
            <span style={sliderValue}>{profile.reserve_warn_km} km</span>
          </div>
          <input
            type="range"
            min={30}
            max={Math.min(300, profile.tank_range_km - 20)}
            step={5}
            value={Math.min(profile.reserve_warn_km, profile.tank_range_km - 20)}
            onChange={(e) => updateField("reserve_warn_km", Number(e.target.value))}
            style={sliderInput}
          />
        </div>

        <div style={{ ...sliderGroup, marginTop: 10 }}>
          <div style={sliderLabel}>
            <span>Critical threshold</span>
            <span style={{ ...sliderValue, color: "#ef4444" }}>{profile.reserve_critical_km} km</span>
          </div>
          <input
            type="range"
            min={10}
            max={Math.min(200, profile.reserve_warn_km - 10)}
            step={5}
            value={Math.min(profile.reserve_critical_km, profile.reserve_warn_km - 10)}
            onChange={(e) => updateField("reserve_critical_km", Number(e.target.value))}
            style={sliderInput}
          />
        </div>

        {/* Summary */}
        <div style={{
          marginTop: 18,
          padding: "10px 14px",
          borderRadius: 12,
          background: "var(--roam-surface-hover)",
          fontSize: 12,
          fontWeight: 700,
          color: "var(--roam-text-muted)",
          lineHeight: "1.5",
        }}>
          Roam will warn at {profile.reserve_warn_km}km remaining range and alert critically at{" "}
          {profile.reserve_critical_km}km. Fuel gaps longer than {profile.tank_range_km}km will be
          flagged as impassable.
        </div>

        {/* Save */}
        <button type="button" style={saveButton} onClick={handleSave}>
          Save Settings
        </button>
      </div>

      <style>{`
        @keyframes roam-fuel-settings-in {
          0% { opacity: 0; transform: scale(0.95) translateY(10px); }
          100% { opacity: 1; transform: scale(1) translateY(0); }
        }
      `}</style>
    </div>
  );
}

===== src/components/native/BasemapBootstrap.tsx =====

// src/components/native/BasemapBootstrap.tsx
//
// Runs once at app startup. Checks if the offline basemap is installed
// and starts the local tile server if so. Silent — no UI.
// Must be inside a client boundary.

"use client";

import { useEffect, useRef } from "react";
import { initBasemap } from "@/lib/offline/basemapManager";

export function BasemapBootstrap() {
  const ran = useRef(false);

  useEffect(() => {
    if (ran.current) return;
    ran.current = true;

    initBasemap("australia")
      .then((status) => {
        if (status.state === "installed") {
          console.log("[BasemapBootstrap] ✅ Tile server started, basemap ready");
        } else {
          console.log("[BasemapBootstrap] Basemap not installed:", status.state);
        }
      })
      .catch((e) => {
        console.warn("[BasemapBootstrap] init failed (non-fatal):", e);
      });
  }, []);

  return null;
}

===== src/components/native/NativeBootstrap.tsx =====

// src/components/native/NativeBootstrap.tsx
"use client";

import { useEffect, useRef } from "react";
import { useRouter } from "next/navigation";

import {
  isNative,
  configureStatusBar,
  configureKeyboard,
  lockPortrait,
  hideSplash,
  initAppLifecycle,
  onAppStateChange,
  initNotificationTapListener,
  requestNotificationPermission,
  onNotificationTap,
} from "@/lib/native";
import { networkMonitor } from "@/lib/offline/networkMonitor";
import { planSync } from "@/lib/offline/planSync";

/**
 * Invisible component that initializes all native Capacitor plugins.
 *
 * Mount once in the root layout. Renders nothing.
 *
 * Initialization order:
 *   1. Status bar → dark, transparent (instant visual)
 *   2. Screen orientation → lock portrait
 *   3. Keyboard → configure resize + done button
 *   4. App lifecycle → listen for foreground/background
 *   5. Notifications → request permission + listen for taps
 *   6. Splash screen → hide after all setup is done
 */
export function NativeBootstrap() {
  const router = useRouter();
  const initRef = useRef(false);

  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    (async () => {
      // 1. Visual setup (status bar)
      await configureStatusBar();

      // 2. Lock orientation
      await lockPortrait();

      // 3. Keyboard behavior
      await configureKeyboard();

      // 4. App lifecycle (foreground/background)
      await initAppLifecycle();

      // When app comes to foreground: trigger sync drain + network recheck
      onAppStateChange((state) => {
        if (state === "foreground") {
          // Recheck network and drain sync queue
          networkMonitor.start(); // idempotent — will re-poll health
          planSync.drainQueue();
        }
      });

      // 5. Notifications
      await requestNotificationPermission();
      await initNotificationTapListener();

      // Handle notification taps → route to relevant screen
      onNotificationTap((extra) => {
        const type = extra?.type;
        if (type === "bundle_ready" || type === "sync") {
          router.push("/plans");
        } else if (type === "hazard") {
          router.push("/trip");
        }
      });

      // 6. Hide splash (everything is ready)
      //    Small delay ensures the first paint has happened
      setTimeout(() => hideSplash(), 150);
    })();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return null;
}

===== src/components/nav/ElevationStrip.tsx =====

// src/components/nav/ElevationStrip.tsx
"use client";

import { useMemo } from "react";
import type { ElevationProfile, GradeSegment } from "@/lib/types/navigation";
import { formatDistance } from "@/lib/nav/instructions";

type Props = {
  profile: ElevationProfile;
  gradeSegments?: GradeSegment[];
  /** Current km along route (for position marker during active nav) */
  currentKm?: number | null;
  /** Compact mode for inline display */
  compact?: boolean;
};

/* ── Grade → colour mapping ──────────────────────────────────────── */

function gradeColor(gradePct: number): string {
  const abs = Math.abs(gradePct);
  if (abs < 2)  return "#4ade80"; // flat — green
  if (abs < 5)  return "#fbbf24"; // moderate — amber
  return "#ef4444";               // steep — red
}

/* ── Component ───────────────────────────────────────────────────── */

export function ElevationStrip({ profile, gradeSegments, currentKm, compact }: Props) {
  const samples = profile.samples;
  if (!samples || samples.length < 2) return null;

  const totalKm = samples[samples.length - 1].km_along;
  const height = compact ? 40 : 56;
  const width = 100; // percentage-based, rendered in SVG viewBox

  // Build SVG path for the elevation sparkline
  const { path, minElev, maxElev } = useMemo(() => {
    const elevs = samples.map((s) => s.elevation_m);
    const min = Math.min(...elevs);
    const max = Math.max(...elevs);
    const range = max - min || 1;
    const pad = 4; // px padding top/bottom

    const points = samples.map((s) => {
      const x = totalKm > 0 ? (s.km_along / totalKm) * width : 0;
      const y = height - pad - ((s.elevation_m - min) / range) * (height - pad * 2);
      return `${x.toFixed(2)},${y.toFixed(2)}`;
    });

    // Closed path for fill (goes to bottom-right, bottom-left, then back to start)
    const fillPath =
      `M${points[0]} ` +
      points.slice(1).map((p) => `L${p}`).join(" ") +
      ` L${width},${height} L0,${height} Z`;

    return { path: fillPath, minElev: min, maxElev: max };
  }, [samples, totalKm, height]);

  // Grade-colored segments for the fill
  const gradeFills = useMemo(() => {
    if (!gradeSegments || gradeSegments.length === 0) return null;

    return gradeSegments.map((seg) => {
      const x1 = totalKm > 0 ? (seg.from_km / totalKm) * width : 0;
      const x2 = totalKm > 0 ? (seg.to_km / totalKm) * width : 0;
      return {
        x: x1,
        width: x2 - x1,
        color: gradeColor(seg.avg_grade_pct),
        opacity: Math.abs(seg.avg_grade_pct) > 5 ? 0.35 : 0.2,
      };
    });
  }, [gradeSegments, totalKm]);

  // Current position marker
  const posX = currentKm != null && totalKm > 0
    ? (currentKm / totalKm) * width
    : null;

  return (
    <div
      style={{
        width: "100%",
        position: "relative",
        borderRadius: 12,
        overflow: "hidden",
        background: "var(--roam-surface-hover)",
      }}
    >
      <svg
        viewBox={`0 0 ${width} ${height}`}
        preserveAspectRatio="none"
        style={{ width: "100%", height, display: "block" }}
      >
        {/* Grade-colored background strips */}
        {gradeFills?.map((seg, i) => (
          <rect
            key={i}
            x={seg.x}
            y={0}
            width={Math.max(seg.width, 0.3)}
            height={height}
            fill={seg.color}
            opacity={seg.opacity}
          />
        ))}

        {/* Elevation fill — semi-transparent */}
        <path
          d={path}
          fill="rgba(74,108,83,0.25)"
          stroke="none"
        />

        {/* Elevation line — crisp outline */}
        <path
          d={path.replace(/ L\d+[\d.]*,\d+[\d.]* L0,\d+[\d.]* Z/, "")} // strip the close path
          fill="none"
          stroke="rgba(74,108,83,0.7)"
          strokeWidth={0.8}
          vectorEffect="non-scaling-stroke"
        />

        {/* Current position marker */}
        {posX != null && (
          <>
            <line
              x1={posX}
              y1={0}
              x2={posX}
              y2={height}
              stroke="white"
              strokeWidth={1.2}
              vectorEffect="non-scaling-stroke"
              opacity={0.8}
            />
            <circle
              cx={posX}
              cy={(() => {
                // Find elevation at current position
                const range = maxElev - minElev || 1;
                const pad = 4;
                let elev = minElev;
                for (let i = 1; i < samples.length; i++) {
                  if (samples[i].km_along >= (currentKm ?? 0)) {
                    const prev = samples[i - 1];
                    const curr = samples[i];
                    const frac =
                      curr.km_along - prev.km_along > 0
                        ? ((currentKm ?? 0) - prev.km_along) / (curr.km_along - prev.km_along)
                        : 0;
                    elev = prev.elevation_m + (curr.elevation_m - prev.elevation_m) * frac;
                    break;
                  }
                }
                return height - pad - ((elev - minElev) / range) * (height - pad * 2);
              })()}
              r={2.5}
              fill="white"
              stroke="rgba(74,108,83,0.9)"
              strokeWidth={1.5}
              vectorEffect="non-scaling-stroke"
            />
          </>
        )}
      </svg>

      {/* Stats overlay */}
      {!compact && (
        <div
          style={{
            position: "absolute",
            bottom: 4,
            left: 8,
            right: 8,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <span style={{ fontSize: 10, fontWeight: 800, color: "var(--roam-text-muted)" }}>
            {formatDistance(totalKm * 1000)}
          </span>
          <div style={{ display: "flex", gap: 8 }}>
            <span style={{ fontSize: 10, fontWeight: 800, color: "#4ade80" }}>
              ↑ {Math.round(profile.total_ascent_m)}m
            </span>
            <span style={{ fontSize: 10, fontWeight: 800, color: "#f87171" }}>
              ↓ {Math.round(profile.total_descent_m)}m
            </span>
          </div>
        </div>
      )}
    </div>
  );
}

===== src/components/nav/NavigationBar.tsx =====

// src/components/nav/NavigationBar.tsx
"use client";

import type { ActiveNavState } from "@/lib/nav/activeNav";
import type { FuelTrackingState } from "@/lib/types/fuel";
import { formatDistance, formatDuration, formatETA } from "@/lib/nav/instructions";
import { formatDriveSinceRest, fatigueColor } from "@/lib/nav/fatigue";
import { Fuel, Clock, MapPin, Navigation } from "lucide-react";

type Props = {
  nav: ActiveNavState;
  fuelTracking?: FuelTrackingState | null;
  visible: boolean;
  onTap?: () => void;
};

export function NavigationBar({ nav, fuelTracking, visible, onTap }: Props) {
  if (!visible) return null;

  const eta = nav.etaTimestamp > 0 ? formatETA(nav.etaTimestamp) : "--:--";
  const distRemaining = formatDistance(nav.distRemaining_m);
  const timeRemaining = formatDuration(nav.durationRemaining_s);
  const fatigue = nav.fatigue;
  const fColor = fatigueColor(fatigue.warningLevel);

  // Fuel: distance to next station or range info
  const fuelText = fuelTracking
    ? fuelTracking.km_to_next_fuel !== null
      ? `${Math.round(fuelTracking.km_to_next_fuel)} km`
      : "--"
    : null;

    const fuelUrgent = !!fuelTracking?.is_critical;
  return (
    <div
      style={{
        position: "absolute",
        bottom: "calc(env(safe-area-inset-bottom, 0px) + var(--roam-tab-h, 64px) + 8px)",
        left: 12,
        right: 12,
        zIndex: 30,
        pointerEvents: "auto",
        transform: visible ? "translateY(0)" : "translateY(150%)",
        transition: "transform 0.3s cubic-bezier(0.4,0,0.2,1)",
      }}
      onClick={onTap}
    >
      <div
        style={{
          background: "linear-gradient(135deg, rgba(30,30,30,0.94), rgba(20,20,20,0.97))",
          borderRadius: 18,
          padding: "14px 18px",
          backdropFilter: "blur(20px)",
          WebkitBackdropFilter: "blur(20px)",
          boxShadow: "0 8px 32px rgba(0,0,0,0.35), 0 2px 8px rgba(0,0,0,0.2)",
        }}
      >
        {/* Top row: ETA + distance + time */}
        <div
          style={{
            display: "flex",
            alignItems: "baseline",
            justifyContent: "space-between",
            gap: 12,
          }}
        >
          {/* ETA — prominent */}
          <div>
            <div
              style={{
                fontSize: 24,
                fontWeight: 950,
                color: "white",
                letterSpacing: "-0.5px",
                lineHeight: 1,
              }}
            >
              {eta}
            </div>
            <div
              style={{
                fontSize: 10,
                fontWeight: 800,
                color: "rgba(255,255,255,0.4)",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
                marginTop: 2,
              }}
            >
              ETA
            </div>
          </div>

          {/* Distance remaining */}
          <div style={{ textAlign: "center" }}>
            <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
              <MapPin size={13} color="rgba(255,255,255,0.5)" />
              <span
                style={{
                  fontSize: 16,
                  fontWeight: 900,
                  color: "rgba(255,255,255,0.85)",
                  letterSpacing: "-0.3px",
                }}
              >
                {distRemaining}
              </span>
            </div>
          </div>

          {/* Time remaining */}
          <div style={{ textAlign: "center" }}>
            <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
              <Clock size={13} color="rgba(255,255,255,0.5)" />
              <span
                style={{
                  fontSize: 16,
                  fontWeight: 900,
                  color: "rgba(255,255,255,0.85)",
                  letterSpacing: "-0.3px",
                }}
              >
                {timeRemaining}
              </span>
            </div>
          </div>
        </div>

        {/* Bottom row: fuel + fatigue indicators */}
        <div
          style={{
            marginTop: 10,
            paddingTop: 10,
            borderTop: "1px solid rgba(255,255,255,0.08)",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 12,
          }}
        >
          {/* Fuel indicator */}
          {fuelText && (
            <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
              <Fuel
                size={14}
                color={fuelUrgent ? "#ef4444" : "#d97706"}
                style={fuelUrgent ? { animation: "fuel-blink 1s ease-in-out infinite" } : undefined}
              />
              <span
                style={{
                  fontSize: 12,
                  fontWeight: 850,
                  color: fuelUrgent ? "#ef4444" : "rgba(255,255,255,0.65)",
                  letterSpacing: "-0.2px",
                }}
              >
                {fuelUrgent ? "Fuel!" : ""} {fuelText}
              </span>
            </div>
          )}

          {/* Fatigue indicator */}
          <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
            <Navigation
              size={13}
              color={fColor}
              style={{
                opacity: fatigue.warningLevel === "none" ? 0.5 : 1,
              }}
            />
            <span
              style={{
                fontSize: 12,
                fontWeight: 850,
                color: fColor,
                letterSpacing: "-0.2px",
              }}
            >
              {formatDriveSinceRest(fatigue)}
            </span>
          </div>

          {/* Speed (if available) */}
          {nav.speed_mps != null && nav.speed_mps > 0.5 && (
            <div
              style={{
                fontSize: 13,
                fontWeight: 900,
                color: "rgba(255,255,255,0.6)",
                letterSpacing: "-0.2px",
              }}
            >
              {Math.round(nav.speed_mps * 3.6)} km/h
            </div>
          )}
        </div>
      </div>

      <style>{`
        @keyframes fuel-blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.4; }
        }
      `}</style>
    </div>
  );
}

===== src/components/nav/NavigationControls.tsx =====

// src/components/nav/NavigationControls.tsx
"use client";

import { useState } from "react";
import { Volume2, VolumeX, Maximize2, Crosshair, X } from "lucide-react";
import { haptic } from "@/lib/native/haptics";

type Props = {
  visible: boolean;
  isMuted: boolean;
  onToggleMute: () => void;
  onOverview: () => void;
  onRecenter: () => void;
  onEnd: () => void;
};

function FloatingBtn({
  icon,
  label,
  onClick,
  danger,
  active,
}: {
  icon: React.ReactNode;
  label: string;
  onClick: () => void;
  danger?: boolean;
  active?: boolean;
}) {
  return (
    <button
      type="button"
      aria-label={label}
      onClick={() => {
        haptic.selection();
        onClick();
      }}
      style={{
        width: 44,
        height: 44,
        borderRadius: 14,
        border: "none",
        cursor: "pointer",
        display: "grid",
        placeItems: "center",
        background: danger
          ? "rgba(239,68,68,0.9)"
          : active
          ? "rgba(74,108,83,0.9)"
          : "rgba(30,30,30,0.88)",
        color: "white",
        backdropFilter: "blur(12px)",
        WebkitBackdropFilter: "blur(12px)",
        boxShadow: "0 4px 16px rgba(0,0,0,0.3), 0 1px 4px rgba(0,0,0,0.15)",
        transition: "transform 0.1s ease, background 0.2s ease",
      }}
      onPointerDown={(e) => {
        (e.currentTarget as HTMLElement).style.transform = "scale(0.92)";
      }}
      onPointerUp={(e) => {
        (e.currentTarget as HTMLElement).style.transform = "scale(1)";
      }}
      onPointerCancel={(e) => {
        (e.currentTarget as HTMLElement).style.transform = "scale(1)";
      }}
    >
      {icon}
    </button>
  );
}

export function NavigationControls({
  visible,
  isMuted,
  onToggleMute,
  onOverview,
  onRecenter,
  onEnd,
}: Props) {
  const [confirmEnd, setConfirmEnd] = useState(false);

  if (!visible) return null;

  return (
    <div
      style={{
        position: "absolute",
        top: "calc(env(safe-area-inset-top, 0px) + 130px)",
        right: 12,
        zIndex: 25,
        pointerEvents: "auto",
        display: "flex",
        flexDirection: "column",
        gap: 10,
      }}
    >
      {/* Mute / unmute */}
      <FloatingBtn
        icon={isMuted ? <VolumeX size={20} /> : <Volume2 size={20} />}
        label={isMuted ? "Unmute voice" : "Mute voice"}
        onClick={onToggleMute}
        active={!isMuted}
      />

      {/* Overview — zoom out to see full route */}
      <FloatingBtn
        icon={<Maximize2 size={20} />}
        label="Route overview"
        onClick={onOverview}
      />

      {/* Recenter on user */}
      <FloatingBtn
        icon={<Crosshair size={20} />}
        label="Recenter"
        onClick={onRecenter}
      />

      {/* End navigation — requires confirmation */}
      {!confirmEnd ? (
        <FloatingBtn
          icon={<X size={20} />}
          label="End navigation"
          onClick={() => setConfirmEnd(true)}
          danger
        />
      ) : (
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            gap: 6,
            background: "rgba(30,30,30,0.95)",
            borderRadius: 16,
            padding: 8,
            backdropFilter: "blur(12px)",
            WebkitBackdropFilter: "blur(12px)",
            boxShadow: "0 8px 32px rgba(0,0,0,0.4)",
          }}
        >
          <div
            style={{
              fontSize: 11,
              fontWeight: 900,
              color: "rgba(255,255,255,0.6)",
              textAlign: "center",
              padding: "2px 4px",
            }}
          >
            End nav?
          </div>
          <button
            type="button"
            onClick={() => {
              haptic.medium();
              setConfirmEnd(false);
              onEnd();
            }}
            style={{
              width: "100%",
              padding: "8px 12px",
              border: "none",
              borderRadius: 10,
              cursor: "pointer",
              fontSize: 12,
              fontWeight: 950,
              color: "white",
              background: "#ef4444",
            }}
          >
            Yes, end
          </button>
          <button
            type="button"
            onClick={() => {
              haptic.selection();
              setConfirmEnd(false);
            }}
            style={{
              width: "100%",
              padding: "8px 12px",
              border: "none",
              borderRadius: 10,
              cursor: "pointer",
              fontSize: 12,
              fontWeight: 950,
              color: "rgba(255,255,255,0.7)",
              background: "rgba(255,255,255,0.1)",
            }}
          >
            Cancel
          </button>
        </div>
      )}
    </div>
  );
}

===== src/components/nav/NavigationHUD.tsx =====

// src/components/nav/NavigationHUD.tsx
"use client";

import { useMemo } from "react";
import type { ActiveNavState } from "@/lib/nav/activeNav";
import { formatInstruction, formatShort, formatDistance, maneuverIcon } from "@/lib/nav/instructions";

type Props = {
  nav: ActiveNavState;
  visible: boolean;
};

/* ── Maneuver arrow SVGs (clean, bold, white on transparent) ──────── */

const ARROW_SVGS: Record<string, string> = {
  "arrow-up":          "M12 4 12 20M12 4 5 11M12 4 19 11",
  "arrow-left":        "M5 12 20 12M5 12 12 5M5 12 12 19",
  "arrow-right":       "M19 12 4 12M19 12 12 5M19 12 12 19",
  "arrow-slight-left": "M7 4 7 20M7 4 17 14",
  "arrow-slight-right":"M17 4 17 20M17 4 7 14",
  "arrow-sharp-left":  "M5 19 5 4M5 19 19 5",
  "arrow-sharp-right": "M19 19 19 4M19 19 5 5",
  "uturn-left":        "M5 20 5 10a7 7 0 0 1 14 0M5 20 1 16M5 20 9 16",
  "roundabout":        "M12 12m-5 0a5 5 0 1 0 10 0 5 5 0 1 0-10 0M12 7 12 2M12 2 9 5M12 2 15 5",
  "roundabout-exit":   "M12 12m-5 0a5 5 0 1 0 10 0 5 5 0 1 0-10 0M17 12 22 12M22 12 19 9M22 12 19 15",
  "merge-left":        "M6 4 12 12 12 20M18 4 12 12",
  "merge-right":       "M18 4 12 12 12 20M6 4 12 12",
  "fork-left":         "M12 20 12 12 5 4M12 12 19 4",
  "fork-right":        "M12 20 12 12 19 4M12 12 5 4",
  "ramp-left":         "M12 20 12 12 5 4",
  "ramp-right":        "M12 20 12 12 19 4",
  "offramp-left":      "M12 20 12 12 5 4M12 12 4 12",
  "offramp-right":     "M12 20 12 12 19 4M12 12 20 12",
  "arrive":            "M12 2a7 7 0 0 0-7 7c0 5 7 13 7 13s7-8 7-13a7 7 0 0 0-7-7Zm0 4a3 3 0 1 1 0 6 3 3 0 0 1 0-6Z",
  "depart":            "M4 2v20M4 2l12 7-12 7",
};

function ManeuverArrow({ iconName, size = 48 }: { iconName: string; size?: number }) {
  const pathD = ARROW_SVGS[iconName] ?? ARROW_SVGS["arrow-up"];
  const isArrive = iconName === "arrive" || iconName === "depart";

  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill={isArrive ? "white" : "none"}
      stroke={isArrive ? "none" : "white"}
      strokeWidth={2.5}
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d={pathD} />
    </svg>
  );
}

/* ── Component ───────────────────────────────────────────────────── */

export function NavigationHUD({ nav, visible }: Props) {
  const currentStep = nav.currentStep;
  const nextStep = nav.nextStep;

  const iconName = useMemo(
    () => (currentStep ? maneuverIcon(currentStep.maneuver) : "arrow-up"),
    [currentStep],
  );

  // Determine approach state for visual intensity
  const isImminent = nav.distToNextManeuver_m < 100;
  const isApproaching = nav.distToNextManeuver_m < 500;

  if (!visible || !currentStep) return null;

  return (
    <div
      style={{
        position: "absolute",
        top: "calc(env(safe-area-inset-top, 0px) + 12px)",
        left: 12,
        right: 12,
        zIndex: 30,
        pointerEvents: "auto",
        transform: visible ? "translateY(0)" : "translateY(-120%)",
        transition: "transform 0.3s cubic-bezier(0.4,0,0.2,1)",
      }}
    >
      {/* Main maneuver card */}
      <div
        style={{
          background: isImminent
            ? "linear-gradient(135deg, #16a34a, #15803d)"
            : isApproaching
            ? "linear-gradient(135deg, #2563eb, #1d4ed8)"
            : "linear-gradient(135deg, rgba(30,30,30,0.92), rgba(20,20,20,0.95))",
          borderRadius: 20,
          padding: "16px 18px",
          backdropFilter: "blur(20px)",
          WebkitBackdropFilter: "blur(20px)",
          boxShadow: "0 8px 32px rgba(0,0,0,0.4), 0 2px 8px rgba(0,0,0,0.2)",
          transition: "background 0.4s ease",
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 14 }}>
          {/* Arrow icon */}
          <div
            style={{
              flexShrink: 0,
              width: 56,
              height: 56,
              display: "grid",
              placeItems: "center",
              animation: isImminent ? "hud-pulse 0.8s ease-in-out infinite" : undefined,
            }}
          >
            <ManeuverArrow iconName={iconName} size={48} />
          </div>

          {/* Instruction text */}
          <div style={{ flex: 1, minWidth: 0 }}>
            <div
              style={{
                fontSize: 15,
                fontWeight: 950,
                color: "white",
                lineHeight: 1.2,
                letterSpacing: "-0.2px",
              }}
            >
              {formatShort(currentStep)}
            </div>
            {currentStep.name && (
              <div
                style={{
                  fontSize: 13,
                  fontWeight: 700,
                  color: "rgba(255,255,255,0.75)",
                  marginTop: 2,
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                  whiteSpace: "nowrap",
                }}
              >
                {currentStep.ref
                  ? `${currentStep.name} (${currentStep.ref})`
                  : currentStep.name}
              </div>
            )}
          </div>

          {/* Distance to maneuver */}
          <div
            style={{
              flexShrink: 0,
              textAlign: "right",
            }}
          >
            <div
              style={{
                fontSize: 22,
                fontWeight: 950,
                color: "white",
                letterSpacing: "-0.5px",
                lineHeight: 1,
              }}
            >
              {formatDistance(nav.distToNextManeuver_m)}
            </div>
          </div>
        </div>

        {/* Next step preview */}
        {nextStep && (
          <div
            style={{
              marginTop: 10,
              paddingTop: 10,
              borderTop: "1px solid rgba(255,255,255,0.12)",
              display: "flex",
              alignItems: "center",
              gap: 8,
            }}
          >
            <span
              style={{
                fontSize: 11,
                fontWeight: 800,
                color: "rgba(255,255,255,0.45)",
                textTransform: "uppercase",
                letterSpacing: "0.5px",
              }}
            >
              then
            </span>
            <span
              style={{
                fontSize: 12,
                fontWeight: 700,
                color: "rgba(255,255,255,0.6)",
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
              }}
            >
              {formatInstruction(nextStep)}
            </span>
          </div>
        )}
      </div>

      {/* Pulse animation for imminent turns */}
      <style>{`
        @keyframes hud-pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.08); }
        }
      `}</style>
    </div>
  );
}

===== src/components/nav/OffRouteBanner.tsx =====

// src/components/nav/OffRouteBanner.tsx
"use client";

import { AlertTriangle, RotateCcw } from "lucide-react";
import { formatDistance } from "@/lib/nav/instructions";
import { haptic } from "@/lib/native/haptics";

type Props = {
  visible: boolean;
  distFromRoute_m: number;
  hasCorridorGraph: boolean;
  onReroute?: () => void;
};

export function OffRouteBanner({ visible, distFromRoute_m, hasCorridorGraph, onReroute }: Props) {
  if (!visible) return null;

  return (
    <div
      style={{
        position: "absolute",
        top: "calc(env(safe-area-inset-top, 0px) + 12px)",
        left: 12,
        right: 12,
        zIndex: 35, // above HUD
        pointerEvents: "auto",
        animation: "offroute-slide-in 0.3s ease-out",
      }}
    >
      <div
        style={{
          background: "linear-gradient(135deg, #dc2626, #b91c1c)",
          borderRadius: 16,
          padding: "14px 16px",
          boxShadow: "0 8px 32px rgba(220,38,38,0.4), 0 2px 8px rgba(0,0,0,0.2)",
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
          <AlertTriangle
            size={24}
            color="white"
            style={{ flexShrink: 0, animation: "offroute-pulse 1.5s ease-in-out infinite" }}
          />
          <div style={{ flex: 1, minWidth: 0 }}>
            <div
              style={{
                fontSize: 15,
                fontWeight: 950,
                color: "white",
                lineHeight: 1.2,
              }}
            >
              Off route
            </div>
            <div
              style={{
                fontSize: 12,
                fontWeight: 700,
                color: "rgba(255,255,255,0.75)",
                marginTop: 2,
              }}
            >
              {formatDistance(distFromRoute_m)} from planned route
            </div>
          </div>

          {hasCorridorGraph && onReroute && (
            <button
              type="button"
              onClick={() => {
                haptic.medium();
                onReroute();
              }}
              style={{
                flexShrink: 0,
                display: "flex",
                alignItems: "center",
                gap: 6,
                padding: "8px 14px",
                border: "none",
                borderRadius: 10,
                cursor: "pointer",
                fontSize: 12,
                fontWeight: 950,
                color: "#dc2626",
                background: "white",
                boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
              }}
              onPointerDown={(e) => {
                (e.currentTarget as HTMLElement).style.transform = "scale(0.95)";
              }}
              onPointerUp={(e) => {
                (e.currentTarget as HTMLElement).style.transform = "scale(1)";
              }}
              onPointerCancel={(e) => {
                (e.currentTarget as HTMLElement).style.transform = "scale(1)";
              }}
            >
              <RotateCcw size={14} />
              Reroute
            </button>
          )}
        </div>

        {!hasCorridorGraph && (
          <div
            style={{
              marginTop: 8,
              fontSize: 11,
              fontWeight: 700,
              color: "rgba(255,255,255,0.65)",
            }}
          >
            No corridor data available for rerouting. Return to your planned route.
          </div>
        )}
      </div>

      <style>{`
        @keyframes offroute-slide-in {
          from { transform: translateY(-120%); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
        @keyframes offroute-pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
      `}</style>
    </div>
  );
}

===== src/components/nav/StartNavigationButton.tsx =====

// src/components/nav/StartNavigationButton.tsx
"use client";

import { useState } from "react";
import { Navigation, Loader2 } from "lucide-react";
import { haptic } from "@/lib/native/haptics";

type Props = {
  onStart: () => Promise<void>;
  disabled?: boolean;
};

export function StartNavigationButton({ onStart, disabled }: Props) {
  const [loading, setLoading] = useState(false);

  const handlePress = async () => {
    if (loading || disabled) return;
    haptic.medium();
    setLoading(true);
    try {
      await onStart();
    } catch (e) {
      console.error("[StartNav] failed:", e);
    } finally {
      setLoading(false);
    }
  };

  return (
    <button
      type="button"
      onClick={handlePress}
      disabled={loading || disabled}
      style={{
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: 10,
        padding: "14px 24px",
        border: "none",
        borderRadius: 16,
        cursor: loading || disabled ? "default" : "pointer",
        fontSize: 16,
        fontWeight: 950,
        letterSpacing: "-0.3px",
        color: "white",
        background: loading || disabled
          ? "rgba(74,108,83,0.5)"
          : "linear-gradient(135deg, #4a6c53, #3d5a45)",
        boxShadow: loading || disabled
          ? "none"
          : "0 4px 16px rgba(74,108,83,0.4), 0 1px 4px rgba(0,0,0,0.1)",
        transition: "all 0.2s ease",
        opacity: disabled ? 0.5 : 1,
      }}
      onPointerDown={(e) => {
        if (!loading && !disabled) {
          (e.currentTarget as HTMLElement).style.transform = "scale(0.97)";
        }
      }}
      onPointerUp={(e) => {
        (e.currentTarget as HTMLElement).style.transform = "scale(1)";
      }}
      onPointerCancel={(e) => {
        (e.currentTarget as HTMLElement).style.transform = "scale(1)";
      }}
    >
      {loading ? (
        <Loader2 size={20} style={{ animation: "spin 1s linear infinite" }} />
      ) : (
        <Navigation size={20} />
      )}
      {loading ? "Starting…" : "Start Navigation"}
      <style>{`
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
      `}</style>
    </button>
  );
}

===== src/components/plans/InviteCodeModal.tsx =====

// src/components/plans/InviteCodeModal.tsx
"use client";

import { useCallback, useState } from "react";
import { useRouter } from "next/navigation";
import { usePlanSync } from "@/lib/hooks/usePlanSync";
import { useBundleBuilder } from "@/lib/hooks/useBundleBuilder";
import { getOfflinePlan, setCurrentPlanId } from "@/lib/offline/plansStore";

type Props = {
  open: boolean;
  planId: string | null;
  mode: "create" | "redeem";
  onClose: () => void;
  onRedeemed?: (planId: string) => void;
};

/**
 * Modal for creating or redeeming plan invite codes.
 *
 * Create mode: generates a 6-char code for the given planId.
 * Redeem mode: accepts a code → joins plan → builds local bundle → navigates to /trip.
 */
export function InviteCodeModal({ open, planId, mode, onClose, onRedeemed }: Props) {
  const router = useRouter();
  const { createInvite, redeemInvite, online } = usePlanSync();
  const bundle = useBundleBuilder();

  const [code, setCode] = useState("");
  const [generatedCode, setGeneratedCode] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /* ── Create flow ───────────────────────────────────────────────────── */

  const handleCreate = useCallback(async () => {
    if (!planId) return;
    if (!online) {
      setError("You need to be online to create an invite code");
      return;
    }
    setBusy(true);
    setError(null);
    try {
      const c = await createInvite(planId);
      setGeneratedCode(c);
    } catch (e: any) {
      setError(e?.message ?? "Failed to create invite");
    } finally {
      setBusy(false);
    }
  }, [planId, createInvite, online]);

  /* ── Redeem flow (join → build bundle → navigate) ──────────────────── */

  const handleRedeem = useCallback(async () => {
    const trimmed = code.trim().toUpperCase();
    if (trimmed.length < 4) {
      setError("Enter a valid invite code");
      return;
    }
    if (!online) {
      setError("You need to be online to redeem an invite code");
      return;
    }

    setBusy(true);
    setError(null);

    try {
      // 1. Join the plan via Supabase (adds membership + pulls definition to IDB)
      const joinedPlanId = await redeemInvite(trimmed);

      // 2. Read the plan stub from IDB (planSync.pullRemote just wrote it)
      const stub = await getOfflinePlan(joinedPlanId);

      if (!stub?.preview?.stops?.length) {
        throw new Error("Joined plan has no route data. Ask the owner to re-share.");
      }

      // 3. Build the full offline bundle from the plan definition
      //    This runs the same pipeline as /new: route → corridor → places → bundle → zip
      await bundle.build({
        plan_id: joinedPlanId,
        stops: stub.preview.stops,
        profile: stub.preview.profile || "drive",
        styleId: "roam-basemap-vector-bright",
      });

      // 4. Set as current plan
      await setCurrentPlanId(joinedPlanId);

      // 5. Notify parent + navigate
      onRedeemed?.(joinedPlanId);
      onClose();
      router.push(`/trip?plan_id=${encodeURIComponent(joinedPlanId)}`);
    } catch (e: any) {
      setError(e?.message ?? "Failed to join plan");
    } finally {
      setBusy(false);
    }
  }, [code, redeemInvite, online, bundle, onRedeemed, onClose, router]);

  /* ── Copy code ─────────────────────────────────────────────────────── */

  const handleCopy = useCallback(() => {
    if (generatedCode) {
      navigator.clipboard?.writeText(generatedCode).catch(() => {});
    }
  }, [generatedCode]);

  if (!open) return null;

  // Are we in the bundle-building phase of redemption?
  const isBuilding = bundle.building;
  const buildingOrBusy = busy || isBuilding;

  return (
    <div className="trip-modal-overlay" role="dialog" aria-modal="true" onClick={onClose}>
      <div className="trip-modal" onClick={(e) => e.stopPropagation()}>
        {/* ── Header ─────────────────────────────────────────────────── */}
        <div className="trip-row-between">
          <div className="trip-h2">
            {mode === "create" ? "Share Plan" : "Join Plan"}
          </div>
          <button
            type="button"
            onClick={onClose}
            className="trip-interactive trip-btn-icon"
            aria-label="Close"
            disabled={isBuilding}
          >
            ✕
          </button>
        </div>

        {/* ── Create mode ────────────────────────────────────────────── */}
        {mode === "create" ? (
          <>
            {generatedCode ? (
              <div style={{ textAlign: "center", padding: "16px 0" }}>
                <div style={{ fontSize: 13, color: "var(--roam-muted, #888)", marginBottom: 12 }}>
                  Share this code with your travel partner
                </div>
                <div
                  style={{
                    fontSize: 32,
                    fontWeight: 700,
                    letterSpacing: "0.2em",
                    fontFamily: "monospace",
                    padding: "12px 0",
                  }}
                >
                  {generatedCode}
                </div>
                <button
                  type="button"
                  onClick={handleCopy}
                  className="trip-interactive trip-btn trip-btn-secondary"
                  style={{ marginTop: 8 }}
                >
                  Copy code
                </button>
              </div>
            ) : (
              <div style={{ textAlign: "center", padding: "16px 0" }}>
                <div style={{ fontSize: 13, color: "var(--roam-muted, #888)", marginBottom: 16 }}>
                  Generate a 6-character code so your partner can view and edit this trip plan on
                  their device.
                </div>
                <button
                  type="button"
                  onClick={handleCreate}
                  disabled={busy}
                  className="trip-interactive trip-btn"
                  style={{
                    background: "var(--roam-accent, #3b82f6)",
                    color: "#fff",
                    border: "none",
                    padding: "12px 24px",
                    borderRadius: 8,
                    fontSize: 14,
                    fontWeight: 600,
                  }}
                >
                  {busy ? "Generating…" : "Generate invite code"}
                </button>
              </div>
            )}
          </>
        ) : (
          /* ── Redeem mode ───────────────────────────────────────────── */
          <div style={{ padding: "8px 0" }}>
            {/* Bundle build progress replaces the input form */}
            {isBuilding ? (
              <div style={{ textAlign: "center", padding: "20px 0" }}>
                {/* Spinner */}
                <div
                  style={{
                    width: 40,
                    height: 40,
                    margin: "0 auto 16px",
                    border: "3px solid var(--roam-border, #333)",
                    borderTop: "3px solid var(--roam-accent, #3b82f6)",
                    borderRadius: "50%",
                    animation: "roam-spin 0.8s linear infinite",
                  }}
                />
                <div style={{ fontSize: 14, fontWeight: 600, marginBottom: 6 }}>
                  Building your offline bundle…
                </div>
                <div style={{ fontSize: 13, color: "var(--roam-muted, #888)" }}>
                  {bundle.statusText}
                </div>
              </div>
            ) : (
              <>
                <div style={{ fontSize: 13, color: "var(--roam-muted, #888)", marginBottom: 12 }}>
                  Enter the 6-character code from your travel partner
                </div>
                <input
                  value={code}
                  onChange={(e) => setCode(e.target.value.toUpperCase())}
                  placeholder="e.g. A3BX7K"
                  maxLength={6}
                  autoFocus
                  disabled={buildingOrBusy}
                  style={{
                    width: "100%",
                    textAlign: "center",
                    fontSize: 24,
                    fontWeight: 700,
                    letterSpacing: "0.2em",
                    fontFamily: "monospace",
                    padding: "12px 14px",
                    borderRadius: 8,
                    border: "1px solid var(--roam-border, #333)",
                    background: "var(--roam-surface, #1a1a1a)",
                    color: "var(--roam-text, #eee)",
                    boxSizing: "border-box",
                  }}
                />
                <button
                  type="button"
                  onClick={handleRedeem}
                  disabled={buildingOrBusy || code.trim().length < 4}
                  className="trip-interactive trip-btn"
                  style={{
                    width: "100%",
                    marginTop: 12,
                    background: "var(--roam-accent, #3b82f6)",
                    color: "#fff",
                    border: "none",
                    padding: "12px 16px",
                    borderRadius: 8,
                    fontSize: 14,
                    fontWeight: 600,
                    opacity: buildingOrBusy || code.trim().length < 4 ? 0.5 : 1,
                  }}
                >
                  {busy && !isBuilding ? "Joining…" : "Join plan"}
                </button>
              </>
            )}
          </div>
        )}

        {/* ── Error banner ───────────────────────────────────────────── */}
        {(error || bundle.error) && (
          <div
            style={{
              padding: "10px 12px",
              borderRadius: 8,
              background: "rgba(239,68,68,0.12)",
              color: "#f87171",
              fontSize: 13,
              textAlign: "center",
              marginTop: 8,
            }}
          >
            {error || bundle.error}
          </div>
        )}
      </div>

      {/* Keyframe for spinner */}
      <style>{`
        @keyframes roam-spin {
          to { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}

===== src/components/trip/GuideView.tsx =====

// src/components/trip/GuideView.tsx
"use client";

import { useMemo, useRef, useState, useEffect } from "react";
import type { PlacesPack, PlaceItem, PlaceCategory } from "@/lib/types/places";
import type { MouseEvent, SyntheticEvent } from "react";

import type {
  GuidePack,
  DiscoveredPlace,
  TripProgress,
  GuideAction,
  GuideMsg,
} from "@/lib/types/guide";
import { haptic } from "@/lib/native/haptics";

import type { LucideIcon } from "lucide-react";
import {
  Search,
  Sparkles,
  MapPin,
  Layers,
  Fuel,
  Tent,
  Bath,
  Droplets,
  Building2,
  ShoppingCart,
  Wrench,
  Hospital,
  Pill,
  Coffee,
  Utensils,
  TreePine,
  Eye,
  Waves,
  Bed,
  Phone,
  Link2,
  ParkingMeter,
  Target,
  Camera,
  Zap,
  Wine,
  Beer,
  Info,
  Mountain,
  Landmark,
  Baby,
  Trash2,
  Banknote,
  Shirt,
  Thermometer,
  Star,
  Store,
  Globe,
  Compass,
  ExternalLink,
} from "lucide-react";

// ──────────────────────────────────────────────────────────────
// Constants — category chips + icon map
// ──────────────────────────────────────────────────────────────

type ChipKey = PlaceCategory | "all";
type Chip = { key: ChipKey; label: string; Icon: LucideIcon };

/**
 * Chips in priority order for the horizontal scroll bar.
 * First ~8 are visible without scrolling on most phones.
 * Organised: safety → food → sleep → nature → family → culture → supplies
 */
const CHIPS: Chip[] = [
  { key: "all", label: "All", Icon: Layers },
  // Safety & essentials
  { key: "fuel", label: "Fuel", Icon: Fuel },
  { key: "ev_charging", label: "EV", Icon: Zap },
  { key: "rest_area", label: "Rest", Icon: ParkingMeter },
  { key: "toilet", label: "Toilets", Icon: Bath },
  { key: "water", label: "Water", Icon: Droplets },
  // Food & drink
  { key: "bakery", label: "Bakery", Icon: Star },
  { key: "cafe", label: "Café", Icon: Coffee },
  { key: "restaurant", label: "Food", Icon: Utensils },
  { key: "fast_food", label: "Takeaway", Icon: Utensils },
  { key: "pub", label: "Pub", Icon: Beer },
  // Accommodation
  { key: "camp", label: "Camp", Icon: Tent },
  { key: "motel", label: "Motel", Icon: Bed },
  { key: "hotel", label: "Hotel", Icon: Bed },
  // Nature & outdoors
  { key: "viewpoint", label: "Views", Icon: Eye },
  { key: "beach", label: "Beach", Icon: Waves },
  { key: "swimming_hole", label: "Swim", Icon: Waves },
  { key: "waterfall", label: "Waterfall", Icon: Droplets },
  { key: "national_park", label: "Parks", Icon: TreePine },
  { key: "hiking", label: "Hiking", Icon: Mountain },
  { key: "picnic", label: "Picnic", Icon: TreePine },
  { key: "hot_spring", label: "Hot Spring", Icon: Thermometer },
  // Family & recreation
  { key: "playground", label: "Kids", Icon: Baby },
  { key: "pool", label: "Pool", Icon: Waves },
  { key: "zoo", label: "Zoo", Icon: Compass },
  { key: "theme_park", label: "Theme Park", Icon: Star },
  // Culture & sightseeing
  { key: "winery", label: "Wine", Icon: Wine },
  { key: "brewery", label: "Brew", Icon: Beer },
  { key: "visitor_info", label: "Info", Icon: Info },
  { key: "museum", label: "Museum", Icon: Landmark },
  { key: "gallery", label: "Gallery", Icon: Landmark },
  { key: "heritage", label: "Heritage", Icon: Landmark },
  { key: "attraction", label: "Sights", Icon: Camera },
  { key: "market", label: "Market", Icon: Store },
  // Supplies
  { key: "grocery", label: "Grocery", Icon: ShoppingCart },
  { key: "town", label: "Towns", Icon: Building2 },
  { key: "atm", label: "ATM", Icon: Banknote },
  { key: "laundromat", label: "Laundry", Icon: Shirt },
  { key: "dump_point", label: "Dump", Icon: Trash2 },
  { key: "mechanic", label: "Mechanic", Icon: Wrench },
  { key: "hospital", label: "Hospital", Icon: Hospital },
  { key: "pharmacy", label: "Pharmacy", Icon: Pill },
];

/** Fast lookup: category → icon component */
const CATEGORY_ICON: Record<string, LucideIcon> = {};
for (const c of CHIPS) CATEGORY_ICON[c.key] = c.Icon;

type ViewTab = "chat" | "discoveries" | "browse";

// ──────────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────────

function getTags(p: PlaceItem): Record<string, any> {
  const ex: any = p.extra ?? {};
  if (ex?.tags && typeof ex.tags === "object") return ex.tags as Record<string, any>;
  return ex as Record<string, any>;
}

function fmtCategory(c?: string) {
  return (c ?? "").replace(/_/g, " ");
}

function fmtDist(km?: number | null) {
  if (km == null) return null;
  if (km < 1) return `${Math.round(km * 1000)} m`;
  return `${km.toFixed(1)} km`;
}

function safeOpen(url: string) {
  try {
    window.open(url, "_blank", "noopener,noreferrer");
  } catch {}
}

function normalizeUrl(raw: string) {
  const s = raw.trim();
  if (!s) return null;
  if (/^https?:\/\//i.test(s)) return s;
  if (/^www\./i.test(s)) return `https://${s}`;
  if (/^[a-z0-9.-]+\.[a-z]{2,}(\/|$)/i.test(s)) return `https://${s}`;
  return null;
}

function normalizeUrlKey(normUrl: string) {
  try {
    const u = new URL(normUrl);
    const host = (u.host || "").toLowerCase().replace(/^www\./, "");
    const path = (u.pathname || "/").replace(/\/+$/, "") || "/";
    return `${host}${path}`;
  } catch {
    return normUrl
      .toLowerCase()
      .replace(/^https?:\/\//, "")
      .replace(/^www\./, "")
      .replace(/\/+$/, "");
  }
}

function cleanPhone(raw: string) {
  const trimmed = raw.trim();
  const keepPlus = trimmed.startsWith("+");
  const digits = trimmed.replace(/[^\d]/g, "");
  if (digits.length < 8 || digits.length > 15) return null;
  return (keepPlus ? "+" : "") + digits;
}

function stopEvent(e: SyntheticEvent) {
  e.stopPropagation();
}

// ──────────────────────────────────────────────────────────────
// Markdown-based action extraction (FALLBACK for old messages
// that don't have structured actions from the backend)
// ──────────────────────────────────────────────────────────────

type FallbackAction =
  | { type: "web"; url: string; label: string }
  | { type: "call"; tel: string; label: string };

function extractActionsFromMarkdown(text: string): FallbackAction[] {
  if (!text) return [];

  const actions: FallbackAction[] = [];
  const seenWeb = new Set<string>();
  const seenTel = new Set<string>();

  const lines = text.split(/\r?\n/);
  const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
  const urlRegex =
    /(https?:\/\/[^\s)>\]]+|www\.[^\s)>\]]+|[a-z0-9.-]+\.[a-z]{2,}(\/[^\s)>\]]*)?)/gi;
  const phoneRegex = /(\+?\d[\d\s().-]{6,}\d)/g;

  const cleanName = (s: string | null | undefined) => {
    const t = (s ?? "").trim();
    if (!t) return null;
    return t.replace(/^\s*(?:\d+\.)?\s*[-*•]?\s*/, "").trim() || null;
  };

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    const bold = line.match(/\*\*(.+?)\*\*/);
    const lineName = cleanName(bold?.[1]);

    const strippedLine = line.replace(markdownLinkRegex, (_m, _lbl, urlRaw) => {
      const href = normalizeUrl(String(urlRaw)) ?? String(urlRaw).trim();
      if (href) {
        const key = normalizeUrlKey(href);
        if (!seenWeb.has(key)) {
          seenWeb.add(key);
          actions.push({ type: "web", url: href, label: lineName ?? "Website" });
        }
      }
      return " ";
    });

    const urlMatches = Array.from(strippedLine.matchAll(urlRegex));
    for (const m of urlMatches) {
      const norm = normalizeUrl(m[0]);
      if (!norm) continue;
      const key = normalizeUrlKey(norm);
      if (seenWeb.has(key)) continue;
      seenWeb.add(key);
      actions.push({ type: "web", url: norm, label: lineName ?? "Website" });
    }

    const phoneMatches = Array.from(line.matchAll(phoneRegex));
    for (const m of phoneMatches) {
      const tel = cleanPhone(m[0]);
      if (!tel) continue;
      const telKey = tel.replace(/[^\d+]/g, "");
      if (seenTel.has(telKey)) continue;
      seenTel.add(telKey);
      actions.push({ type: "call", tel, label: lineName ? `Call ${lineName}` : "Call" });
    }
  }

  return actions.slice(0, 10);
}

// ──────────────────────────────────────────────────────────────
// Action pill component
// ──────────────────────────────────────────────────────────────

function ActionPill({
  Icon,
  label,
  onClick,
  href,
  muted,
}: {
  Icon: LucideIcon;
  label: string;
  onClick?: () => void;
  href?: string;
  muted?: boolean;
}) {
  const baseStyle: React.CSSProperties = {
    borderRadius: 999,
    minHeight: 36,
    padding: "0 12px",
    fontWeight: 950,
    fontSize: 12.5,
    border: "none",
    background: muted ? "var(--roam-surface)" : "var(--roam-surface-hover)",
    color: "var(--roam-text)",
    boxShadow: "var(--shadow-button)",
    display: "inline-flex",
    alignItems: "center",
    gap: 8,
    cursor: "pointer",
    textDecoration: "none",
    userSelect: "none",
    WebkitTapHighlightColor: "transparent",
  };

  if (href) {
    return (
      <a
        href={href}
        className="trip-interactive"
        style={baseStyle}
        onPointerDown={stopEvent}
        onTouchStart={stopEvent}
        onClick={stopEvent}
      >
        <Icon size={15} />
        <span className="trip-truncate" style={{ maxWidth: 200 }}>
          {label}
        </span>
      </a>
    );
  }

  return (
    <button
      type="button"
      className="trip-interactive"
      style={baseStyle}
      onPointerDown={stopEvent}
      onTouchStart={stopEvent}
      onClick={(e) => {
        stopEvent(e);
        onClick?.();
      }}
    >
      <Icon size={15} />
      <span className="trip-truncate" style={{ maxWidth: 200 }}>
        {label}
      </span>
    </button>
  );
}

// ──────────────────────────────────────────────────────────────
// Message actions row — prefers structured backend actions,
// falls back to markdown extraction for older messages
// ──────────────────────────────────────────────────────────────

function MessageActionsRow({
  msg,
  isOnline,
}: {
  msg: GuideMsg;
  isOnline: boolean;
}) {
  const structured = msg.actions ?? [];

  // Only extract from markdown if no structured actions exist
  const fallback = useMemo(() => {
    if (structured.length > 0) return [];
    return extractActionsFromMarkdown(msg.content ?? "");
  }, [msg.content, structured.length]);

  const hasStructured = structured.length > 0;
  const hasFallback = fallback.length > 0;
  if (!hasStructured && !hasFallback) return null;

  return (
    <div style={{ marginTop: 10, display: "flex", flexWrap: "wrap", gap: 8 }}>
      {/* Structured actions from backend (preferred) */}
      {structured.map((a, idx) => {
        if (a.type === "web" && a.url) {
          return (
            <ActionPill
              key={`sa_web_${idx}_${a.place_id ?? idx}`}
              Icon={ExternalLink}
              label={a.label}
              onClick={
                isOnline
                  ? () => {
                      haptic.selection();
                      safeOpen(a.url!);
                    }
                  : () => haptic.selection()
              }
              muted={!isOnline}
            />
          );
        }
        if (a.type === "call" && a.tel) {
          return (
            <ActionPill
              key={`sa_call_${idx}_${a.place_id ?? idx}`}
              Icon={Phone}
              label={a.label}
              href={`tel:${a.tel}`}
            />
          );
        }
        return null;
      })}

      {/* Fallback: extracted from markdown */}
      {fallback.map((a, idx) => {
        if (a.type === "web") {
          return (
            <ActionPill
              key={`fb_web_${idx}`}
              Icon={Link2}
              label={a.label}
              onClick={
                isOnline
                  ? () => {
                      haptic.selection();
                      safeOpen(a.url);
                    }
                  : () => haptic.selection()
              }
              muted={!isOnline}
            />
          );
        }
        return (
          <ActionPill
            key={`fb_call_${idx}`}
            Icon={Phone}
            label={a.label}
            href={`tel:${a.tel}`}
          />
        );
      })}
    </div>
  );
}

// ──────────────────────────────────────────────────────────────
// Minimal safe Markdown renderer (no raw HTML)
// Supports: paragraphs, line breaks, lists, headings, code fences,
// inline code, **bold**, *italic*, [text](url), autolink urls
// ──────────────────────────────────────────────────────────────

type MdNode =
  | { t: "p"; inl: InlineNode[] }
  | { t: "h"; level: 1 | 2 | 3; inl: InlineNode[] }
  | { t: "ul"; items: InlineNode[][] }
  | { t: "ol"; items: InlineNode[][] }
  | { t: "codeblock"; code: string };

type InlineNode =
  | { t: "text"; s: string }
  | { t: "strong"; c: InlineNode[] }
  | { t: "em"; c: InlineNode[] }
  | { t: "code"; s: string }
  | { t: "link"; href: string; c: InlineNode[] };

function parseInline(s: string): InlineNode[] {
  const out: InlineNode[] = [];
  let i = 0;
  const pushText = (txt: string) => {
    if (!txt) return;
    out.push({ t: "text", s: txt });
  };

  while (i < s.length) {
    if (s[i] === "`") {
      const j = s.indexOf("`", i + 1);
      if (j > i + 1) {
        pushText(s.slice(0, i));
        out.push({ t: "code", s: s.slice(i + 1, j) });
        s = s.slice(j + 1);
        i = 0;
        continue;
      }
    }

    if (s[i] === "[") {
      const close = s.indexOf("]", i + 1);
      if (close > i + 1 && s[close + 1] === "(") {
        const endParen = s.indexOf(")", close + 2);
        if (endParen > close + 2) {
          const label = s.slice(i + 1, close);
          const urlRaw = s.slice(close + 2, endParen);
          const href = normalizeUrl(urlRaw) ?? urlRaw;
          pushText(s.slice(0, i));
          out.push({ t: "link", href, c: parseInline(label) });
          s = s.slice(endParen + 1);
          i = 0;
          continue;
        }
      }
    }

    if (s[i] === "*" && s[i + 1] === "*") {
      const j = s.indexOf("**", i + 2);
      if (j > i + 2) {
        const inner = s.slice(i + 2, j);
        pushText(s.slice(0, i));
        out.push({ t: "strong", c: parseInline(inner) });
        s = s.slice(j + 2);
        i = 0;
        continue;
      }
    }

    if (s[i] === "*") {
      const j = s.indexOf("*", i + 1);
      if (j > i + 1) {
        const inner = s.slice(i + 1, j);
        pushText(s.slice(0, i));
        out.push({ t: "em", c: parseInline(inner) });
        s = s.slice(j + 1);
        i = 0;
        continue;
      }
    }

    i++;
  }

  pushText(s);
  return out;
}

function parseMarkdown(md: string): MdNode[] {
  const lines = (md ?? "").replace(/\r\n/g, "\n").split("\n");
  const nodes: MdNode[] = [];
  let i = 0;

  const flushParagraph = (buf: string[]) => {
    const text = buf.join("\n").trimEnd();
    if (!text.trim()) return;
    nodes.push({ t: "p", inl: parseInline(text) });
  };

  while (i < lines.length) {
    const line = lines[i];

    if (line.trimStart().startsWith("```")) {
      const buf: string[] = [];
      i++;
      while (i < lines.length && !lines[i].trimStart().startsWith("```")) {
        buf.push(lines[i]);
        i++;
      }
      if (i < lines.length) i++;
      nodes.push({ t: "codeblock", code: buf.join("\n") });
      continue;
    }

    const hm = /^(#{1,3})\s+(.*)$/.exec(line.trim());
    if (hm) {
      const level = Math.min(3, hm[1].length) as 1 | 2 | 3;
      nodes.push({ t: "h", level, inl: parseInline(hm[2] ?? "") });
      i++;
      continue;
    }

    if (/^\s*[-*]\s+/.test(line)) {
      const items: InlineNode[][] = [];
      while (i < lines.length && /^\s*[-*]\s+/.test(lines[i])) {
        const itemText = lines[i].replace(/^\s*[-*]\s+/, "");
        items.push(parseInline(itemText));
        i++;
      }
      nodes.push({ t: "ul", items });
      continue;
    }

    if (/^\s*\d+\.\s+/.test(line)) {
      const items: InlineNode[][] = [];
      while (i < lines.length && /^\s*\d+\.\s+/.test(lines[i])) {
        const itemText = lines[i].replace(/^\s*\d+\.\s+/, "");
        items.push(parseInline(itemText));
        i++;
      }
      nodes.push({ t: "ol", items });
      continue;
    }

    if (!line.trim()) {
      i++;
      continue;
    }

    const pbuf: string[] = [];
    while (
      i < lines.length &&
      lines[i].trim() &&
      !lines[i].trimStart().startsWith("```") &&
      !/^(#{1,3})\s+/.test(lines[i].trim()) &&
      !/^\s*[-*]\s+/.test(lines[i]) &&
      !/^\s*\d+\.\s+/.test(lines[i])
    ) {
      pbuf.push(lines[i]);
      i++;
    }
    flushParagraph(pbuf);
  }

  return nodes;
}

function renderInline(nodes: InlineNode[], keyPrefix: string, inLink = false) {
  const out: React.ReactNode[] = [];
  for (let i = 0; i < nodes.length; i++) {
    const n = nodes[i];
    const k = `${keyPrefix}_${i}`;

    if (n.t === "text") {
      if (!inLink) {
        const parts = n.s.split(/(https?:\/\/[^\s)>\]]+|www\.[^\s)>\]]+)/g);
        for (let pi = 0; pi < parts.length; pi++) {
          const p = parts[pi];
          const maybe = normalizeUrl(p);
          if (maybe) {
            out.push(
              <a
                key={`${k}_u_${pi}`}
                href={maybe}
                target="_blank"
                rel="noopener noreferrer"
                style={{
                  color: "var(--roam-accent)",
                  textDecoration: "underline",
                  textUnderlineOffset: 2,
                }}
                onClick={(e) => e.stopPropagation()}
              >
                {p}
              </a>,
            );
          } else {
            out.push(<span key={`${k}_t_${pi}`}>{p}</span>);
          }
        }
      } else {
        out.push(<span key={k}>{n.s}</span>);
      }
      continue;
    }

    if (n.t === "code") {
      out.push(
        <code
          key={k}
          style={{
            fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace",
            fontSize: "0.92em",
            background: "rgba(0,0,0,0.06)",
            padding: "2px 6px",
            borderRadius: 8,
          }}
        >
          {n.s}
        </code>,
      );
      continue;
    }

    if (n.t === "strong") {
      out.push(
        <strong key={k} style={{ fontWeight: 950 }}>
          {renderInline(n.c, k, inLink)}
        </strong>,
      );
      continue;
    }

    if (n.t === "em") {
      out.push(
        <em key={k} style={{ fontStyle: "italic" }}>
          {renderInline(n.c, k, inLink)}
        </em>,
      );
      continue;
    }

    if (n.t === "link") {
      const href = normalizeUrl(n.href) ?? n.href;
      out.push(
        <a
          key={k}
          href={href}
          target="_blank"
          rel="noopener noreferrer"
          style={{
            color: "var(--roam-accent)",
            textDecoration: "underline",
            textUnderlineOffset: 2,
          }}
          onClick={(e) => e.stopPropagation()}
        >
          {renderInline(n.c, k, true)}
        </a>,
      );
      continue;
    }
  }
  return out;
}

function MarkdownBody({ text }: { text: string }) {
  const nodes = useMemo(() => parseMarkdown(text ?? ""), [text]);

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
      {nodes.map((n, idx) => {
        const k = `md_${idx}`;

        if (n.t === "codeblock") {
          return (
            <pre
              key={k}
              style={{
                margin: 0,
                padding: "10px 12px",
                borderRadius: 14,
                background: "rgba(0,0,0,0.06)",
                overflowX: "auto",
                WebkitOverflowScrolling: "touch",
                fontSize: 12.5,
                lineHeight: 1.35,
              }}
            >
              <code style={{ fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace" }}>
                {n.code}
              </code>
            </pre>
          );
        }

        if (n.t === "h") {
          const size = n.level === 1 ? 15 : n.level === 2 ? 14 : 13;
          return (
            <div
              key={k}
              style={{
                fontSize: size,
                fontWeight: 950,
                color: "var(--roam-text)",
                marginTop: n.level === 1 ? 2 : 0,
              }}
            >
              {renderInline(n.inl, k)}
            </div>
          );
        }

        if (n.t === "ul" || n.t === "ol") {
          const ListTag = n.t === "ul" ? "ul" : "ol";
          return (
            <ListTag
              key={k}
              style={{
                margin: 0,
                paddingLeft: 18,
                color: "var(--roam-text)",
                fontWeight: 850,
                lineHeight: 1.35,
              }}
            >
              {n.items.map((it, ii) => (
                <li key={`${k}_li_${ii}`} style={{ margin: "4px 0px" }}>
                  {renderInline(it, `${k}_li_${ii}`)}
                </li>
              ))}
            </ListTag>
          );
        }

        return (
          <div
            key={k}
            style={{
              color: "var(--roam-text)",
              fontWeight: 850,
              lineHeight: 1.35,
              whiteSpace: "pre-wrap",
            }}
          >
            {renderInline(n.inl, k)}
          </div>
        );
      })}
    </div>
  );
}

// ──────────────────────────────────────────────────────────────
// Extra badges — show rich metadata from the new extra fields
// ──────────────────────────────────────────────────────────────

function ExtraBadges({ place }: { place: PlaceItem }) {
  const extra: any = place.extra ?? {};
  const badges: { label: string; accent?: boolean }[] = [];

  // Free camp
  if (extra.free) badges.push({ label: "Free", accent: true });
  // Powered sites
  if (extra.powered_sites) badges.push({ label: "Powered" });
  // Has water
  if (extra.has_water) badges.push({ label: "Water" });
  // Has toilets
  if (extra.has_toilets) badges.push({ label: "Toilets" });
  // Fuel types
  if (extra.fuel_types && Array.isArray(extra.fuel_types)) {
    const fuels = extra.fuel_types as string[];
    if (fuels.includes("diesel")) badges.push({ label: "Diesel" });
    if (fuels.includes("lpg")) badges.push({ label: "LPG" });
    if (fuels.includes("adblue")) badges.push({ label: "AdBlue" });
  }
  // EV socket types
  if (extra.socket_types && Array.isArray(extra.socket_types)) {
    const sockets = extra.socket_types as string[];
    const display = sockets.slice(0, 2).map((s: string) => s.replace(/_/g, " ")).join(", ");
    if (display) badges.push({ label: display });
  }
  // Opening hours (short)
  if (extra.opening_hours) {
    const hrs = String(extra.opening_hours);
    if (hrs.length <= 20) badges.push({ label: hrs });
  }

  if (badges.length === 0) return null;

  return (
    <div style={{ display: "flex", gap: 4, flexWrap: "wrap", marginTop: 4 }}>
      {badges.map((b, i) => (
        <span
          key={i}
          style={{
            fontSize: 10,
            fontWeight: 950,
            padding: "2px 7px",
            borderRadius: 6,
            background: b.accent ? "rgba(0,180,100,0.12)" : "rgba(0,0,0,0.05)",
            color: b.accent ? "rgba(0,140,70,1)" : "var(--roam-text-muted)",
            whiteSpace: "nowrap",
          }}
        >
          {b.label}
        </span>
      ))}
    </div>
  );
}

// ──────────────────────────────────────────────────────────────
// Place card
// ──────────────────────────────────────────────────────────────

function PlaceCard({
  place,
  isFocused,
  onFocus,
  onAdd,
  onShowOnMap,
  isOnline,
}: {
  place: PlaceItem | DiscoveredPlace;
  isFocused: boolean;
  onFocus: () => void;
  onAdd: () => void;
  onShowOnMap?: () => void;
  isOnline: boolean;
}) {
  const extra: any = place.extra ?? {};
  const suburb = extra["addr:suburb"] || extra["addr:city"] || extra.address;
  const phone = extra.phone as string | undefined;
  const website = extra.website as string | undefined;

  const CatIcon = CATEGORY_ICON[place.category] ?? MapPin;
  const dist = fmtDist((place as DiscoveredPlace).distance_from_user_km);

  function handleCardClick(e: MouseEvent<HTMLDivElement>) {
    const t = e.target as HTMLElement | null;
    if (!t) return onFocus();
    if (t.closest("button,a,input,textarea,select,[role='button']")) return;
    onFocus();
  }

  const stop = (e: SyntheticEvent) => e.stopPropagation();

  return (
    <div
      onClick={handleCardClick}
      className="trip-interactive"
      style={{
        display: "flex",
        flexDirection: "column",
        gap: 8,
        padding: "12px 14px",
        borderRadius: 20,
        cursor: "pointer",
        background: isFocused ? "var(--roam-surface-hover)" : "var(--roam-surface)",
        boxShadow: isFocused ? "var(--shadow-heavy)" : "var(--shadow-soft)",
        outline: isFocused ? "3px solid var(--brand-sky)" : "3px solid transparent",
        outlineOffset: -3,
      }}
    >
      <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
        <div
          style={{
            width: 36,
            height: 36,
            borderRadius: 10,
            background: "var(--roam-surface-hover)",
            display: "grid",
            placeItems: "center",
            flexShrink: 0,
          }}
        >
          <CatIcon size={18} />
        </div>

        <div style={{ minWidth: 0, flex: 1 }}>
          <div
            style={{ fontSize: 15, fontWeight: 950, color: "var(--roam-text)" }}
            className="trip-truncate"
          >
            {place.name}
          </div>
          <div
            style={{
              fontSize: 12,
              color: "var(--roam-text-muted)",
              marginTop: 2,
              fontWeight: 850,
              display: "flex",
              gap: 6,
              flexWrap: "wrap",
            }}
          >
            <span>{fmtCategory(place.category)}</span>
            {suburb ? <span>· {typeof suburb === "string" ? suburb.split(",")[0] : suburb}</span> : null}
            {dist ? <span>· {dist}</span> : null}
          </div>

          <ExtraBadges place={place} />
        </div>
      </div>

      <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
        <button
          type="button"
          onPointerDown={stop}
          onTouchStart={stop}
          onClick={(e) => {
            stop(e);
            haptic.medium();
            onAdd();
          }}
          className="trip-btn-sm trip-interactive"
          style={{
            borderRadius: 12,
            minHeight: 38,
            padding: "0 12px",
            fontWeight: 950,
            fontSize: 13,
            background: "var(--roam-accent)",
            color: "white",
            boxShadow: "var(--shadow-button)",
          }}
        >
          + Add
        </button>

        {onShowOnMap ? (
          <button
            type="button"
            onPointerDown={stop}
            onTouchStart={stop}
            onClick={(e) => {
              stop(e);
              haptic.selection();
              onFocus();
              onShowOnMap?.();
            }}
            className="trip-btn-sm trip-interactive"
            style={{
              borderRadius: 12,
              minHeight: 38,
              padding: "0 12px",
              fontWeight: 950,
              fontSize: 13,
              background: "var(--roam-surface-hover)",
              color: "var(--roam-text)",
              boxShadow: "var(--shadow-button)",
            }}
          >
            Map
          </button>
        ) : null}

        {phone ? (
          <a
            href={`tel:${phone}`}
            onPointerDown={stop}
            onTouchStart={stop}
            onClick={stop}
            className="trip-btn-sm trip-interactive"
            style={{
              textDecoration: "none",
              display: "inline-flex",
              alignItems: "center",
              justifyContent: "center",
              borderRadius: 12,
              minHeight: 38,
              padding: "0 12px",
              fontWeight: 950,
              fontSize: 13,
              background: "var(--roam-surface-hover)",
              color: "var(--roam-text)",
              boxShadow: "var(--shadow-button)",
              gap: 6,
            }}
          >
            <Phone size={14} />
            Call
          </a>
        ) : null}

        {isOnline && website ? (
          <button
            type="button"
            onPointerDown={stop}
            onTouchStart={stop}
            onClick={(e) => {
              stop(e);
              haptic.selection();
              const norm = normalizeUrl(String(website));
              if (norm) safeOpen(norm);
            }}
            className="trip-btn-sm trip-interactive"
            style={{
              borderRadius: 12,
              minHeight: 38,
              padding: "0 12px",
              fontWeight: 950,
              fontSize: 13,
              background: "var(--roam-surface-hover)",
              color: "var(--roam-text)",
              boxShadow: "var(--shadow-button)",
              display: "inline-flex",
              alignItems: "center",
              gap: 6,
            }}
          >
            <Globe size={14} />
            Web
          </button>
        ) : null}
      </div>
    </div>
  );
}

// ──────────────────────────────────────────────────────────────
// Discovery group
// ──────────────────────────────────────────────────────────────

function DiscoveryGroup({
  category,
  places,
  focusedPlaceId,
  onFocusPlace,
  onAddStop,
  onShowOnMap,
  isOnline,
}: {
  category: string;
  places: DiscoveredPlace[];
  focusedPlaceId: string | null;
  onFocusPlace: (id: string | null) => void;
  onAddStop: (place: PlaceItem) => void;
  onShowOnMap?: (placeId: string) => void;
  isOnline: boolean;
}) {
  const Icon = CATEGORY_ICON[category] ?? MapPin;
  const label = fmtCategory(category);

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
      <div style={{ display: "flex", alignItems: "center", gap: 8, padding: "4px 0" }}>
        <Icon size={16} />
        <span style={{ fontSize: 14, fontWeight: 950, color: "var(--roam-text)" }}>{label}</span>
        <span
          style={{
            fontSize: 12,
            fontWeight: 900,
            color: "var(--roam-text-muted)",
            background: "var(--roam-surface-hover)",
            borderRadius: 999,
            padding: "2px 8px",
          }}
        >
          {places.length}
        </span>
      </div>

      {places.slice(0, 8).map((p) => (
        <PlaceCard
          key={p.id}
          place={p}
          isFocused={focusedPlaceId === p.id}
          onFocus={() => onFocusPlace(p.id)}
          onAdd={() => onAddStop(p)}
          onShowOnMap={onShowOnMap ? () => onShowOnMap(p.id) : undefined}
          isOnline={isOnline}
        />
      ))}

      {places.length > 8 ? (
        <div
          style={{
            textAlign: "center",
            fontSize: 12,
            fontWeight: 900,
            color: "var(--roam-text-muted)",
            padding: 8,
          }}
        >
          +{places.length - 8} more {label.toLowerCase()}
        </div>
      ) : null}
    </div>
  );
}

// ──────────────────────────────────────────────────────────────
// Main Component
// ──────────────────────────────────────────────────────────────

export function GuideView({
  places,
  focusedPlaceId,
  onFocusPlace,
  onAddStop,
  isOnline = true,
  onShowOnMap,
  guideReady = false,
  guidePack,
  tripProgress,
  onSendMessage,
  chatBusy = false,
}: {
  places: PlacesPack | null;
  focusedPlaceId: string | null;
  onFocusPlace: (id: string | null) => void;
  onAddStop: (place: PlaceItem) => void;
  isOnline?: boolean;
  onShowOnMap?: (placeId: string) => void;
  guideReady?: boolean;
  guidePack?: GuidePack | null;
  tripProgress?: TripProgress | null;
  onSendMessage?: (text: string, preferredCategories: string[]) => Promise<string | undefined>;
  chatBusy?: boolean;
}) {
  const [chatInput, setChatInput] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [chip, setChip] = useState<ChipKey>("all");
  const [activeTab, setActiveTab] = useState<ViewTab>("chat");

  const chatEndRef = useRef<HTMLDivElement>(null);

  const thread = guidePack?.thread ?? [];
  const prevThreadLen = useRef(thread.length);
  useEffect(() => {
    if (thread.length > prevThreadLen.current) {
      setTimeout(
        () => chatEndRef.current?.scrollIntoView({ behavior: "smooth", block: "end" }),
        80,
      );
    }
    prevThreadLen.current = thread.length;
  }, [thread.length]);

  const discoveredPlaces = guidePack?.discovered_places ?? [];

  // ── Discovered places grouped by category ──────────────────
  const discoveryGroups = useMemo(() => {
    const groups: Record<string, DiscoveredPlace[]> = {};
    for (const p of discoveredPlaces) {
      const cat = p.category ?? "town";
      if (!groups[cat]) groups[cat] = [];
      groups[cat].push(p);
    }

    for (const cat of Object.keys(groups)) {
      groups[cat].sort(
        (a, b) => (a.distance_from_user_km ?? 9999) - (b.distance_from_user_km ?? 9999),
      );
    }

    // Priority order: safety → food → sleep → nature → culture → supplies
    const priorityOrder = [
      "fuel", "ev_charging", "rest_area", "water", "toilet", "dump_point",
      "hospital", "pharmacy", "mechanic",
      "bakery", "cafe", "restaurant", "fast_food", "pub", "bar",
      "camp", "motel", "hotel", "hostel",
      "grocery", "town", "atm", "laundromat",
      "viewpoint", "waterfall", "swimming_hole", "beach",
      "national_park", "hiking", "picnic", "hot_spring",
      "playground", "pool", "zoo", "theme_park",
      "visitor_info", "winery", "brewery", "museum", "gallery",
      "heritage", "attraction", "market", "park",
    ];

    const cats = Object.keys(groups).sort((a, b) => {
      const ai = priorityOrder.indexOf(a);
      const bi = priorityOrder.indexOf(b);
      const aN = ai >= 0 ? ai : 999;
      const bN = bi >= 0 ? bi : 999;
      return aN - bN;
    });

    return cats.map((cat) => ({ category: cat, places: groups[cat] }));
  }, [discoveredPlaces]);

  // ── Browse: filter corridor places ─────────────────────────
  const browseItems = useMemo(() => {
    const items = places?.items ?? [];
    const q = searchQuery.trim().toLowerCase();
    let list = items;
    if (chip !== "all") list = list.filter((p) => p.category === chip);
    if (q) list = list.filter((p) => (p.name ?? "").toLowerCase().includes(q));
    return list.slice(0, 140);
  }, [places, searchQuery, chip]);

  // ── Quick suggestions — context-aware based on trip phase ──
  const quickSuggestions = useMemo(() => {
    const suggestions: { label: string; query: string; Icon: LucideIcon }[] = [];

    if (tripProgress && tripProgress.total_km > 0) {
      const kmRemaining = tripProgress.km_remaining;
      const kmDone = tripProgress.km_from_start;
      const hour = new Date().getHours();

      // Always useful
      suggestions.push({
        label: "Next fuel",
        query: "Where's the next fuel stop ahead?",
        Icon: Fuel,
      });

      // Time-based
      if (hour >= 5 && hour < 9) {
        suggestions.push({
          label: "Coffee",
          query: "Any good cafes or bakeries ahead for a morning coffee?",
          Icon: Coffee,
        });
      } else if (hour >= 11 && hour < 14) {
        suggestions.push({
          label: "Lunch",
          query: "Where's a good spot to stop for lunch?",
          Icon: Utensils,
        });
      } else if (hour >= 16 && hour < 20) {
        suggestions.push({
          label: "Tonight",
          query: "Where should I stay tonight? Show me camps and motels ahead.",
          Icon: Bed,
        });
      } else if (hour >= 20 || hour < 5) {
        suggestions.push({
          label: "Stop now",
          query: "I need to stop for the night. What's the closest safe option?",
          Icon: Tent,
        });
      }

      // Distance-based
      if (kmDone > 150) {
        suggestions.push({
          label: "Rest area",
          query: "Where's the next rest area? Need a break.",
          Icon: ParkingMeter,
        });
      }
      if (kmRemaining > 200) {
        suggestions.push({
          label: "Highlights",
          query: "What are the best stops and things to see in the next 100km?",
          Icon: Camera,
        });
      }
      if (kmRemaining < 80 && kmRemaining > 5) {
        suggestions.push({
          label: "Near destination",
          query: "What's worth seeing near my destination?",
          Icon: Target,
        });
      }

      // Nature/discovery
      suggestions.push({
        label: "Scenic",
        query: "Any scenic lookouts, waterfalls, or swimming holes ahead?",
        Icon: Eye,
      });
      suggestions.push({
        label: "Water",
        query: "Where can I fill up drinking water ahead?",
        Icon: Droplets,
      });
    } else {
      // Planning phase — no live position
      suggestions.push({
        label: "Fuel stops",
        query: "Where can I refuel along this route?",
        Icon: Fuel,
      });
      suggestions.push({
        label: "Camps",
        query: "Find camping spots along my route",
        Icon: Tent,
      });
      suggestions.push({
        label: "Scenic",
        query: "What's worth seeing along this route?",
        Icon: Camera,
      });
      suggestions.push({
        label: "Towns",
        query: "What towns will I pass through?",
        Icon: Building2,
      });
      suggestions.push({
        label: "Food",
        query: "Where are good bakeries and cafes along the route?",
        Icon: Coffee,
      });
    }

    return suggestions.slice(0, 6);
  }, [tripProgress]);

  // ── Send handler ───────────────────────────────────────────
  async function handleAsk(text?: string) {
    const msg = (text ?? chatInput).trim();
    if (!msg) return;

    haptic.medium();
    setChatInput("");
    setActiveTab("chat");

    if (!guideReady || !onSendMessage) return;

    const preferred: string[] = chip !== "all" ? [chip] : [];

    try {
      await onSendMessage(msg, preferred);
    } catch {
      // error handled by page
    }
  }

  function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    handleAsk();
  }

  // ── Render ─────────────────────────────────────────────────

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 14 }}>
      {/* ── Tab switcher ────────────────────────────────────── */}
      <div
        style={{
          display: "flex",
          gap: 6,
          background: "var(--roam-surface)",
          borderRadius: 16,
          padding: 4,
          boxShadow: "var(--shadow-soft)",
        }}
      >
        {(
          [
            { key: "chat" as ViewTab, label: "Guide", badge: null },
            {
              key: "discoveries" as ViewTab,
              label: "Found",
              badge: discoveredPlaces.length > 0 ? discoveredPlaces.length : null,
            },
            { key: "browse" as ViewTab, label: "Browse", badge: null },
          ] as const
        ).map((tab) => {
          const active = activeTab === tab.key;
          return (
            <button
              key={tab.key}
              type="button"
              className="trip-interactive"
              onClick={() => {
                haptic.selection();
                setActiveTab(tab.key);
              }}
              style={{
                flex: 1,
                borderRadius: 12,
                border: "none",
                padding: "10px 8px",
                fontSize: 13,
                fontWeight: 950,
                background: active ? "var(--roam-surface-hover)" : "transparent",
                color: active ? "var(--roam-text)" : "var(--roam-text-muted)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 6,
                cursor: "pointer",
              }}
            >
              {tab.label}
              {tab.badge != null ? (
                <span
                  style={{
                    fontSize: 11,
                    fontWeight: 950,
                    background: "var(--roam-accent)",
                    color: "white",
                    borderRadius: 999,
                    padding: "1px 6px",
                    minWidth: 20,
                    textAlign: "center",
                  }}
                >
                  {tab.badge}
                </span>
              ) : null}
            </button>
          );
        })}
      </div>

      {/* ════════════════════════════════════════════════════════
          TAB: CHAT (Guide)
          ════════════════════════════════════════════════════════ */}
      {activeTab === "chat" ? (
        <div
          style={{
            background: "var(--roam-surface)",
            padding: 14,
            borderRadius: 20,
            boxShadow: "var(--shadow-soft)",
            display: "flex",
            flexDirection: "column",
            gap: 10,
          }}
        >
          {/* Header */}
          <div
            style={{
              display: "flex",
              alignItems: "baseline",
              justifyContent: "space-between",
              gap: 10,
            }}
          >
            <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
              <div
                style={{
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 8,
                  fontSize: 14,
                  fontWeight: 950,
                  color: "var(--roam-text)",
                }}
              >
                <Sparkles size={16} />
                Ask Roam
              </div>
              {!guideReady ? (
                <div style={{ fontSize: 12, fontWeight: 900, color: "var(--roam-text-muted)" }}>
                  Loading…
                </div>
              ) : null}
            </div>
            {chatBusy ? (
              <div style={{ fontSize: 12, fontWeight: 900, color: "var(--roam-text-muted)" }}>
                Thinking…
              </div>
            ) : null}
          </div>

          {/* Quick suggestions — shown when chat is empty */}
          {thread.length === 0 ? (
            <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
              {quickSuggestions.map((s, i) => {
                const SI = s.Icon;
                return (
                  <button
                    key={i}
                    type="button"
                    className="trip-interactive"
                    onClick={() => handleAsk(s.query)}
                    disabled={!guideReady || chatBusy}
                    style={{
                      borderRadius: 999,
                      border: "none",
                      padding: "8px 12px",
                      fontSize: 13,
                      fontWeight: 900,
                      background: "var(--roam-surface-hover)",
                      color: "var(--roam-text)",
                      cursor: "pointer",
                      opacity: !guideReady || chatBusy ? 0.5 : 1,
                      whiteSpace: "nowrap",
                      display: "flex",
                      alignItems: "center",
                      gap: 8,
                    }}
                  >
                    <SI size={16} />
                    {s.label}
                  </button>
                );
              })}
            </div>
          ) : null}

          {/* Thread */}
          {thread.length > 0 ? (
            <div
              style={{
                display: "flex",
                flexDirection: "column",
                gap: 10,
                maxHeight: 400,
                overflowY: "auto",
                paddingRight: 4,
                WebkitOverflowScrolling: "touch",
                overscrollBehavior: "contain",
              }}
            >
              {thread.slice(-20).map((m, idx) => {
                const mine = m.role === "user";
                const bubbleBg = mine
                  ? "var(--roam-surface-hover)"
                  : "rgba(0,0,0,0.04)";
                const bubbleRadius = mine
                  ? "16px 16px 4px 16px"
                  : "16px 16px 16px 4px";

                return (
                  <div key={`${m.role}_${idx}`}>
                    <div
                      style={{
                        alignSelf: mine ? "flex-end" : "flex-start",
                        marginLeft: mine ? "auto" : 0,
                        marginRight: mine ? 0 : "auto",
                        maxWidth: "92%",
                        padding: "10px 14px",
                        borderRadius: bubbleRadius,
                        background: bubbleBg,
                        color: "var(--roam-text)",
                        fontSize: 14,
                        fontWeight: 850,
                        lineHeight: 1.35,
                      }}
                    >
                      {!mine ? (
                        <div
                          style={{
                            fontSize: 11,
                            fontWeight: 950,
                            color: "var(--roam-text-muted)",
                            marginBottom: 6,
                            display: "flex",
                            alignItems: "center",
                            gap: 5,
                          }}
                        >
                          <Sparkles size={12} />
                          Roam Guide
                        </div>
                      ) : null}

                      <MarkdownBody text={m.content ?? ""} />

                      {/* Actions: structured from backend → fallback from markdown */}
                      {!mine ? (
                        <MessageActionsRow msg={m} isOnline={!!isOnline} />
                      ) : null}
                    </div>

                    {/* Discovery CTA after tool resolution */}
                    {!mine && m.resolved_tool_id && discoveredPlaces.length > 0 ? (
                      <button
                        type="button"
                        className="trip-interactive"
                        onClick={() => {
                          haptic.selection();
                          setActiveTab("discoveries");
                        }}
                        style={{
                          marginTop: 6,
                          padding: "6px 12px",
                          borderRadius: 12,
                          border: "none",
                          background: "rgba(0,150,255,0.08)",
                          color: "var(--roam-accent)",
                          fontSize: 12,
                          fontWeight: 950,
                          cursor: "pointer",
                          display: "inline-flex",
                          alignItems: "center",
                          gap: 8,
                        }}
                      >
                        <MapPin size={14} />
                        View {discoveredPlaces.length} places
                        <span aria-hidden="true">→</span>
                      </button>
                    ) : null}
                  </div>
                );
              })}

              {chatBusy ? (
                <div
                  style={{
                    alignSelf: "flex-start",
                    maxWidth: "60%",
                    padding: "10px 14px",
                    borderRadius: "16px 16px 16px 4px",
                    background: "rgba(0,0,0,0.04)",
                    color: "var(--roam-text-muted)",
                    fontSize: 14,
                    fontWeight: 850,
                  }}
                >
                  <span style={{ animation: "pulse 1.5s ease-in-out infinite" }}>
                    Searching…
                  </span>
                </div>
              ) : null}

              <div ref={chatEndRef} />
            </div>
          ) : thread.length === 0 && quickSuggestions.length === 0 ? (
            <div
              style={{
                color: "var(--roam-text-muted)",
                fontSize: 13,
                fontWeight: 850,
              }}
            >
              Ask about fuel, camps, food, scenic stops — anything along your route.
            </div>
          ) : null}

          {/* Input */}
          <form
            onSubmit={handleSubmit}
            style={{ display: "flex", gap: 10, marginTop: 4 }}
          >
            <input
              type="text"
              value={chatInput}
              onChange={(e) => setChatInput(e.target.value)}
              placeholder="Ask about your route…"
              className="trip-interactive"
              style={{
                flex: 1,
                padding: "12px 14px",
                borderRadius: 999,
                border: "none",
                outline: "none",
                fontSize: 14,
                fontWeight: 850,
                background: "var(--roam-surface-hover)",
                color: "var(--roam-text)",
                boxShadow: "inset 0 0 0 2px rgba(0,0,0,0.04)",
              }}
            />
            <button
              type="submit"
              className="trip-btn trip-btn-primary trip-interactive"
              disabled={!guideReady || chatBusy}
              style={{
                width: "auto",
                borderRadius: 999,
                padding: "0 16px",
                minHeight: 46,
                fontWeight: 950,
                opacity: !guideReady || chatBusy ? 0.6 : 1,
              }}
            >
              Ask
            </button>
          </form>
        </div>
      ) : null}

      {/* ════════════════════════════════════════════════════════
          TAB: DISCOVERIES
          ════════════════════════════════════════════════════════ */}
      {activeTab === "discoveries" ? (
        <div style={{ display: "flex", flexDirection: "column", gap: 14 }}>
          {discoveredPlaces.length === 0 ? (
            <div
              style={{
                background: "var(--roam-surface)",
                borderRadius: 20,
                padding: 32,
                textAlign: "center",
                boxShadow: "var(--shadow-soft)",
              }}
            >
              <div
                style={{ display: "grid", placeItems: "center", marginBottom: 10 }}
              >
                <Search size={22} />
              </div>
              <div
                style={{
                  fontSize: 15,
                  fontWeight: 950,
                  color: "var(--roam-text)",
                }}
              >
                No discoveries yet
              </div>
              <div
                style={{
                  fontSize: 13,
                  fontWeight: 850,
                  color: "var(--roam-text-muted)",
                  marginTop: 8,
                }}
              >
                Ask the Guide about fuel, camps, food, or scenic stops to discover
                places along your route.
              </div>
              <button
                type="button"
                className="trip-interactive"
                onClick={() => {
                  haptic.selection();
                  setActiveTab("chat");
                }}
                style={{
                  marginTop: 16,
                  borderRadius: 999,
                  border: "none",
                  padding: "10px 18px",
                  fontSize: 14,
                  fontWeight: 950,
                  background: "var(--roam-accent)",
                  color: "white",
                  cursor: "pointer",
                  display: "inline-flex",
                  alignItems: "center",
                  gap: 10,
                }}
              >
                <Sparkles size={16} />
                Ask the Guide
              </button>
            </div>
          ) : (
            <>
              <div
                style={{
                  background: "var(--roam-surface)",
                  borderRadius: 20,
                  padding: "14px 16px",
                  boxShadow: "var(--shadow-soft)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                }}
              >
                <div>
                  <div
                    style={{
                      fontSize: 15,
                      fontWeight: 950,
                      color: "var(--roam-text)",
                    }}
                  >
                    {discoveredPlaces.length} places found
                  </div>
                  <div
                    style={{
                      fontSize: 12,
                      fontWeight: 850,
                      color: "var(--roam-text-muted)",
                      marginTop: 2,
                    }}
                  >
                    {discoveryGroups.length} categories · nearest first
                  </div>
                </div>
                <button
                  type="button"
                  className="trip-interactive"
                  onClick={() => {
                    haptic.selection();
                    setActiveTab("chat");
                  }}
                  style={{
                    borderRadius: 999,
                    border: "none",
                    padding: "8px 14px",
                    fontSize: 13,
                    fontWeight: 950,
                    background: "var(--roam-surface-hover)",
                    color: "var(--roam-text)",
                    cursor: "pointer",
                    display: "inline-flex",
                    alignItems: "center",
                    gap: 8,
                  }}
                >
                  <Sparkles size={16} />
                  Ask more
                </button>
              </div>

              {discoveryGroups.map((g) => (
                <DiscoveryGroup
                  key={g.category}
                  category={g.category}
                  places={g.places}
                  focusedPlaceId={focusedPlaceId}
                  onFocusPlace={onFocusPlace}
                  onAddStop={onAddStop}
                  onShowOnMap={onShowOnMap}
                  isOnline={isOnline}
                />
              ))}
            </>
          )}
        </div>
      ) : null}

      {/* ════════════════════════════════════════════════════════
          TAB: BROWSE
          ════════════════════════════════════════════════════════ */}
      {activeTab === "browse" ? (
        <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search places…"
            className="trip-interactive"
            style={{
              padding: "12px 14px",
              borderRadius: 16,
              border: "none",
              outline: "none",
              background: "var(--roam-surface)",
              color: "var(--roam-text)",
              fontSize: 14,
              fontWeight: 850,
              boxShadow: "var(--shadow-soft)",
            }}
          />

          <div
            style={{
              display: "flex",
              gap: 8,
              overflowX: "auto",
              paddingBottom: 4,
              WebkitOverflowScrolling: "touch",
            }}
          >
            {CHIPS.map((c) => {
              const active = chip === c.key;
              const CI = c.Icon;
              return (
                <button
                  key={c.key}
                  type="button"
                  className="trip-interactive"
                  onClick={() => {
                    haptic.selection();
                    setChip(c.key);
                  }}
                  style={{
                    flex: "0 0 auto",
                    borderRadius: 999,
                    border: "none",
                    padding: "8px 12px",
                    fontSize: 13,
                    fontWeight: 950,
                    background: active
                      ? "var(--roam-surface-hover)"
                      : "var(--roam-surface)",
                    color: active ? "var(--roam-text)" : "var(--roam-text-muted)",
                    boxShadow: active
                      ? "var(--shadow-button)"
                      : "var(--shadow-soft)",
                    display: "flex",
                    gap: 8,
                    alignItems: "center",
                    cursor: "pointer",
                  }}
                >
                  <CI size={16} />
                  {c.label}
                </button>
              );
            })}
          </div>

          {browseItems.length === 0 ? (
            <div
              style={{
                padding: 18,
                textAlign: "center",
                color: "var(--roam-text-muted)",
                fontSize: 14,
                fontWeight: 850,
                background: "var(--roam-surface)",
                borderRadius: 20,
                boxShadow: "var(--shadow-soft)",
              }}
            >
              No places found
              {chip !== "all" ? ` for "${fmtCategory(chip)}"` : ""}.
            </div>
          ) : (
            browseItems.map((p) => (
              <PlaceCard
                key={p.id}
                place={p}
                isFocused={focusedPlaceId === p.id}
                onFocus={() => onFocusPlace(p.id)}
                onAdd={() => onAddStop(p)}
                onShowOnMap={onShowOnMap ? () => onShowOnMap(p.id) : undefined}
                isOnline={isOnline}
              />
            ))
          )}
        </div>
      ) : null}
    </div>
  );
}

===== src/components/trip/TripAlertsPanel.tsx =====

// src/components/trip/TripAlertsPanel.tsx
"use client";

import { useMemo, useState, useCallback, useRef, useEffect } from "react";
import type {
  TrafficOverlay,
  HazardOverlay,
  TrafficEvent,
  HazardEvent,
  TrafficSeverity,
  TrafficType,
  HazardSeverity,
  HazardKind,
} from "@/lib/types/navigation";
import type { RoamPosition } from "@/lib/native/geolocation";
import { haptic } from "@/lib/native/haptics";

import {
  CircleX,
  Droplets,
  Car,
  Construction,
  TriangleAlert,
  Siren,
  CircleHelp,
  CloudRain,
  Tornado,
  CloudLightning,
  Flame,
  Wind,
  Thermometer,
  Waves,
  Zap,
  ShieldCheck,
  ChevronDown,
  MapPin,
  Eye,
  EyeOff,
  Clock,
  XCircle,
  OctagonAlert,
  RefreshCw,
  ArrowRight,
  ShieldAlert,
  Route,
  Ban,
} from "lucide-react";

/* ══════════════════════════════════════════════════════════════════════
   Types
   ══════════════════════════════════════════════════════════════════════ */

export type RouteImpact = "blocks_route" | "affects_route" | "nearby" | "informational";

export type AlertHighlightEvent = {
  id: string;
  kind: "traffic" | "hazard";
  lat: number;
  lng: number;
};

export type EnrichedAlert = {
  id: string;
  alertKind: "traffic" | "hazard";
  headline: string;
  description?: string | null;
  iconKey: string;
  severity: string;
  sevOrder: number;
  sevColor: string;
  sevBg: string;
  sevLabel: string;
  typeLabel: string;
  source?: string | null;
  timestamp?: string | null;
  coord: { lat: number; lng: number } | null;
  distFromUserKm: number | null;
  kmAlongRoute: number | null;
  distFromRouteKm: number | null;
  contextLabel: string;
  relevanceScore: number;
  // ── BETTER_NAV additions ──
  routeImpact: RouteImpact;
  isAhead: boolean;
  /** Original raw geometry for intersection tests */
  rawGeometry?: any;
};

/* ══════════════════════════════════════════════════════════════════════
   Config — severity palettes
   ══════════════════════════════════════════════════════════════════════ */

const T_SEV: Record<TrafficSeverity, { color: string; bg: string; label: string; order: number }> = {
  major:    { color: "#ef4444", bg: "rgba(239,68,68,0.12)",   label: "Major",    order: 0 },
  moderate: { color: "#f59e0b", bg: "rgba(245,158,11,0.10)",  label: "Moderate", order: 1 },
  minor:    { color: "#3b82f6", bg: "rgba(59,130,246,0.10)",  label: "Minor",    order: 2 },
  info:     { color: "#64748b", bg: "rgba(100,116,139,0.08)", label: "Info",     order: 3 },
  unknown:  { color: "#64748b", bg: "rgba(100,116,139,0.08)", label: "Unknown",  order: 4 },
};

const H_SEV: Record<HazardSeverity, { color: string; bg: string; label: string; order: number }> = {
  high:    { color: "#dc2626", bg: "rgba(220,38,38,0.12)",   label: "High",    order: 0 },
  medium:  { color: "#ea580c", bg: "rgba(234,88,12,0.10)",   label: "Medium",  order: 1 },
  low:     { color: "#2563eb", bg: "rgba(37,99,235,0.10)",   label: "Low",     order: 2 },
  unknown: { color: "#64748b", bg: "rgba(100,116,139,0.08)", label: "Unknown", order: 3 },
};

/* ══════════════════════════════════════════════════════════════════════
   Route impact palettes
   ══════════════════════════════════════════════════════════════════════ */

const IMPACT_CONFIG: Record<RouteImpact, { label: string; color: string; bg: string; order: number }> = {
  blocks_route:  { label: "Route blocked", color: "#dc2626", bg: "rgba(220,38,38,0.14)", order: 0 },
  affects_route: { label: "On route",      color: "#ea580c", bg: "rgba(234,88,12,0.12)", order: 1 },
  nearby:        { label: "Nearby",        color: "#f59e0b", bg: "rgba(245,158,11,0.10)", order: 2 },
  informational: { label: "In region",     color: "#64748b", bg: "rgba(100,116,139,0.06)", order: 3 },
};

/* ══════════════════════════════════════════════════════════════════════
   Icon keys (used for both map SVG + React Lucide rendering)
   ══════════════════════════════════════════════════════════════════════ */

const T_ICON_KEYS: Record<TrafficType, string> = {
  closure: "closure", flooding: "flooding", congestion: "congestion",
  roadworks: "roadworks", hazard: "hazard", incident: "incident", unknown: "unknown",
};

const H_ICON_KEYS: Record<HazardKind, string> = {
  flood: "flood", cyclone: "cyclone", storm: "storm", fire: "fire",
  wind: "wind", heat: "heat", marine: "marine", weather_warning: "weather_warning", unknown: "h_unknown",
};

/* ── Lucide icon map for React rendering ──────────────────────────── */

const LUCIDE_ICONS: Record<string, React.ComponentType<{ size?: number; strokeWidth?: number; color?: string }>> = {
  closure: CircleX,
  flooding: Droplets,
  congestion: Car,
  roadworks: Construction,
  hazard: TriangleAlert,
  incident: Siren,
  unknown: CircleHelp,
  flood: CloudRain,
  cyclone: Tornado,
  storm: CloudLightning,
  fire: Flame,
  wind: Wind,
  heat: Thermometer,
  marine: Waves,
  weather_warning: Zap,
  h_unknown: TriangleAlert,
};

const ICON_COLORS: Record<string, string> = {
  closure: "#ef4444",
  flooding: "#3b82f6",
  congestion: "#f59e0b",
  roadworks: "#f97316",
  hazard: "#eab308",
  incident: "#ef4444",
  unknown: "#64748b",
  flood: "#3b82f6",
  cyclone: "#7c3aed",
  storm: "#6366f1",
  fire: "#ef4444",
  wind: "#64748b",
  heat: "#ea580c",
  marine: "#0ea5e9",
  weather_warning: "#eab308",
  h_unknown: "#64748b",
};

function AlertIcon({ iconKey, size = 16 }: { iconKey: string; size?: number }) {
  const Comp = LUCIDE_ICONS[iconKey] ?? TriangleAlert;
  const color = ICON_COLORS[iconKey] ?? "#64748b";
  return <Comp size={size} strokeWidth={2.2} color={color} />;
}

/* ══════════════════════════════════════════════════════════════════════
   Geo helpers
   ══════════════════════════════════════════════════════════════════════ */

function decodePolyline6(poly: string): Array<[number, number]> {
  let index = 0, lat = 0, lng = 0;
  const out: Array<[number, number]> = [];
  while (index < poly.length) {
    let r = 0, s = 0, b: number;
    do { b = poly.charCodeAt(index++) - 63; r |= (b & 0x1f) << s; s += 5; } while (b >= 0x20);
    lat += r & 1 ? ~(r >> 1) : r >> 1;
    r = 0; s = 0;
    do { b = poly.charCodeAt(index++) - 63; r |= (b & 0x1f) << s; s += 5; } while (b >= 0x20);
    lng += r & 1 ? ~(r >> 1) : r >> 1;
    out.push([lng / 1e6, lat / 1e6]);
  }
  return out;
}

const D2R = Math.PI / 180;
function haversineKm(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const dLat = (lat2 - lat1) * D2R, dLng = (lng2 - lng1) * D2R;
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * D2R) * Math.cos(lat2 * D2R) * Math.sin(dLng / 2) ** 2;
  return 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function projectOntoRoute(lat: number, lng: number, rc: Array<[number, number]>): { kmAlong: number; distKm: number } {
  let best = Infinity, bestKm = 0, cum = 0;
  for (let i = 0; i < rc.length - 1; i++) {
    const [aLng, aLat] = rc[i], [bLng, bLat] = rc[i + 1];
    const seg = haversineKm(aLat, aLng, bLat, bLng);
    const dx = bLng - aLng, dy = bLat - aLat, len2 = dx * dx + dy * dy;
    let t = 0;
    if (len2 > 0) t = Math.max(0, Math.min(1, ((lng - aLng) * dx + (lat - aLat) * dy) / len2));
    const d = haversineKm(lat, lng, aLat + t * dy, aLng + t * dx);
    if (d < best) { best = d; bestKm = cum + t * seg; }
    cum += seg;
  }
  return { kmAlong: bestKm, distKm: best };
}

export function extractCoord(geo: any, bbox: number[] | null | undefined): { lat: number; lng: number } | null {
  if (geo) {
    if (geo.type === "Point" && Array.isArray(geo.coordinates)) return { lng: geo.coordinates[0], lat: geo.coordinates[1] };
    if (geo.type === "LineString" && geo.coordinates?.length > 0) {
      const mid = geo.coordinates[Math.floor(geo.coordinates.length / 2)];
      return Array.isArray(mid) ? { lng: mid[0], lat: mid[1] } : null;
    }
    if ((geo.type === "Polygon" || geo.type === "MultiPolygon") && geo.coordinates) {
      const ring = geo.type === "Polygon" ? geo.coordinates[0] : geo.coordinates[0]?.[0];
      if (Array.isArray(ring) && ring.length) {
        let sLng = 0, sLat = 0;
        for (const c of ring) { sLng += c[0]; sLat += c[1]; }
        return { lng: sLng / ring.length, lat: sLat / ring.length };
      }
    }
  }
  if (bbox && bbox.length === 4) return { lng: (bbox[0] + bbox[2]) / 2, lat: (bbox[1] + bbox[3]) / 2 };
  return null;
}

/* ══════════════════════════════════════════════════════════════════════
   Route Impact Classification — BETTER_NAV #2

   Tests whether alert geometry actually intersects the route polyline
   buffer.  This is the core safety feature — distinguishing "closure
   ON your road" from "closure 2km away on a different road."
   ══════════════════════════════════════════════════════════════════════ */

/** Types that indicate a physical road blockage */
const BLOCKING_TRAFFIC_TYPES = new Set<string>(["closure", "flooding"]);
const BLOCKING_HAZARD_KINDS = new Set<string>(["flood", "fire", "cyclone"]);

/**
 * Extracts ALL coordinates from any GeoJSON geometry for intersection
 * testing.  Returns array of [lng, lat] pairs.
 */
function extractAllCoords(geo: any): Array<[number, number]> {
  if (!geo) return [];
  switch (geo.type) {
    case "Point":
      return [geo.coordinates as [number, number]];
    case "MultiPoint":
    case "LineString":
      return (geo.coordinates ?? []) as Array<[number, number]>;
    case "MultiLineString":
    case "Polygon":
      return ((geo.coordinates ?? []) as Array<Array<[number, number]>>).flat();
    case "MultiPolygon":
      return ((geo.coordinates ?? []) as Array<Array<Array<[number, number]>>>).flat(2);
    default:
      return [];
  }
}

/**
 * Tests if ANY point of an alert's geometry is within the route buffer.
 * Returns the minimum distance in km.
 *
 * For performance on long routes (2000+ km), we subsample the route
 * polyline — checking every Nth vertex — and early-exit when we find
 * something close enough.
 */
function minDistanceToRoute(
  alertCoords: Array<[number, number]>,
  routeCoords: Array<[number, number]>,
): number {
  if (alertCoords.length === 0 || routeCoords.length === 0) return Infinity;

  // Subsample route to ~500 check-points max
  const step = Math.max(1, Math.floor(routeCoords.length / 500));
  let minDist = Infinity;

  for (const [aLng, aLat] of alertCoords) {
    for (let i = 0; i < routeCoords.length - 1; i += step) {
      const [rLng, rLat] = routeCoords[i];
      const d = haversineKm(aLat, aLng, rLat, rLng);
      if (d < minDist) minDist = d;
      // Early exit — anything within 100m is definitely on-route
      if (minDist < 0.1) return minDist;
    }
    // Always check the last point
    const [lastLng, lastLat] = routeCoords[routeCoords.length - 1];
    const dLast = haversineKm(aLat, aLng, lastLat, lastLng);
    if (dLast < minDist) minDist = dLast;
  }

  return minDist;
}

/**
 * Classify how an alert impacts the route.
 *
 * - geometry within 0.5km AND blocking type  → blocks_route
 * - geometry within 0.5km, non-blocking      → affects_route
 * - geometry within 2km AND blocking type     → affects_route (safety margin)
 * - centroid within 5km                       → nearby
 * - everything else                           → informational
 */
function classifyRouteImpact(
  alertKind: "traffic" | "hazard",
  alertType: string,
  alertGeometry: any,
  alertBbox: number[] | null | undefined,
  routeCoords: Array<[number, number]>,
  distFromRouteKm: number | null,
): RouteImpact {
  if (!routeCoords || routeCoords.length < 2) return "informational";

  const alertCoords = extractAllCoords(alertGeometry);
  let closestKm: number;

  if (alertCoords.length > 0) {
    closestKm = minDistanceToRoute(alertCoords, routeCoords);
  } else if (distFromRouteKm != null) {
    closestKm = distFromRouteKm;
  } else {
    return "informational";
  }

  const isBlockingType = alertKind === "traffic"
    ? BLOCKING_TRAFFIC_TYPES.has(alertType)
    : BLOCKING_HAZARD_KINDS.has(alertType);

  if (closestKm <= 0.5) {
    return isBlockingType ? "blocks_route" : "affects_route";
  }
  if (closestKm <= 2.0 && isBlockingType) {
    return "affects_route";
  }
  if (closestKm <= 5.0) {
    return "nearby";
  }
  return "informational";
}

/* ══════════════════════════════════════════════════════════════════════
   Cross-Overlay Deduplication — BETTER_NAV #8b

   Same real-world event can appear as both a TrafficEvent (type
   "flooding") and a HazardEvent (kind "flood") from different sources.
   Merge by proximity — if two alerts of related types are within 2km,
   keep the higher-severity one.
   ══════════════════════════════════════════════════════════════════════ */

const RELATED_PAIRS = new Map<string, Set<string>>([
  ["flooding", new Set(["flood"])],
  ["flood", new Set(["flooding"])],
  ["closure", new Set(["fire", "flood", "cyclone"])],
  ["fire", new Set(["closure", "hazard"])],
  ["hazard", new Set(["fire", "weather_warning", "storm", "wind"])],
  ["storm", new Set(["hazard", "weather_warning"])],
  ["weather_warning", new Set(["hazard", "storm"])],
]);

function isRelatedType(typeA: string, typeB: string): boolean {
  return RELATED_PAIRS.get(typeA)?.has(typeB) ?? false;
}

function deduplicateAlerts(alerts: EnrichedAlert[]): EnrichedAlert[] {
  const removed = new Set<string>();
  const sorted = [...alerts].sort((a, b) => a.sevOrder - b.sevOrder);

  for (let i = 0; i < sorted.length; i++) {
    if (removed.has(sorted[i].id)) continue;
    const a = sorted[i];
    if (!a.coord) continue;

    for (let j = i + 1; j < sorted.length; j++) {
      if (removed.has(sorted[j].id)) continue;
      const b = sorted[j];
      if (!b.coord) continue;

      // Same source type, very close — duplicate feed entry
      if (a.alertKind === b.alertKind && a.typeLabel === b.typeLabel) {
        const d = haversineKm(a.coord.lat, a.coord.lng, b.coord.lat, b.coord.lng);
        if (d < 1.0) { removed.add(b.id); continue; }
      }

      // Cross-overlay: related types within 2km
      const tA = a.typeLabel.replace(/ /g, "_");
      const tB = b.typeLabel.replace(/ /g, "_");
      if (isRelatedType(tA, tB)) {
        const d = haversineKm(a.coord.lat, a.coord.lng, b.coord.lat, b.coord.lng);
        if (d < 2.0) { removed.add(b.id); }
      }
    }
  }

  return alerts.filter((a) => !removed.has(a.id));
}

/* ══════════════════════════════════════════════════════════════════════
   Enrichment engine — PROXIMITY-FIRST scoring + route impact
   ══════════════════════════════════════════════════════════════════════ */

function fmtKm(km: number): string {
  if (km < 1) return `${Math.round(km * 1000)} m`;
  if (km < 10) return `${km.toFixed(1)} km`;
  return `${Math.round(km)} km`;
}

function buildContextLabel(
  userKm: number | null,
  alertKm: number | null,
  userDist: number | null,
  routeDist: number | null,
  impact: RouteImpact,
): string {
  const parts: string[] = [];

  if (impact === "blocks_route") parts.push("⛔ Route blocked");
  else if (impact === "affects_route") parts.push("⚠️ On route");

  if (routeDist != null && routeDist > 25) parts.push(`${Math.round(routeDist)} km off-route`);

  if (userKm != null && alertKm != null) {
    const d = alertKm - userKm;
    if (Math.abs(d) < 2) { if (parts.length === 0) parts.push("Right here"); }
    else if (d > 0) parts.push(`${fmtKm(Math.abs(d))} ahead`);
    else parts.push(`${fmtKm(Math.abs(d))} behind`);
  } else if (userDist != null) {
    parts.push(`${fmtKm(userDist)} away`);
  }
  return parts.join(" · ");
}

/**
 * PROXIMITY-FIRST relevance scoring with route impact weighting.
 *
 * Route-blocking alerts get a massive priority bonus (−500) to ensure
 * they ALWAYS surface at the top regardless of distance.
 */
function relevanceScore(
  sevOrder: number,
  userDist: number | null,
  routeDist: number | null,
  ahead: number | null,
  impact: RouteImpact,
): number {
  let s = 0;

  // Route impact is the DOMINANT factor
  s += IMPACT_CONFIG[impact].order * 200;

  if (impact === "blocks_route") s -= 500;
  else if (impact === "affects_route") s -= 200;

  if (userDist != null) s += userDist * 10;
  else s += 500;

  s += sevOrder * 15;
  if (ahead != null && ahead > 0) s -= 30;
  if (routeDist != null && routeDist > 10) s += routeDist * 5;

  return s;
}

function timeAgo(iso: string | null | undefined): string {
  if (!iso) return "";
  try {
    const diff = Date.now() - new Date(iso).getTime();
    const m = Math.floor(diff / 60000);
    if (m < 1) return "just now";
    if (m < 60) return `${m}m ago`;
    const h = Math.floor(m / 60);
    if (h < 24) return `${h}h ago`;
    return `${Math.floor(h / 24)}d ago`;
  } catch { return ""; }
}

export function enrichAlerts(
  traffic: TrafficOverlay | null,
  hazards: HazardOverlay | null,
  routeGeometry: string | null | undefined,
  userPosition: RoamPosition | null | undefined,
): EnrichedAlert[] {
  const rc = routeGeometry ? (() => { try { return decodePolyline6(routeGeometry); } catch { return null; } })() : null;

  let userKm: number | null = null;
  if (userPosition && rc && rc.length >= 2) {
    const proj = projectOntoRoute(userPosition.lat, userPosition.lng, rc);
    userKm = proj.distKm < 50 ? proj.kmAlong : null;
  }

  const out: EnrichedAlert[] = [];

  for (const ev of traffic?.items ?? []) {
    const coord = extractCoord(ev.geometry, ev.bbox);
    let dUser: number | null = null, kmAlong: number | null = null, dRoute: number | null = null;
    if (coord) {
      if (userPosition) dUser = haversineKm(userPosition.lat, userPosition.lng, coord.lat, coord.lng);
      if (rc && rc.length >= 2) { const p = projectOntoRoute(coord.lat, coord.lng, rc); kmAlong = p.kmAlong; dRoute = p.distKm; }
    }
    const sev = T_SEV[ev.severity ?? "unknown"];
    const ahead = userKm != null && kmAlong != null ? kmAlong - userKm : null;
    const isAhead = ahead != null ? ahead > -2 : true;

    const impact = classifyRouteImpact("traffic", ev.type ?? "unknown", ev.geometry, ev.bbox, rc ?? [], dRoute);

    out.push({
      id: ev.id, alertKind: "traffic", headline: ev.headline, description: ev.description,
      iconKey: T_ICON_KEYS[ev.type ?? "unknown"], severity: ev.severity ?? "unknown",
      sevOrder: sev.order, sevColor: sev.color, sevBg: sev.bg, sevLabel: sev.label,
      typeLabel: (ev.type ?? "unknown").replace("_", " "),
      source: ev.source, timestamp: ev.last_updated,
      coord, distFromUserKm: dUser, kmAlongRoute: kmAlong, distFromRouteKm: dRoute,
      contextLabel: buildContextLabel(userKm, kmAlong, dUser, dRoute, impact),
      relevanceScore: relevanceScore(sev.order, dUser, dRoute, ahead, impact),
      routeImpact: impact,
      isAhead,
      rawGeometry: ev.geometry,
    });
  }

  for (const ev of hazards?.items ?? []) {
    const coord = extractCoord(ev.geometry, ev.bbox);
    let dUser: number | null = null, kmAlong: number | null = null, dRoute: number | null = null;
    if (coord) {
      if (userPosition) dUser = haversineKm(userPosition.lat, userPosition.lng, coord.lat, coord.lng);
      if (rc && rc.length >= 2) { const p = projectOntoRoute(coord.lat, coord.lng, rc); kmAlong = p.kmAlong; dRoute = p.distKm; }
    }
    const sev = H_SEV[ev.severity ?? "unknown"];
    const ahead = userKm != null && kmAlong != null ? kmAlong - userKm : null;
    const isAhead = ahead != null ? ahead > -2 : true;

    const impact = classifyRouteImpact("hazard", ev.kind ?? "unknown", ev.geometry, ev.bbox, rc ?? [], dRoute);

    out.push({
      id: ev.id, alertKind: "hazard", headline: ev.title, description: ev.description,
      iconKey: H_ICON_KEYS[ev.kind ?? "unknown"], severity: ev.severity ?? "unknown",
      sevOrder: sev.order, sevColor: sev.color, sevBg: sev.bg, sevLabel: sev.label,
      typeLabel: (ev.kind ?? "unknown").replace("_", " "),
      source: ev.source, timestamp: ev.issued_at,
      coord, distFromUserKm: dUser, kmAlongRoute: kmAlong, distFromRouteKm: dRoute,
      contextLabel: buildContextLabel(userKm, kmAlong, dUser, dRoute, impact),
      relevanceScore: relevanceScore(sev.order, dUser, dRoute, ahead, impact),
      routeImpact: impact,
      isAhead,
      rawGeometry: ev.geometry,
    });
  }

  return out.sort((a, b) => a.relevanceScore - b.relevanceScore);
}

/* ══════════════════════════════════════════════════════════════════════
   Staleness helpers — BETTER_NAV #4
   ══════════════════════════════════════════════════════════════════════ */

type FreshnessLevel = "fresh" | "stale" | "expired";

function overlayStaleness(createdAt: string | null | undefined): {
  level: FreshnessLevel;
  label: string;
  color: string;
  minutesAgo: number;
} {
  if (!createdAt) return { level: "expired", label: "No data", color: "#64748b", minutesAgo: Infinity };
  try {
    const diff = Date.now() - new Date(createdAt).getTime();
    const mins = Math.floor(diff / 60000);
    if (mins < 5) return { level: "fresh", label: `Updated ${mins < 1 ? "just now" : `${mins}m ago`}`, color: "#22c55e", minutesAgo: mins };
    if (mins < 30) return { level: "fresh", label: `Updated ${mins}m ago`, color: "#22c55e", minutesAgo: mins };
    if (mins < 180) return { level: "stale", label: `Updated ${Math.floor(mins / 60)}h ${mins % 60}m ago`, color: "#f59e0b", minutesAgo: mins };
    const hours = Math.floor(mins / 60);
    if (hours < 24) return { level: "stale", label: `Updated ${hours}h ago — connect to refresh`, color: "#ef4444", minutesAgo: mins };
    return { level: "expired", label: `Updated ${Math.floor(hours / 24)}d ago — data may be outdated`, color: "#ef4444", minutesAgo: mins };
  } catch {
    return { level: "expired", label: "Unknown age", color: "#64748b", minutesAgo: Infinity };
  }
}

/* ══════════════════════════════════════════════════════════════════════
   useAlerts hook — single source of truth for all alert consumers
   ══════════════════════════════════════════════════════════════════════ */

export function useAlerts(
  traffic: TrafficOverlay | null | undefined,
  hazards: HazardOverlay | null | undefined,
  routeGeometry: string | null | undefined,
  userPosition: RoamPosition | null | undefined,
  stops?: Array<{ lat: number; lng: number }>,
) {
  const rc = useMemo(() => {
    if (!routeGeometry) return null;
    try { return decodePolyline6(routeGeometry); } catch { return null; }
  }, [routeGeometry]);

  // ── Dismiss state — BETTER_NAV #8c ──
  const [dismissedIds, setDismissedIds] = useState<Set<string>>(new Set());
  const lastOverlayTimestampRef = useRef<string>("");

  // Reset dismissed state when overlay data actually changes
  useEffect(() => {
    const key = `${traffic?.created_at ?? ""}|${hazards?.created_at ?? ""}`;
    if (key !== lastOverlayTimestampRef.current) {
      lastOverlayTimestampRef.current = key;
      setDismissedIds(new Set());
    }
  }, [traffic?.created_at, hazards?.created_at]);

  const dismissAlert = useCallback((id: string) => {
    haptic.selection();
    setDismissedIds((prev) => new Set(prev).add(id));
  }, []);

  // ── Behind filter state — BETTER_NAV #8a ──
  const [hideBehind, setHideBehind] = useState(false);
  const toggleHideBehind = useCallback(() => {
    haptic.selection();
    setHideBehind((v) => !v);
  }, []);

  // ── Enrichment pipeline ──
  const rawAlerts = useMemo(
    () => enrichAlerts(traffic ?? null, hazards ?? null, routeGeometry, userPosition),
    [traffic, hazards, routeGeometry, userPosition],
  );

  const dedupedAlerts = useMemo(() => deduplicateAlerts(rawAlerts), [rawAlerts]);

  const all = useMemo(() => {
    let filtered = dedupedAlerts.filter((a) => !dismissedIds.has(a.id));
    if (hideBehind) filtered = filtered.filter((a) => a.isAhead);
    return filtered;
  }, [dedupedAlerts, dismissedIds, hideBehind]);

  const next = useMemo(() => {
    const upcoming = all.filter((a) => {
      if (!a.coord) return false;
      if (!a.isAhead) return false;
      if (a.distFromRouteKm != null && a.distFromRouteKm > 25) return false;
      return true;
    });
    return upcoming.length > 0 ? upcoming[0] : null;
  }, [all]);

  // Route-blocking alerts — always visible regardless of behind filter
  const routeBlockers = useMemo(
    () => dedupedAlerts.filter((a) => a.routeImpact === "blocks_route" && !dismissedIds.has(a.id)),
    [dedupedAlerts, dismissedIds],
  );

  const stopKmAlongs = useMemo(() => {
    if (!rc || rc.length < 2 || !stops) return null;
    return stops.map((s) => projectOntoRoute(s.lat, s.lng, rc).kmAlong);
  }, [rc, stops]);

  const alertsForLeg = useCallback(
    (fromIdx: number, toIdx: number): EnrichedAlert[] => {
      if (!stopKmAlongs) return [];
      const startKm = stopKmAlongs[fromIdx] ?? 0;
      const endKm = stopKmAlongs[toIdx] ?? Infinity;
      return all.filter((a) => {
        if (a.kmAlongRoute == null) return false;
        if (a.distFromRouteKm != null && a.distFromRouteKm > 25) return false;
        return a.kmAlongRoute >= startKm && a.kmAlongRoute <= endKm;
      });
    },
    [all, stopKmAlongs],
  );

  // ── Staleness — BETTER_NAV #4 ──
  const staleness = useMemo(() => {
    const trafficAge = overlayStaleness(traffic?.created_at);
    const hazardsAge = overlayStaleness(hazards?.created_at);
    const worst = trafficAge.minutesAgo > hazardsAge.minutesAgo ? trafficAge : hazardsAge;
    return { traffic: trafficAge, hazards: hazardsAge, worst };
  }, [traffic?.created_at, hazards?.created_at]);

  // ── Route assessment — BETTER_NAV #5 ──
  const assessment = useMemo(() => {
    const blockers = dedupedAlerts.filter((a) => a.routeImpact === "blocks_route");
    const onRoute = dedupedAlerts.filter((a) => a.routeImpact === "affects_route");
    const nearby = dedupedAlerts.filter((a) => a.routeImpact === "nearby");

    let status: "clear" | "caution" | "warning" | "blocked" = "clear";
    if (blockers.length > 0) status = "blocked";
    else if (onRoute.length > 0) status = "warning";
    else if (nearby.length > 0) status = "caution";

    return { status, blockerCount: blockers.length, onRouteCount: onRoute.length, nearbyCount: nearby.length, totalCount: dedupedAlerts.length, blockers, onRoute };
  }, [dedupedAlerts]);

  const highCount = all.filter((a) => a.sevOrder === 0).length;
  const totalCount = all.length;
  const behindCount = dedupedAlerts.filter((a) => !a.isAhead && !dismissedIds.has(a.id)).length;
  const dismissedCount = dismissedIds.size;

  return {
    all, next, routeBlockers, alertsForLeg,
    highCount, totalCount, staleness, assessment,
    hideBehind, toggleHideBehind, behindCount,
    dismissAlert, dismissedCount,
  };
}

/* ══════════════════════════════════════════════════════════════════════
   StalenessBar — BETTER_NAV #4
   ══════════════════════════════════════════════════════════════════════ */

export function StalenessBar({
  traffic,
  hazards,
}: {
  traffic: TrafficOverlay | null | undefined;
  hazards: HazardOverlay | null | undefined;
}) {
  const trafficAge = overlayStaleness(traffic?.created_at ?? null);
  const hazardsAge = overlayStaleness(hazards?.created_at ?? null);
  const worst = trafficAge.minutesAgo > hazardsAge.minutesAgo ? trafficAge : hazardsAge;

  if (worst.level === "fresh" && worst.minutesAgo < 5) return null;

  return (
    <div style={{
      display: "flex", alignItems: "center", gap: 6,
      padding: "5px 10px", borderRadius: 8,
      background: worst.level === "expired" ? "rgba(239,68,68,0.06)" : worst.level === "stale" ? "rgba(245,158,11,0.06)" : "transparent",
    }}>
      <Clock size={11} color={worst.color} strokeWidth={2.5} />
      <span style={{ fontSize: 10, fontWeight: 800, color: worst.color, letterSpacing: "0.15px" }}>
        {worst.label}
      </span>
      {worst.level !== "fresh" && (
        <RefreshCw size={10} color={worst.color} strokeWidth={2.5} style={{ marginLeft: "auto", opacity: 0.7 }} />
      )}
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   AlertFiltersBar — behind toggle + dismissed count
   BETTER_NAV #8a + #8c
   ══════════════════════════════════════════════════════════════════════ */

export function AlertFiltersBar({
  hideBehind,
  onToggleHideBehind,
  behindCount,
  dismissedCount,
}: {
  hideBehind: boolean;
  onToggleHideBehind: () => void;
  behindCount: number;
  dismissedCount: number;
}) {
  if (behindCount === 0 && dismissedCount === 0) return null;

  return (
    <div style={{ display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" }}>
      {behindCount > 0 && (
        <button
          type="button"
          onClick={onToggleHideBehind}
          style={{
            display: "flex", alignItems: "center", gap: 4,
            padding: "4px 10px", borderRadius: 8, border: "none",
            background: hideBehind ? "rgba(37,99,235,0.12)" : "var(--roam-surface-hover)",
            color: hideBehind ? "#2563eb" : "var(--roam-text-muted)",
            fontSize: 10, fontWeight: 900, cursor: "pointer",
            transition: "all 0.12s ease",
          }}
        >
          {hideBehind ? <EyeOff size={11} strokeWidth={2.5} /> : <Eye size={11} strokeWidth={2.5} />}
          {hideBehind ? `${behindCount} behind hidden` : `Hide ${behindCount} behind`}
        </button>
      )}
      {dismissedCount > 0 && (
        <span style={{
          fontSize: 10, fontWeight: 800, color: "var(--roam-text-muted)",
          padding: "4px 8px", borderRadius: 6, background: "var(--roam-surface-hover)",
        }}>
          {dismissedCount} dismissed
        </span>
      )}
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   RouteBlockedBanner — BETTER_NAV #2

   Full-width red banner when a closure/flood is detected ON the route.
   ══════════════════════════════════════════════════════════════════════ */

export function RouteBlockedBanner({
  blockers,
  onHighlight,
  onRebuildRequested,
}: {
  blockers: EnrichedAlert[];
  onHighlight?: (ev: AlertHighlightEvent) => void;
  onRebuildRequested?: () => void;
}) {
  if (blockers.length === 0) return null;

  const primary = blockers[0];
  const additionalCount = blockers.length - 1;

  return (
    <div
      onClick={() => {
        haptic.heavy();
        if (primary.coord && onHighlight) {
          onHighlight({ id: primary.id, kind: primary.alertKind, lat: primary.coord.lat, lng: primary.coord.lng });
        }
      }}
      style={{
        padding: "12px 14px", borderRadius: 16, cursor: "pointer",
        background: "linear-gradient(135deg, rgba(220,38,38,0.14) 0%, rgba(239,68,68,0.08) 100%)",
        border: "2px solid rgba(220,38,38,0.35)",
        boxShadow: "0 2px 12px rgba(220,38,38,0.15), inset 0 1px 0 rgba(255,255,255,0.05)",
        transition: "all 0.15s ease",
      }}
    >
      <div style={{ display: "flex", alignItems: "flex-start", gap: 10 }}>
        <div style={{
          width: 40, height: 40, borderRadius: 12,
          background: "rgba(220,38,38,0.18)", border: "2px solid rgba(220,38,38,0.3)",
          display: "grid", placeItems: "center", flexShrink: 0,
          animation: "roam-pulse-glow 2s ease-in-out infinite",
        }}>
          <Ban size={20} color="#dc2626" strokeWidth={2.5} />
        </div>

        <div style={{ flex: 1, minWidth: 0 }}>
          <div style={{ fontSize: 14, fontWeight: 950, color: "#dc2626", letterSpacing: "-0.2px", lineHeight: 1.2 }}>
            ⛔ Route blocked ahead
          </div>
          <div style={{ fontSize: 12, fontWeight: 700, color: "var(--roam-text)", marginTop: 3, lineHeight: 1.4 }}>
            {primary.headline}
          </div>
          <div style={{ fontSize: 10, fontWeight: 800, color: "var(--roam-text-muted)", marginTop: 4, display: "flex", alignItems: "center", gap: 6 }}>
            {primary.contextLabel && <span>{primary.contextLabel.replace(/⛔ Route blocked ?·? ?/g, "")}</span>}
            {primary.source && <span>· {primary.source}</span>}
            {primary.timestamp && <span>· {timeAgo(primary.timestamp)}</span>}
            {additionalCount > 0 && <span style={{ color: "#dc2626", fontWeight: 950 }}>+ {additionalCount} more</span>}
          </div>

          {onRebuildRequested && (
            <button
              type="button"
              onClick={(e) => { e.stopPropagation(); haptic.medium(); onRebuildRequested(); }}
              style={{
                marginTop: 8, padding: "7px 14px", borderRadius: 10,
                border: "none", cursor: "pointer",
                background: "#dc2626", color: "#fff",
                fontSize: 11, fontWeight: 950, letterSpacing: "0.2px",
                display: "flex", alignItems: "center", gap: 6,
                boxShadow: "0 2px 8px rgba(220,38,38,0.3)", transition: "opacity 0.1s",
              }}
            >
              <Route size={12} strokeWidth={2.5} />
              Find alternative route
            </button>
          )}
        </div>
      </div>

      <style>{`
        @keyframes roam-pulse-glow {
          0%, 100% { box-shadow: 0 0 0 0 rgba(220,38,38,0.3); }
          50% { box-shadow: 0 0 12px 4px rgba(220,38,38,0.2); }
        }
      `}</style>
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   RouteAssessment — BETTER_NAV #5

   Pre-departure summary shown in /new and /plans views.
   ══════════════════════════════════════════════════════════════════════ */

export function RouteAssessment({
  assessment,
  staleness,
  onHighlight,
}: {
  assessment: {
    status: "clear" | "caution" | "warning" | "blocked";
    blockerCount: number;
    onRouteCount: number;
    nearbyCount: number;
    totalCount: number;
    blockers: EnrichedAlert[];
    onRoute: EnrichedAlert[];
  };
  staleness: { worst: { level: FreshnessLevel; label: string; color: string } };
  onHighlight?: (ev: AlertHighlightEvent) => void;
}) {
  const statusConfig = {
    clear:   { icon: ShieldCheck, color: "#22c55e", bg: "rgba(34,197,94,0.08)",  border: "rgba(34,197,94,0.12)",  label: "Route clear",           description: "No alerts affecting your route" },
    caution: { icon: ShieldAlert, color: "#f59e0b", bg: "rgba(245,158,11,0.08)", border: "rgba(245,158,11,0.12)", label: "Proceed with caution",   description: `${assessment.nearbyCount} alert${assessment.nearbyCount !== 1 ? "s" : ""} near your route` },
    warning: { icon: TriangleAlert, color: "#ea580c", bg: "rgba(234,88,12,0.10)", border: "rgba(234,88,12,0.15)", label: "Alerts on route",         description: `${assessment.onRouteCount} alert${assessment.onRouteCount !== 1 ? "s" : ""} affecting your route` },
    blocked: { icon: OctagonAlert, color: "#dc2626", bg: "rgba(220,38,38,0.10)", border: "rgba(220,38,38,0.18)", label: "Route blocked",           description: `${assessment.blockerCount} closure${assessment.blockerCount !== 1 ? "s" : ""} blocking your route` },
  };

  const cfg = statusConfig[assessment.status];
  const Icon = cfg.icon;

  return (
    <div style={{ borderRadius: 16, overflow: "hidden", border: `1.5px solid ${cfg.border}`, background: cfg.bg }}>
      <div style={{ padding: "12px 14px", display: "flex", alignItems: "center", gap: 10 }}>
        <div style={{
          width: 36, height: 36, borderRadius: 11,
          background: `color-mix(in srgb, ${cfg.color} 15%, transparent)`,
          border: `1.5px solid color-mix(in srgb, ${cfg.color} 20%, transparent)`,
          display: "grid", placeItems: "center", flexShrink: 0,
        }}>
          <Icon size={18} color={cfg.color} strokeWidth={2.5} />
        </div>
        <div style={{ flex: 1 }}>
          <div style={{ fontSize: 14, fontWeight: 950, color: cfg.color, letterSpacing: "-0.2px" }}>{cfg.label}</div>
          <div style={{ fontSize: 11, fontWeight: 700, color: "var(--roam-text-muted)", marginTop: 1 }}>{cfg.description}</div>
        </div>
      </div>

      {assessment.totalCount > 0 && (
        <div style={{ padding: "0 14px 10px", display: "flex", gap: 6, flexWrap: "wrap" }}>
          {assessment.blockerCount > 0 && <span style={{ fontSize: 10, fontWeight: 950, color: "#dc2626", background: "rgba(220,38,38,0.10)", padding: "3px 8px", borderRadius: 6 }}>{assessment.blockerCount} blocking</span>}
          {assessment.onRouteCount > 0 && <span style={{ fontSize: 10, fontWeight: 950, color: "#ea580c", background: "rgba(234,88,12,0.10)", padding: "3px 8px", borderRadius: 6 }}>{assessment.onRouteCount} on route</span>}
          {assessment.nearbyCount > 0 && <span style={{ fontSize: 10, fontWeight: 950, color: "#f59e0b", background: "rgba(245,158,11,0.08)", padding: "3px 8px", borderRadius: 6 }}>{assessment.nearbyCount} nearby</span>}
        </div>
      )}

      {assessment.blockers.length > 0 && (
        <div style={{ padding: "0 14px 12px", display: "flex", flexDirection: "column", gap: 6 }}>
          {assessment.blockers.slice(0, 3).map((b) => (
            <div
              key={b.id}
              onClick={() => { haptic.selection(); if (b.coord && onHighlight) onHighlight({ id: b.id, kind: b.alertKind, lat: b.coord.lat, lng: b.coord.lng }); }}
              style={{
                padding: "6px 10px", borderRadius: 10, cursor: "pointer",
                background: "rgba(220,38,38,0.06)", border: "1px solid rgba(220,38,38,0.12)",
                display: "flex", alignItems: "center", gap: 8,
              }}
            >
              <Ban size={13} color="#dc2626" strokeWidth={2.5} />
              <div style={{ flex: 1, minWidth: 0 }}>
                <div style={{ fontSize: 11, fontWeight: 900, color: "var(--roam-text)", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{b.headline}</div>
                <div style={{ fontSize: 9, fontWeight: 700, color: "var(--roam-text-muted)", marginTop: 1 }}>
                  {b.contextLabel.replace(/⛔ Route blocked ?·? ?/g, "On route")}{b.source ? ` · ${b.source}` : ""}
                </div>
              </div>
              <ArrowRight size={12} color="var(--roam-text-muted)" />
            </div>
          ))}
        </div>
      )}

      {staleness.worst.level !== "fresh" && (
        <div style={{ padding: "6px 14px 10px", borderTop: "1px solid rgba(255,255,255,0.04)", display: "flex", alignItems: "center", gap: 5 }}>
          <Clock size={10} color={staleness.worst.color} strokeWidth={2.5} />
          <span style={{ fontSize: 9, fontWeight: 800, color: staleness.worst.color }}>{staleness.worst.label}</span>
        </div>
      )}
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   AlertCard — used in NextAlertBanner and LegAlertStrip
   Updated with route impact badge + dismiss button
   ══════════════════════════════════════════════════════════════════════ */

export function AlertCard({
  alert,
  compact = false,
  highlighted = false,
  onHighlight,
  onDismiss,
}: {
  alert: EnrichedAlert;
  compact?: boolean;
  highlighted?: boolean;
  onHighlight?: (ev: AlertHighlightEvent) => void;
  onDismiss?: (id: string) => void;
}) {
  const [expanded, setExpanded] = useState(false);

  const isBlocker = alert.routeImpact === "blocks_route";
  const impactCfg = IMPACT_CONFIG[alert.routeImpact];

  const handleTap = () => {
    haptic.selection();
    if (alert.coord && onHighlight) {
      onHighlight({ id: alert.id, kind: alert.alertKind, lat: alert.coord.lat, lng: alert.coord.lng });
    }
    if (alert.description) setExpanded((v) => !v);
  };

  const cardBg = isBlocker
    ? highlighted ? "rgba(220,38,38,0.18)" : "rgba(220,38,38,0.10)"
    : highlighted ? `color-mix(in srgb, ${alert.sevColor} 18%, var(--roam-surface))` : alert.sevBg;
  const cardBorder = isBlocker
    ? highlighted ? "#dc2626" : "rgba(220,38,38,0.25)"
    : highlighted ? alert.sevColor : `color-mix(in srgb, ${alert.sevColor} 18%, transparent)`;

  return (
    <div
      onClick={handleTap}
      style={{
        padding: compact ? "8px 10px" : "10px 14px",
        borderRadius: compact ? 12 : 14,
        background: cardBg,
        border: `1.5px solid ${cardBorder}`,
        cursor: "pointer", transition: "all 0.15s ease",
      }}
    >
      <div style={{ display: "flex", alignItems: "flex-start", gap: compact ? 8 : 10 }}>
        <div style={{
          width: compact ? 30 : 34, height: compact ? 30 : 34, borderRadius: compact ? 9 : 10,
          background: isBlocker ? "rgba(220,38,38,0.15)" : `color-mix(in srgb, ${alert.sevColor} 12%, var(--roam-surface))`,
          border: `1px solid ${isBlocker ? "rgba(220,38,38,0.20)" : `color-mix(in srgb, ${alert.sevColor} 15%, transparent)`}`,
          display: "grid", placeItems: "center", flexShrink: 0,
        }}>
          {isBlocker ? <Ban size={compact ? 14 : 16} color="#dc2626" strokeWidth={2.5} /> : <AlertIcon iconKey={alert.iconKey} size={compact ? 14 : 16} />}
        </div>

        <div style={{ flex: 1, minWidth: 0 }}>
          {alert.contextLabel && (
            <div style={{
              fontSize: compact ? 10 : 11, fontWeight: 950,
              color: isBlocker ? "#dc2626" : alert.sevColor,
              marginBottom: 2, letterSpacing: "0.15px",
            }}>
              {alert.contextLabel}
            </div>
          )}

          <div style={{ display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" }}>
            <span style={{
              fontSize: compact ? 12 : 13, fontWeight: 950, color: "var(--roam-text)",
              lineHeight: 1.3, overflow: "hidden", textOverflow: "ellipsis",
              whiteSpace: compact ? "nowrap" : undefined,
            }}>
              {alert.headline}
            </span>
            {!compact && (
              <>
                <span style={{
                  fontSize: 9, fontWeight: 950, color: alert.sevColor,
                  background: `color-mix(in srgb, ${alert.sevColor} 12%, transparent)`,
                  padding: "2px 6px", borderRadius: 6,
                  textTransform: "uppercase", letterSpacing: "0.5px", flexShrink: 0,
                }}>
                  {alert.sevLabel}
                </span>
                {(alert.routeImpact === "blocks_route" || alert.routeImpact === "affects_route") && (
                  <span style={{
                    fontSize: 9, fontWeight: 950, color: impactCfg.color,
                    background: impactCfg.bg, padding: "2px 6px", borderRadius: 6,
                    textTransform: "uppercase", letterSpacing: "0.5px", flexShrink: 0,
                  }}>
                    {impactCfg.label}
                  </span>
                )}
              </>
            )}
          </div>

          {!compact && (
            <div style={{ display: "flex", gap: 6, marginTop: 3, fontSize: 10, fontWeight: 700, color: "var(--roam-text-muted)" }}>
              {alert.typeLabel !== "unknown" && <span style={{ textTransform: "capitalize" }}>{alert.typeLabel}</span>}
              {alert.source && <span>· {alert.source}</span>}
              {alert.timestamp && <span>· {timeAgo(alert.timestamp)}</span>}
            </div>
          )}

          {expanded && alert.description && (
            <div style={{ marginTop: 6, fontSize: 12, fontWeight: 600, color: "var(--roam-text-muted)", lineHeight: 1.5 }}>
              {alert.description}
            </div>
          )}
        </div>

        <div style={{ display: "flex", flexDirection: "column", alignItems: "center", gap: 3, flexShrink: 0, paddingTop: 2 }}>
          {onDismiss && (
            <div
              onClick={(e) => { e.stopPropagation(); onDismiss(alert.id); }}
              style={{
                width: 18, height: 18, borderRadius: 9,
                background: "rgba(100,116,139,0.10)",
                display: "grid", placeItems: "center", cursor: "pointer",
                transition: "background 0.12s ease",
              }}
            >
              <XCircle size={11} color="var(--roam-text-muted)" strokeWidth={2} />
            </div>
          )}
          {alert.coord && !compact && (
            <div style={{
              width: 7, height: 7, borderRadius: 7,
              background: highlighted ? (isBlocker ? "#dc2626" : alert.sevColor) : `color-mix(in srgb, ${isBlocker ? "#dc2626" : alert.sevColor} 35%, transparent)`,
              transition: "background 0.2s ease",
              boxShadow: highlighted ? `0 0 6px ${isBlocker ? "#dc2626" : alert.sevColor}` : "none",
            }} />
          )}
          {alert.description && (
            <ChevronDown
              size={14}
              color="var(--roam-text-muted)"
              style={{ transform: expanded ? "rotate(180deg)" : "rotate(0deg)", transition: "transform 0.15s ease", marginTop: 2 }}
              onClick={(e) => { e.stopPropagation(); setExpanded((v) => !v); }}
            />
          )}
        </div>
      </div>
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   NextAlertBanner — persistent, always visible above tabs
   ══════════════════════════════════════════════════════════════════════ */

export function NextAlertBanner({
  next,
  totalCount,
  highCount,
  allAlerts,
  routeBlockers,
  highlighted,
  onHighlight,
  onDismiss,
  onRebuildRequested,
  staleness,
  hideBehind,
  onToggleHideBehind,
  behindCount,
  dismissedCount,
}: {
  next: EnrichedAlert | null;
  totalCount: number;
  highCount: number;
  allAlerts: EnrichedAlert[];
  routeBlockers?: EnrichedAlert[];
  highlighted?: string | null;
  onHighlight?: (ev: AlertHighlightEvent) => void;
  onDismiss?: (id: string) => void;
  onRebuildRequested?: () => void;
  staleness?: { worst: { level: FreshnessLevel; label: string; color: string } };
  hideBehind?: boolean;
  onToggleHideBehind?: () => void;
  behindCount?: number;
  dismissedCount?: number;
}) {
  const [showAll, setShowAll] = useState(false);
  const blockers = routeBlockers ?? [];

  if (totalCount === 0 && blockers.length === 0) {
    return (
      <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
        <div style={{
          padding: "10px 14px", borderRadius: 14,
          background: "rgba(34,197,94,0.08)", border: "1px solid rgba(34,197,94,0.12)",
          display: "flex", alignItems: "center", gap: 10,
        }}>
          <div style={{
            width: 30, height: 30, borderRadius: 10,
            background: "rgba(34,197,94,0.12)", border: "1px solid rgba(34,197,94,0.10)",
            display: "grid", placeItems: "center", flexShrink: 0,
          }}>
            <ShieldCheck size={15} color="#22c55e" strokeWidth={2.5} />
          </div>
          <div>
            <div style={{ fontSize: 13, fontWeight: 950, color: "var(--roam-text)" }}>Clear ahead</div>
            <div style={{ fontSize: 10, fontWeight: 700, color: "var(--roam-text-muted)", marginTop: 1 }}>No alerts on your route</div>
          </div>
        </div>
        {staleness && staleness.worst.level !== "fresh" && (
          <div style={{ display: "flex", alignItems: "center", gap: 5, paddingLeft: 4 }}>
            <Clock size={10} color={staleness.worst.color} strokeWidth={2.5} />
            <span style={{ fontSize: 9, fontWeight: 800, color: staleness.worst.color }}>{staleness.worst.label}</span>
          </div>
        )}
      </div>
    );
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
      {blockers.length > 0 && (
        <RouteBlockedBanner blockers={blockers} onHighlight={onHighlight} onRebuildRequested={onRebuildRequested} />
      )}

      {next && next.routeImpact !== "blocks_route" ? (
        <AlertCard alert={next} highlighted={highlighted === next.id} onHighlight={onHighlight} onDismiss={onDismiss} />
      ) : !next && blockers.length === 0 ? (
        <div style={{
          padding: "10px 14px", borderRadius: 14,
          background: highCount > 0 ? "rgba(239,68,68,0.08)" : "rgba(245,158,11,0.08)",
          border: `1px solid ${highCount > 0 ? "rgba(239,68,68,0.15)" : "rgba(245,158,11,0.15)"}`,
          display: "flex", alignItems: "center", gap: 10,
        }}>
          <div style={{
            width: 30, height: 30, borderRadius: 10,
            background: highCount > 0 ? "rgba(239,68,68,0.12)" : "rgba(245,158,11,0.10)",
            border: `1px solid ${highCount > 0 ? "rgba(239,68,68,0.10)" : "rgba(245,158,11,0.10)"}`,
            display: "grid", placeItems: "center", flexShrink: 0,
          }}>
            {highCount > 0 ? <Siren size={15} color="#ef4444" strokeWidth={2.5} /> : <TriangleAlert size={15} color="#f59e0b" strokeWidth={2.5} />}
          </div>
          <div style={{ flex: 1 }}>
            <div style={{ fontSize: 13, fontWeight: 950, color: "var(--roam-text)" }}>
              {totalCount} alert{totalCount !== 1 ? "s" : ""} on route
            </div>
            {highCount > 0 && <div style={{ fontSize: 10, fontWeight: 800, color: "#ef4444", marginTop: 1 }}>{highCount} critical</div>}
          </div>
        </div>
      ) : null}

      <AlertFiltersBar
        hideBehind={hideBehind ?? false}
        onToggleHideBehind={onToggleHideBehind ?? (() => {})}
        behindCount={behindCount ?? 0}
        dismissedCount={dismissedCount ?? 0}
      />

      {staleness && staleness.worst.level !== "fresh" && (
        <div style={{ display: "flex", alignItems: "center", gap: 5, paddingLeft: 4 }}>
          <Clock size={10} color={staleness.worst.color} strokeWidth={2.5} />
          <span style={{ fontSize: 9, fontWeight: 800, color: staleness.worst.color }}>{staleness.worst.label}</span>
        </div>
      )}

      {totalCount > 1 && (
        <button
          type="button"
          onClick={() => { haptic.selection(); setShowAll((v) => !v); }}
          style={{
            padding: "7px 12px", borderRadius: 10, border: "none",
            background: "var(--roam-surface-hover)", color: "var(--roam-text-muted)",
            fontSize: 11, fontWeight: 900, cursor: "pointer",
            display: "flex", alignItems: "center", justifyContent: "center", gap: 6,
            transition: "all 0.12s ease",
          }}
        >
          {showAll ? "Hide" : `See all ${totalCount} alerts`}
          <ChevronDown size={12} style={{ transform: showAll ? "rotate(180deg)" : "rotate(0deg)", transition: "transform 0.15s ease" }} />
        </button>
      )}

      {showAll && (
        <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
          {allAlerts
            .filter((a) => a.id !== next?.id && a.routeImpact !== "blocks_route")
            .map((a) => (
              <AlertCard key={a.id} alert={a} compact highlighted={highlighted === a.id} onHighlight={onHighlight} onDismiss={onDismiss} />
            ))}
        </div>
      )}
    </div>
  );
}

/* ══════════════════════════════════════════════════════════════════════
   LegAlertStrip — inline between stops in the route list
   ══════════════════════════════════════════════════════════════════════ */

export function LegAlertStrip({
  alerts,
  highlighted,
  onHighlight,
  onDismiss,
}: {
  alerts: EnrichedAlert[];
  highlighted?: string | null;
  onHighlight?: (ev: AlertHighlightEvent) => void;
  onDismiss?: (id: string) => void;
}) {
  const [expanded, setExpanded] = useState(false);

  if (alerts.length === 0) return null;

  const hasBlocker = alerts.some((a) => a.routeImpact === "blocks_route");
  const worst = alerts.reduce((a, b) => (a.sevOrder < b.sevOrder ? a : b));
  const displayColor = hasBlocker ? "#dc2626" : worst.sevColor;

  if (alerts.length === 1) {
    return (
      <div style={{ paddingLeft: 20, position: "relative" }}>
        <div style={{
          position: "absolute", left: 13, top: -4, bottom: -4, width: 2,
          background: `color-mix(in srgb, ${displayColor} 30%, transparent)`, borderRadius: 2,
        }} />
        <AlertCard alert={alerts[0]} compact highlighted={highlighted === alerts[0].id} onHighlight={onHighlight} onDismiss={onDismiss} />
      </div>
    );
  }

  return (
    <div style={{ paddingLeft: 20, position: "relative" }}>
      <div style={{
        position: "absolute", left: 13, top: -4, bottom: -4, width: 2,
        background: `color-mix(in srgb, ${displayColor} 30%, transparent)`, borderRadius: 2,
      }} />

      <div
        onClick={() => { haptic.selection(); setExpanded((v) => !v); }}
        style={{
          padding: "8px 12px", borderRadius: 11, cursor: "pointer",
          background: hasBlocker ? "rgba(220,38,38,0.10)" : worst.sevBg,
          border: `1.5px solid color-mix(in srgb, ${displayColor} 20%, transparent)`,
          display: "flex", alignItems: "center", gap: 8, transition: "all 0.12s ease",
        }}
      >
        {hasBlocker ? <Ban size={14} color="#dc2626" strokeWidth={2.5} /> : <AlertIcon iconKey={worst.iconKey} size={14} />}
        <span style={{ fontSize: 11, fontWeight: 950, color: displayColor, flex: 1 }}>
          {alerts.length} alerts on this stretch{hasBlocker && " — route blocked"}
        </span>
        <ChevronDown
          size={13}
          color="var(--roam-text-muted)"
          style={{ transform: expanded ? "rotate(180deg)" : "rotate(0deg)", transition: "transform 0.15s ease" }}
        />
      </div>

      {expanded && (
        <div style={{ display: "flex", flexDirection: "column", gap: 6, marginTop: 6 }}>
          {alerts.map((a) => (
            <AlertCard key={a.id} alert={a} compact highlighted={highlighted === a.id} onHighlight={onHighlight} onDismiss={onDismiss} />
          ))}
        </div>
      )}
    </div>
  );
}

===== src/components/trip/TripEditorSheet.tsx =====

// src/components/trip/TripEditorSheet.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import type { TripStop } from "@/lib/types/trip";
import type { NavPack, CorridorGraphPack } from "@/lib/types/navigation";
import type { PlacesPack, PlaceItem, PlaceCategory } from "@/lib/types/places";
import { shortId } from "@/lib/utils/ids";
import { haptic } from "@/lib/native/haptics";
import { hideKeyboard } from "@/lib/native/keyboard";

import { TripSuggestionsPanel } from "@/components/trip/TripSuggestionsPanel";

export type TripEditorRebuildMode = "auto" | "online" | "offline";

function ensureStopIds(stops: TripStop[]): TripStop[] {
  return (stops ?? []).map((s) => (s.id ? s : { ...s, id: shortId() }));
}

function isLockedStop(s: TripStop) {
  const t = s.type ?? "poi";
  return t === "start" || t === "end";
}

function stopLabel(s: TripStop, idx: number) {
  const t = s.type ?? "poi";
  const name = s.name?.trim();
  if (name) return name;
  if (t === "start") return "Start";
  if (t === "end") return "End";
  return `Stop ${idx}`;
}

export function TripEditorSheet(props: {
  planId: string;
  navpack: NavPack;
  corridor: CorridorGraphPack;
  places?: PlacesPack | null;

  focusedStopId?: string | null;
  onFocusStop?: (stopId: string | null) => void;
  onRebuildRequested: (args: { stops: TripStop[]; mode: TripEditorRebuildMode }) => Promise<void>;
  setBusy?: (v: string | null) => void;
  setErr?: (v: string | null) => void;
  allowModeToggle?: boolean;
  onAddSuggestion?: (place: PlaceItem) => Promise<void> | void;
  focusedPlaceId?: string | null;
  onFocusPlace?: (placeId: string | null) => void;
}) {
  const [stops, setStops] = useState<TripStop[]>(() => ensureStopIds(props.navpack.req?.stops ?? []));
  const [dirty, setDirty] = useState(false);
  const [busyLocal, setBusyLocal] = useState<string | null>(null);
  const [errLocal, setErrLocal] = useState<string | null>(null);

  const [showSuggestions, setShowSuggestions] = useState(false);
  const [mode, setMode] = useState<TripEditorRebuildMode>("auto");

  useEffect(() => {
    setStops(ensureStopIds(props.navpack.req?.stops ?? []));
    setDirty(false);
    setErrLocal(null);
  }, [props.navpack]);

  const canRebuild = stops.length >= 2 && !!props.corridor;

  const setBusy = (v: string | null) => {
    setBusyLocal(v);
    props.setBusy?.(v);
  };
  const setErr = (v: string | null) => {
    setErrLocal(v);
    props.setErr?.(v);
  };

  const moveStop = (fromIdx: number, dir: -1 | 1) => {
    haptic.selection();
    setStops((prev) => {
      const toIdx = fromIdx + dir;
      if (fromIdx <= 0 || fromIdx >= prev.length) return prev;
      if (toIdx <= 0 || toIdx >= prev.length - 1) return prev;
      const from = prev[fromIdx];
      const to = prev[toIdx];
      if (!from || !to || isLockedStop(from) || isLockedStop(to)) return prev;
      
      const out = [...prev];
      const [moved] = out.splice(fromIdx, 1);
      out.splice(toIdx, 0, moved);
      return out;
    });
    setDirty(true);
  };

  const removeStop = (id?: string | null) => {
    if (!id) return;
    haptic.medium();
    setStops((prev) => {
      const s = prev.find((x) => x.id === id);
      if (!s || isLockedStop(s)) return prev;
      return prev.filter((x) => x.id !== id);
    });
    if (props.focusedStopId === id) props.onFocusStop?.(null);
    setDirty(true);
  };

  const addStopFromPlaceLocally = (p: PlaceItem) => {
    haptic.tap();
    setStops((prev) => {
      const out = [...prev];
      const endIdx = out.findIndex((s) => (s.type ?? "poi") === "end");
      const next: TripStop = { id: shortId(), type: "poi", name: p.name, lat: p.lat, lng: p.lng };
      if (endIdx >= 0) out.splice(endIdx, 0, next); else out.push(next);
      return out;
    });
    setDirty(true);
    hideKeyboard();
  };

  const reset = () => {
    haptic.tap();
    setStops(ensureStopIds(props.navpack.req?.stops ?? []));
    setDirty(false);
    setErr(null);
  };

  const rebuild = async () => {
    if (!canRebuild) return;
    haptic.medium();
    hideKeyboard();
    setBusy("edit_rebuild");
    setErr(null);
    try {
      await props.onRebuildRequested({ stops: ensureStopIds(stops), mode });
      setDirty(false);
      haptic.success();
      setShowSuggestions(false);
    } catch (e: any) {
      setErr(e?.message ?? "Rebuild failed");
      haptic.error();
    } finally {
      setBusy(null);
    }
  };

  const summary = useMemo(() => ({ stops: stops.length, places: props.places?.items?.length ?? 0 }), [stops.length, props.places]);

  return (
    <div className="trip-flex-col trip-gap-md">
      {/* Editor Header */}
      <div className="trip-flex-row trip-justify-between trip-align-center">
        <div>
          <h3 className="trip-title">Route Planner</h3>
          <div className="trip-muted-small trip-mt-xs">
            {dirty ? <span className="trip-badge trip-badge-warning">Unsaved changes</span> : `${summary.stops} stops total`}
          </div>
        </div>

        <div className="trip-flex-row trip-align-center trip-gap-xs">
          
          <button type="button" className="trip-btn-xs trip-btn-secondary" disabled={!!busyLocal}
            onClick={() => { haptic.tap(); setShowSuggestions((v) => !v); hideKeyboard(); }}>
            {showSuggestions ? "Cancel Add" : "+ Add Stop"}
          </button>
        </div>
      </div>

      {errLocal && <div className="trip-err-box">{errLocal}</div>}

      {/* Editor Stops List */}
      <div className="trip-list-compact trip-bordered-list">
        {stops.map((s, idx) => {
          const locked = isLockedStop(s);
          const focused = props.focusedStopId === s.id;

          return (
            <div key={s.id ?? `${idx}`} className="trip-list-row" data-focused={focused} onClick={() => { haptic.selection(); props.onFocusStop?.(s.id ?? null); }}>
              <div className={`trip-badge-dot ${locked ? "dot-locked" : "dot-free"}`}>{idx + 1}</div>
              
              <div className="trip-list-row-content">
                <div className="trip-title trip-truncate">{stopLabel(s, idx)}</div>
                <div className="trip-muted-small trip-truncate trip-mt-xs">{s.lat.toFixed(4)}, {s.lng.toFixed(4)}</div>
              </div>

              {/* Action Buttons */}
              <div className="trip-flex-row trip-gap-xs">
                {!locked && idx > 1 && (
                  <button type="button" className="trip-btn-icon" disabled={!!busyLocal} onClick={(e) => { e.stopPropagation(); moveStop(idx, -1); }}>↑</button>
                )}
                {!locked && idx < stops.length - 2 && (
                  <button type="button" className="trip-btn-icon" disabled={!!busyLocal} onClick={(e) => { e.stopPropagation(); moveStop(idx, +1); }}>↓</button>
                )}
                {!locked && (
                  <button type="button" className="trip-btn-icon icon-danger" disabled={!!busyLocal} onClick={(e) => { e.stopPropagation(); removeStop(s.id); }}>✕</button>
                )}
              </div>
            </div>
          );
        })}
      </div>

      {/* Embedded Suggestions Drawer */}
      {showSuggestions && props.places && (
        <div className="trip-panel trip-panel-inset">
          <TripSuggestionsPanel
            places={props.places}
            enableSearch={true}
            maxHeight="30vh"
            focusedPlaceId={props.focusedPlaceId ?? null}
            onFocusPlace={props.onFocusPlace}
            onAddStopFromPlace={(p) => {
              if (props.onAddSuggestion) {
                haptic.tap(); props.onAddSuggestion(p); setShowSuggestions(false);
              } else {
                addStopFromPlaceLocally(p);
              }
            }}
          />
          <p className="trip-muted-small trip-mt-sm">
            <strong>Tip:</strong> Use the Guide tab to ask for specific spots and they will sync here.
          </p>
        </div>
      )}

      {/* Footer Actions */}
      <div className="trip-action-grid">
        <button type="button" className="trip-btn trip-btn-ghost" disabled={!!busyLocal || !dirty} onClick={reset}>Reset</button>
        <button type="button" className="trip-btn trip-btn-primary" disabled={!!busyLocal || !dirty || !canRebuild} onClick={rebuild}>Save Route</button>
      </div>
    </div>
  );
}

===== src/components/trip/TripMap.tsx =====

// src/components/trip/TripMap.tsx
"use client";

import { useEffect, useMemo, useRef, useCallback } from "react";
import { rewriteStyleForLocalServer, isFullyOfflineCapable } from "@/lib/offline/basemapManager";

import maplibregl, { type Map as MLMap, type LngLatBoundsLike } from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import { Protocol } from "pmtiles";

import type { BBox4 } from "@/lib/types/geo";
import type { TripStop } from "@/lib/types/trip";
import type { PlaceItem, PlaceCategory } from "@/lib/types/places";
import type { TrafficOverlay, HazardOverlay, TrafficEvent, HazardEvent } from "@/lib/types/navigation";
import type { RoamPosition } from "@/lib/native/geolocation";
import type { FuelStation, FuelTrackingState } from "@/lib/types/fuel";

import { assetsApi } from "@/lib/api/assets";

type Props = {
  styleId: string;

  stops: TripStop[];
  geometry: string; // polyline6
  bbox: BBox4;

  focusedStopId?: string | null;
  onStopPress?: (stopId: string) => void;

  // Suggestions
  suggestions?: PlaceItem[] | null;
  filteredSuggestionIds?: Set<string> | null;
  focusedSuggestionId?: string | null;
  onSuggestionPress?: (placeId: string) => void;

  // Overlays
  traffic?: TrafficOverlay | null;
  hazards?: HazardOverlay | null;
  onTrafficEventPress?: (eventId: string) => void;
  onHazardEventPress?: (eventId: string) => void;

  // User location (from native geolocation)
  userPosition?: RoamPosition | null;

  // Map tap for placing stops
  onMapLongPress?: (lat: number, lng: number) => void;

  // Guide navigation
  planId?: string | null;
  onNavigateToGuide?: (placeId: string) => void;

  // Alert highlight — pulses the marker in-place without moving the camera
  highlightedAlertId?: string | null;

  fuelStations?: FuelStation[] | null;
  fuelTracking?: FuelTrackingState | null;

   // ── Active navigation mode ──
   /** When true, map is in heading-up tracking mode. Disables bbox refit. */
   navigationMode?: boolean;
   /** Ref that TripMap populates with the MapLibre instance for external control */
   mapInstanceRef?: React.MutableRefObject<import("maplibre-gl").Map | null>;
 };

/* ── Layer / source IDs ─────────────────────────────────────────────── */

const ROUTE_SRC = "roam-route-src";
const ROUTE_GLOW = "roam-route-glow";
const ROUTE_CASING = "roam-route-casing";
const ROUTE_LINE = "roam-route-line";

const STOPS_SRC = "roam-stops-src";
const STOPS_SHADOW = "roam-stops-shadow";
const STOPS_OUTER = "roam-stops-outer";
const STOPS_INNER = "roam-stops-inner";
const STOP_PULSE = "roam-stop-pulse";
const STOP_ICON_LAYER = "roam-stop-icon";
const STOP_LABELS = "roam-stop-labels";
const STOP_FOCUS_RING = "roam-stop-focus-ring";

const SUG_SRC = "roam-suggestions-src";
const SUG_CLUSTER_CIRCLE = "roam-sug-cluster-circle";
const SUG_CLUSTER_COUNT = "roam-sug-cluster-count";
const SUG_UNCLUSTERED = "roam-sug-unclustered";
const SUG_ICON_LAYER = "roam-sug-icon";
const SUG_LABEL_LAYER = "roam-sug-label";

const TRAFFIC_POINT_SRC = "roam-traffic-pt-src";
const TRAFFIC_LINE_SRC = "roam-traffic-line-src";
const TRAFFIC_POLY_SRC = "roam-traffic-poly-src";
const TRAFFIC_POLY_LAYER = "roam-traffic-poly";
const TRAFFIC_LINE_CASING = "roam-traffic-line-casing";
const TRAFFIC_LINE_LAYER = "roam-traffic-line";
const TRAFFIC_PULSE_LAYER = "roam-traffic-pulse";
const TRAFFIC_POINT_LAYER = "roam-traffic-pt";

const HAZARD_POINT_SRC = "roam-hazard-pt-src";
const HAZARD_POLY_SRC = "roam-hazard-poly-src";
const HAZARD_POLY_LAYER = "roam-hazard-poly";
const HAZARD_POLY_OUTLINE = "roam-hazard-poly-outline";
const HAZARD_ICON_LAYER = "roam-hazard-icon";

const ALERT_HIGHLIGHT_SRC = "roam-alert-highlight-src";
const ALERT_HIGHLIGHT_RING = "roam-alert-highlight-ring";
const ALERT_HIGHLIGHT_PING = "roam-alert-highlight-ping";

const USER_LOC_SRC = "roam-user-loc-src";
const USER_LOC_ACCURACY = "roam-user-loc-accuracy";
const USER_LOC_DOT_OUTER = "roam-user-loc-dot-outer";
const USER_LOC_DOT_INNER = "roam-user-loc-dot-inner";
const USER_LOC_HEADING_SRC = "roam-user-heading-src";
const USER_LOC_HEADING = "roam-user-loc-heading";

const FUEL_SRC = "roam-fuel-src";
const FUEL_CIRCLE_LAYER = "roam-fuel-circle";
const FUEL_ICON_LAYER = "roam-fuel-icon";
const FUEL_LABEL_LAYER = "roam-fuel-label";

/* ══════════════════════════════════════════════════════════════════════
   SVG Icon System — clean vector icons, no emojis
   ══════════════════════════════════════════════════════════════════════ */

function svgToDataUrl(svg: string): string {
  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
}

/**
 * Creates a clean, professional map marker SVG with a vector icon path.
 * All icons are drawn inside a filled circle with a subtle border.
 */
function makeIconSVG(pathD: string, bgColor: string, sizePx: number, iconColor: string = "#fff"): string {
  const r = sizePx / 2;
  // Icon is drawn in a 24x24 viewbox, scaled and centered within the circle
  const iconScale = (sizePx * 0.38) / 24;
  const iconOff = (sizePx - 24 * iconScale) / 2;
  return `<svg width="${sizePx}" height="${sizePx}" viewBox="0 0 ${sizePx} ${sizePx}" xmlns="http://www.w3.org/2000/svg">
    <defs><filter id="ds" x="-20%" y="-10%" width="140%" height="150%"><feDropShadow dx="0" dy="1" stdDeviation="1.5" flood-color="#000" flood-opacity="0.25"/></filter></defs>
    <circle cx="${r}" cy="${r}" r="${r - 1.5}" fill="${bgColor}" stroke="rgba(255,255,255,0.35)" stroke-width="1.5" filter="url(#ds)"/>
    <g transform="translate(${iconOff},${iconOff}) scale(${iconScale.toFixed(3)})">
      <path d="${pathD}" fill="${iconColor}" fill-rule="evenodd"/>
    </g>
  </svg>`;
}

/* ── Icon path data (24x24 viewBox) — clean Lucide-style strokes ──── */

const ICON_PATHS = {
  // ── Essential services ──
  fuel: "M6 2a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-5h1a3 3 0 0 0 3-3V6.5l1.3-1.3a1 1 0 0 0-1.4-1.4L16.6 5.1A3 3 0 0 0 14 4h-1V3a1 1 0 1 0-2 0v1H8V3a1 1 0 1 0-2 0v1Zm6 2H6v6h6V4Zm2 6a1 1 0 0 1 1-1h1v1a1 1 0 0 1-1 1h-1v-1Z",
  hospital: "M8 2a1 1 0 0 1 1 1v5h6V3a1 1 0 1 1 2 0v18a1 1 0 1 1-2 0v-5H9v5a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1Zm1 8v4h6v-4H9Z",
  cross: "M10 2h4v8h8v4h-8v8h-4v-8H2v-4h8V2Z",
  wrench:
    "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6-1.4 1.4-1.6-1.6a1 1 0 0 0-1.4 0l-5 5A3.8 3.8 0 0 0 2 18.5 3.5 3.5 0 0 0 5.5 22a3.8 3.8 0 0 0 3.4-4.9l5-5a1 1 0 0 0 0-1.4l-1.6-1.6 1.4-1.4 1.6 1.6a1 1 0 0 0 1.4 0l2-2A5 5 0 0 0 22 5.5V3l-2 2h-2V3l-2 2a1 1 0 0 0 0 1.4Z",
  droplet: "M12 2.7 6.3 10A7 7 0 0 0 5 14a7 7 0 1 0 14 0 7 7 0 0 0-1.3-4L12 2.7Z",
  pill: "M10.5 1.5a4.95 4.95 0 0 0-7 7l12 12a4.95 4.95 0 0 0 7-7l-12-12ZM7 7l5 5",

  // ── Accommodation ──
  tent: "M3 21h18L12 3 3 21Zm9-14.7 5.7 12.7H6.3L12 6.3Z",
  bed: "M2 12V5a1 1 0 0 1 1-1h5a2 2 0 0 1 2 2v2h10a2 2 0 0 1 2 2v2M2 12v5h20v-5M2 12h20M7 8a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z",
  building:
    "M3 21V3a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v18M3 21h18M12 7h4a1 1 0 0 1 1 1v13M7 5h2M7 9h2M7 13h2M7 17h2M15 11h2M15 15h2",

  // ── Food & drink ──
  cart: "M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4H6Zm0 2h12l2 2H4l2-2Zm2 6a4 4 0 1 0 8 0H8Z",
  coffee: "M17 8h1a4 4 0 0 1 0 8h-1M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V8ZM6 2v2M10 2v2M14 2v2",
  utensils: "M3 2v6a3 3 0 0 0 3 3h1v11h2V11h1a3 3 0 0 0 3-3V2M3 2v4h2V2M9 2v4h2V2M17 2c-2.5 0-4 1.5-4 4v6h4V2Zm0 10v10",
  beer: "M17 11h1a3 3 0 0 1 0 6h-1M2 6l1 13a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-13H2ZM6 2v4M10 2v4",

  // ── Nature & outdoors ──
  tree: "M12 2 4 14h5v8h6v-8h5L12 2Z",
  mountain: "M2 20 8.5 8l3 4.5L15 8l7 12H2Zm6.5-12L12 2l3.5 6",
  wave: "M2 12c2-3 4-3 6 0s4 3 6 0 4-3 6 0M2 17c2-3 4-3 6 0s4 3 6 0 4-3 6 0",
  sun_wave: "M12 2v2M4.9 4.9l1.4 1.4M2 12h2M4.9 19.1l1.4-1.4M20 12h2M18.7 6.3l1.4-1.4M12 6a6 6 0 0 1 6 6",
  swim: "M2 18c2-2 4-2 6 0s4 2 6 0 4-2 6-0M12 12a3 3 0 1 0 0-6 3 3 0 0 0 0 6ZM6 12l6-6 6 6",
  boot: "M4 16v4h12.5a3.5 3.5 0 0 0 3.5-3.5V14l-5-2v-2a2 2 0 0 0-2-2h-1l-1-4H9L7 8v5l-3 3Z",
  basket: "M4 10l-2 8a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2l-2-8H4ZM8 2l-4 8M16 2l4 8M12 14v4M8 14v4M16 14v4",
  eye: "M2.1 12A10 10 0 0 1 12 5a10 10 0 0 1 9.9 7A10 10 0 0 1 12 19a10 10 0 0 1-9.9-7ZM12 9a3 3 0 1 1 0 6 3 3 0 0 1 0-6Z",

  // ── Sightseeing ──
  columns: "M4 3v18M10 3v18M16 3v18M2 3h20M2 21h20M2 6h20M2 18h20",
  palette:
    "M12 2a10 10 0 0 0-1 20 2 2 0 0 0 2-2v-.5a2 2 0 0 1 2-2h1.5A2 2 0 0 0 18.5 15.5 10 10 0 0 0 12 2ZM8.5 8a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3ZM12 6a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3ZM16 9a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3Z",
  paw: "M12 13c-1.5 2.5-4 4-4 6a4 4 0 0 0 8 0c0-2-2.5-3.5-4-6ZM5 8a2 2 0 1 1 4 0 2 2 0 0 1-4 0ZM15 8a2 2 0 1 1 4 0 2 2 0 0 1-4 0ZM3 14a2 2 0 1 1 4 0 2 2 0 0 1-4 0ZM17 14a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z",
  star: "M12 2l3.1 6.3L22 9.3l-5 4.9 1.2 7L12 17.8 5.8 21.2 7 14.2 2 9.3l6.9-1L12 2Z",
  landmark: "M6 22V12M18 22V12M2 22h20M12 2l10 10H2L12 2Z",

  // ── Utilities ──
  town:
    "M3 21V8l4-4 4 4v13M11 21V12h5l4 4v5M7 9v.01M7 13v.01M7 17v.01M15 17v.01",
  wc: "M5 3a2 2 0 1 1 0 4 2 2 0 0 1 0-4Zm0 6v4m0 0-2 5m2-5 2 5M19 3a2 2 0 1 1 0 4 2 2 0 0 1 0-4Zm0 6v1m0 0c-1.5 0-2.5 2.5-2.5 4v4h5v-4c0-1.5-1-4-2.5-4Z",
  pin: "M12 2a7 7 0 0 0-7 7c0 5 7 13 7 13s7-8 7-13a7 7 0 0 0-7-7Zm0 4a3 3 0 1 1 0 6 3 3 0 0 1 0-6Z",
  map_marker: "M9 11l3 3L22 4M20 12v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h9",

  // ── Traffic overlay ──
  x_circle: "M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm3.5 6.5L12 12l-3.5 3.5M15.5 15.5 12 12 8.5 8.5",
  flood_wave: "M2 6c2-3 4-3 6 0s4 3 6 0 4-3 6 0M2 11c2-3 4-3 6 0s4 3 6 0 4-3 6 0M2 16c2-3 4-3 6 0s4 3 6 0 4-3 6 0",
  car: "M7 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM17 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM5 13l1.5-5A2 2 0 0 1 8.4 7h7.2a2 2 0 0 1 1.9 1L19 13M3 13h18v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-4Z",
  cone: "M9.5 21H4l4-14h8l4 14h-5.5M8 7l1-5h6l1 5M8 11h8M9 15h6",
  triangle_alert: "M12 3 2 21h20L12 3Zm0 7v4m0 3v.01",
  siren:
    "M12 2v2M4.9 4.9l1.4 1.4M19.1 4.9l-1.4 1.4M2 12h2M20 12h2M7 17.5A7 7 0 0 1 12 5a7 7 0 0 1 5 12.5M7 17.5v2.5h10v-2.5",
  question: "M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm0 14v.01M12 12a2 2 0 1 0-2-2",

  // ── Hazard overlay ──
  cyclone:
    "M12 12a3 3 0 1 0 0 .01M21 12c-1 5-6 8-9 8-5 0-9-4-9-9a9 9 0 0 1 15-6.7M3 12c1-5 6-8 9-8 5 0 9 4 9 9a9 9 0 0 1-15 6.7",
  lightning: "M13 2 3 14h8l-1 8 10-12h-8l1-8Z",
  flame: "M12 2c0 4-4 6-4 10a4 4 0 0 0 4 4 4 4 0 0 0 4-4c0-4-4-6-4-10Zm0 12a2 2 0 0 1-2-2c0-1.3 2-2.5 2-4 0 1.5 2 2.7 2 4a2 2 0 0 1-2 2Z",
  wind: "M17.7 7.7A2.5 2.5 0 1 0 15 4.5H2M9.6 4.6A2 2 0 1 1 11 2H2M12 19a3 3 0 1 0 3-3H2",
  thermometer: "M14 14.8A4 4 0 0 1 8 18a4 4 0 0 1 2-6.8V4a2 2 0 1 1 4 0v10.8ZM12 8H10",
  anchor: "M12 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3Zm0 6v14M5 12H2a10 10 0 0 0 20 0h-3",

  // ── Stop type icons ──
  flag_start: "M4 2v20M4 2l12 7-12 7",
  flag_end: "M4 2v20M4 2h14l-4 5 4 5H4",
  circle_dot: "M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm0 6a4 4 0 1 1 0 8 4 4 0 0 1 0-8Z",
  diamond: "M12 2l8 10-8 10-8-10L12 2Z",
};

/* ── Category → icon + color config ──────────────────────────────────── */

type CatConfig = { icon: keyof typeof ICON_PATHS; color: string; size: "lg" | "md" | "sm" };

const CATEGORY_CONFIG: Record<string, CatConfig> = {
  // ── Essentials & safety ─────────────────────────────────────────────
  fuel: { icon: "fuel", color: "#d97706", size: "lg" },
  ev_charging: { icon: "lightning", color: "#2563eb", size: "lg" },
  rest_area: { icon: "car", color: "#6366f1", size: "md" },
  toilet: { icon: "wc", color: "#8b5cf6", size: "sm" },
  water: { icon: "droplet", color: "#0284c7", size: "lg" },
  dump_point: { icon: "droplet", color: "#0d9488", size: "sm" },
  mechanic: { icon: "wrench", color: "#e11d48", size: "lg" },
  hospital: { icon: "cross", color: "#dc2626", size: "lg" },
  pharmacy: { icon: "pill", color: "#db2777", size: "lg" },
  // ── Supplies ────────────────────────────────────────────────────────
  grocery: { icon: "cart", color: "#059669", size: "md" },
  town: { icon: "town", color: "#a16207", size: "sm" },
  atm: { icon: "pin", color: "#0891b2", size: "sm" },
  laundromat: { icon: "pin", color: "#64748b", size: "sm" },
  // ── Food & drink ────────────────────────────────────────────────────
  bakery: { icon: "star", color: "#ea580c", size: "md" },
  cafe: { icon: "coffee", color: "#9333ea", size: "md" },
  restaurant: { icon: "utensils", color: "#ea580c", size: "md" },
  fast_food: { icon: "utensils", color: "#ca8a04", size: "sm" },
  pub: { icon: "beer", color: "#d97706", size: "sm" },
  bar: { icon: "beer", color: "#c026d3", size: "sm" },
  // ── Accommodation ───────────────────────────────────────────────────
  camp: { icon: "tent", color: "#16a34a", size: "lg" },
  hotel: { icon: "building", color: "#7c3aed", size: "md" },
  motel: { icon: "bed", color: "#7c3aed", size: "md" },
  hostel: { icon: "bed", color: "#7c3aed", size: "md" },
  // ── Nature & outdoors ───────────────────────────────────────────────
  viewpoint: { icon: "eye", color: "#7c3aed", size: "md" },
  waterfall: { icon: "wave", color: "#0891b2", size: "md" },
  swimming_hole: { icon: "swim", color: "#0891b2", size: "md" },
  beach: { icon: "sun_wave", color: "#2563eb", size: "md" },
  national_park: { icon: "mountain", color: "#15803d", size: "lg" },
  hiking: { icon: "boot", color: "#65a30d", size: "md" },
  picnic: { icon: "basket", color: "#84cc16", size: "sm" },
  hot_spring: { icon: "thermometer", color: "#ea580c", size: "md" },
  // ── Family & recreation ─────────────────────────────────────────────
  playground: { icon: "paw", color: "#f59e0b", size: "sm" },
  pool: { icon: "swim", color: "#0ea5e9", size: "md" },
  zoo: { icon: "paw", color: "#22c55e", size: "md" },
  theme_park: { icon: "star", color: "#ec4899", size: "md" },
  // ── Culture & sightseeing ───────────────────────────────────────────
  visitor_info: { icon: "pin", color: "#4f46e5", size: "sm" },
  museum: { icon: "columns", color: "#8b5cf6", size: "md" },
  gallery: { icon: "palette", color: "#a855f7", size: "sm" },
  heritage: { icon: "landmark", color: "#b45309", size: "md" },
  winery: { icon: "beer", color: "#9f1239", size: "md" },
  brewery: { icon: "beer", color: "#b45309", size: "md" },
  attraction: { icon: "star", color: "#eab308", size: "md" },
  market: { icon: "cart", color: "#65a30d", size: "md" },
  park: { icon: "tree", color: "#22c55e", size: "md" },
  // ── Geocoding (Mapbox) ──────────────────────────────────────────────
  address: { icon: "pin", color: "#64748b", size: "sm" },
  place: { icon: "pin", color: "#64748b", size: "sm" },
  region: { icon: "map_marker", color: "#64748b", size: "sm" },
};

const DEFAULT_CAT_CONFIG: CatConfig = { icon: "pin", color: "#64748b", size: "sm" };

function getCatConfig(cat: string): CatConfig {
  return CATEGORY_CONFIG[cat] ?? DEFAULT_CAT_CONFIG;
}

/* ── Traffic/hazard overlay icon configs ─────────────────────────────── */

const TRAFFIC_ICON_CFG: Record<string, { icon: keyof typeof ICON_PATHS; color: string }> = {
  closure: { icon: "x_circle", color: "#ef4444" },
  flooding: { icon: "flood_wave", color: "#3b82f6" },
  congestion: { icon: "car", color: "#f59e0b" },
  roadworks: { icon: "cone", color: "#f97316" },
  hazard: { icon: "triangle_alert", color: "#eab308" },
  incident: { icon: "siren", color: "#ef4444" },
  unknown: { icon: "question", color: "#64748b" },
};

const HAZARD_ICON_CFG: Record<string, { icon: keyof typeof ICON_PATHS; color: string }> = {
  flood: { icon: "flood_wave", color: "#3b82f6" },
  cyclone: { icon: "cyclone", color: "#7c3aed" },
  storm: { icon: "lightning", color: "#6366f1" },
  fire: { icon: "flame", color: "#ef4444" },
  wind: { icon: "wind", color: "#64748b" },
  heat: { icon: "thermometer", color: "#ea580c" },
  marine: { icon: "anchor", color: "#0ea5e9" },
  weather_warning: { icon: "lightning", color: "#eab308" },
  unknown: { icon: "triangle_alert", color: "#64748b" },
};

/* ── Load all icon images into the map ───────────────────────────────── */

const SIZE_PX: Record<CatConfig["size"], number> = { lg: 36, md: 30, sm: 24 };

function loadCategoryIcons(map: MLMap): Promise<void> {
  const promises: Promise<void>[] = [];
  for (const [cat, cfg] of Object.entries(CATEGORY_CONFIG)) {
    const imgId = `roam-cat-${cat}`;
    if (map.hasImage(imgId)) continue;
    const px = SIZE_PX[cfg.size];
    const pathD = ICON_PATHS[cfg.icon] ?? ICON_PATHS.pin;
    const svg = makeIconSVG(pathD, cfg.color, px);
    promises.push(loadSVGImage(map, imgId, svg, px));
  }
  // Default
  if (!map.hasImage("roam-cat-default")) {
    const svg = makeIconSVG(ICON_PATHS.pin, "#64748b", 24);
    promises.push(loadSVGImage(map, "roam-cat-default", svg, 24));
  }
  return Promise.all(promises).then(() => {});
}

function loadOverlayIcons(map: MLMap): Promise<void> {
  const promises: Promise<void>[] = [];
  for (const [k, v] of Object.entries(TRAFFIC_ICON_CFG)) {
    const id = `roam-traffic-${k}`;
    if (map.hasImage(id)) continue;
    const pathD = ICON_PATHS[v.icon] ?? ICON_PATHS.triangle_alert;
    promises.push(loadSVGImage(map, id, makeIconSVG(pathD, v.color, 32), 32));
  }
  for (const [k, v] of Object.entries(HAZARD_ICON_CFG)) {
    const id = `roam-hazard-${k}`;
    if (map.hasImage(id)) continue;
    const pathD = ICON_PATHS[v.icon] ?? ICON_PATHS.triangle_alert;
    promises.push(loadSVGImage(map, id, makeIconSVG(pathD, v.color, 32), 32));
  }
  return Promise.all(promises).then(() => {});
}

function loadStopIcons(map: MLMap): Promise<void> {
  const defs: Array<{ id: string; icon: keyof typeof ICON_PATHS; color: string; px: number }> = [
    { id: "roam-stop-start", icon: "flag_start", color: "#16a34a", px: 40 },
    { id: "roam-stop-end", icon: "flag_end", color: "#dc2626", px: 40 },
    { id: "roam-stop-via", icon: "diamond", color: "#9333ea", px: 34 },
    { id: "roam-stop-poi", icon: "circle_dot", color: "#2563eb", px: 34 },
  ];
  const promises: Promise<void>[] = [];
  for (const d of defs) {
    if (map.hasImage(d.id)) continue;
    const pathD = ICON_PATHS[d.icon];
    promises.push(loadSVGImage(map, d.id, makeIconSVG(pathD, d.color, d.px), d.px));
  }
  return Promise.all(promises).then(() => {});
}

function loadSVGImage(map: MLMap, id: string, svg: string, px: number): Promise<void> {
  return new Promise<void>((resolve) => {
    const img = new Image(px, px);
    img.onload = () => {
      if (!map.hasImage(id)) map.addImage(id, img, { sdf: false });
      resolve();
    };
    img.onerror = () => resolve();
    img.src = svgToDataUrl(svg);
  });
}

/* ── Heading arrow SVG ───────────────────────────────────────────────── */

const HEADING_ARROW_ID = "roam-heading-arrow";
const HEADING_ARROW_SVG = `<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
  <defs><linearGradient id="hg" x1="24" y1="4" x2="24" y2="28" gradientUnits="userSpaceOnUse">
    <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.85"/>
    <stop offset="100%" stop-color="#2563eb" stop-opacity="0.15"/>
  </linearGradient></defs>
  <path d="M24 4 L36 28 L24 22 L12 28 Z" fill="url(#hg)" stroke="#2563eb" stroke-width="1" stroke-opacity="0.4"/>
</svg>`;

function loadHeadingArrow(map: MLMap): Promise<void> {
  return loadSVGImage(map, HEADING_ARROW_ID, HEADING_ARROW_SVG, 48);
}

function loadFuelIcons(map: MLMap): Promise<void> {
  const defs = [
    { id: "roam-fuel-ok", color: "#22c55e" },
    { id: "roam-fuel-warn", color: "#f59e0b" },
    { id: "roam-fuel-critical", color: "#ef4444" },
  ];
  const promises: Promise<void>[] = [];
  for (const d of defs) {
    if (map.hasImage(d.id)) continue;
    const svg = makeIconSVG(ICON_PATHS.fuel, d.color, 38, "#fff");
    promises.push(loadSVGImage(map, d.id, svg, 38));
  }
  return Promise.all(promises).then(() => {});
}

/* ── Helpers ─────────────────────────────────────────────────────────── */

function bboxToBounds(b: BBox4): LngLatBoundsLike {
  return [
    [b.minLng, b.minLat],
    [b.maxLng, b.maxLat],
  ];
}

function decodePolyline6(poly: string): Array<[number, number]> {
  let index = 0,
    lat = 0,
    lng = 0;
  const coordinates: Array<[number, number]> = [];
  const factor = 1e6;
  while (index < poly.length) {
    let result = 0,
      shift = 0,
      b: number;
    do {
      b = poly.charCodeAt(index++) - 63;
      result |= (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    lat += result & 1 ? ~(result >> 1) : result >> 1;
    result = 0;
    shift = 0;
    do {
      b = poly.charCodeAt(index++) - 63;
      result |= (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    lng += result & 1 ? ~(result >> 1) : result >> 1;
    coordinates.push([lng / factor, lat / factor]);
  }
  return coordinates;
}

function routeGeoJSON(polyline6: string) {
  return {
    type: "FeatureCollection",
    features: [{ type: "Feature", properties: {}, geometry: { type: "LineString", coordinates: decodePolyline6(polyline6) } }],
  } as any;
}

function stopsGeoJSON(stops: TripStop[]) {
  return {
    type: "FeatureCollection",
    features: (stops ?? []).map((s, idx) => ({
      type: "Feature",
      properties: {
        id: s.id ?? `${idx}`,
        type: s.type ?? "poi",
        name: s.name ?? "",
        idx,
        iconId: `roam-stop-${s.type ?? "poi"}`,
      },
      geometry: { type: "Point", coordinates: [s.lng, s.lat] },
    })),
  } as any;
}

function suggestionsGeoJSON(items: PlaceItem[], allowed?: Set<string> | null) {
  return {
    type: "FeatureCollection",
    features: (items ?? [])
      .filter((p) => (allowed ? allowed.has(p.id) : true))
      .map((p) => {
        const cfg = getCatConfig(p.category);
        return {
          type: "Feature",
          properties: {
            id: p.id,
            name: p.name ?? "",
            category: p.category ?? "unknown",
            color: cfg.color,
            sizeClass: cfg.size,
            iconId: CATEGORY_CONFIG[p.category] ? `roam-cat-${p.category}` : "roam-cat-default",
          },
          geometry: { type: "Point", coordinates: [p.lng, p.lat] },
        };
      }),
  } as any;
}

/* ── Overlay GeoJSON builders ────────────────────────────────────────── */

function trafficPointsGeoJSON(overlay: TrafficOverlay | null) {
  if (!overlay) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: overlay.items
      .filter((ev) => ev.geometry && ev.geometry.type === "Point" && Array.isArray(ev.geometry.coordinates))
      .map((ev) => ({
        type: "Feature",
        properties: {
          id: ev.id,
          type: ev.type ?? "unknown",
          severity: ev.severity ?? "unknown",
          headline: ev.headline,
          iconId: `roam-traffic-${ev.type ?? "unknown"}`,
        },
        geometry: ev.geometry,
      })),
  } as any;
}

function trafficLinesGeoJSON(overlay: TrafficOverlay | null) {
  if (!overlay) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: overlay.items
      .filter((ev) => ev.geometry && (ev.geometry.type === "LineString" || ev.geometry.type === "MultiLineString"))
      .map((ev) => ({
        type: "Feature",
        properties: { id: ev.id, type: ev.type ?? "unknown", severity: ev.severity ?? "unknown", headline: ev.headline },
        geometry: ev.geometry,
      })),
  } as any;
}

function trafficPolygonsGeoJSON(overlay: TrafficOverlay | null) {
  if (!overlay) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: overlay.items
      .filter((ev) => ev.geometry && (ev.geometry.type === "Polygon" || ev.geometry.type === "MultiPolygon"))
      .map((ev) => ({
        type: "Feature",
        properties: { id: ev.id, type: ev.type ?? "unknown", severity: ev.severity ?? "unknown", headline: ev.headline },
        geometry: ev.geometry,
      })),
  } as any;
}

function hazardPointsGeoJSON(overlay: HazardOverlay | null) {
  if (!overlay) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: overlay.items
      .map((ev) => {
        if (ev.geometry && ev.geometry.type === "Point") {
          return {
            type: "Feature",
            properties: {
              id: ev.id,
              kind: ev.kind ?? "unknown",
              severity: ev.severity ?? "unknown",
              title: ev.title,
              iconId: `roam-hazard-${ev.kind ?? "unknown"}`,
            },
            geometry: ev.geometry,
          };
        }
        if (ev.bbox && ev.bbox.length === 4 && !ev.geometry) {
          return {
            type: "Feature",
            properties: {
              id: ev.id,
              kind: ev.kind ?? "unknown",
              severity: ev.severity ?? "unknown",
              title: ev.title,
              iconId: `roam-hazard-${ev.kind ?? "unknown"}`,
            },
            geometry: { type: "Point", coordinates: [(ev.bbox[0] + ev.bbox[2]) / 2, (ev.bbox[1] + ev.bbox[3]) / 2] },
          };
        }
        return null;
      })
      .filter(Boolean),
  } as any;
}

function hazardPolygonsGeoJSON(overlay: HazardOverlay | null) {
  if (!overlay) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: overlay.items
      .filter((ev) => ev.geometry && (ev.geometry.type === "Polygon" || ev.geometry.type === "MultiPolygon"))
      .map((ev) => ({
        type: "Feature",
        properties: { id: ev.id, kind: ev.kind ?? "unknown", severity: ev.severity ?? "unknown", title: ev.title },
        geometry: ev.geometry,
      })),
  } as any;
}

/* ── User location GeoJSON ───────────────────────────────────────────── */

function userLocGeoJSON(pos: RoamPosition | null | undefined) {
  if (!pos) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: [
      {
        type: "Feature",
        properties: { accuracy: pos.accuracy, heading: pos.heading, speed: pos.speed },
        geometry: { type: "Point", coordinates: [pos.lng, pos.lat] },
      },
    ],
  } as any;
}

function headingConeGeoJSON(pos: RoamPosition | null | undefined) {
  if (!pos || pos.heading == null || pos.speed == null || pos.speed < 0.5) return { type: "FeatureCollection", features: [] } as any;
  return {
    type: "FeatureCollection",
    features: [{ type: "Feature", properties: { heading: pos.heading }, geometry: { type: "Point", coordinates: [pos.lng, pos.lat] } }],
  } as any;
}

function accuracyToPixels(accuracyM: number, lat: number, zoom: number): number {
  const metersPerPixel = (Math.cos((lat * Math.PI) / 180) * 2 * Math.PI * 6371008.8) / (256 * Math.pow(2, zoom));
  return Math.max(12, Math.min(200, accuracyM / metersPerPixel));
}

/* ── Style / PMTiles helpers ─────────────────────────────────────────── */

function rewriteStyleForPMTiles(style: any, origin: string) {
  if (!style?.sources || typeof style.sources !== "object") return style;
  const out = { ...style, sources: { ...style.sources } };
  for (const [k, src] of Object.entries<any>(out.sources)) {
    if (!src || typeof src !== "object") continue;
    if (typeof src.url === "string" && src.url.startsWith("pmtiles://")) {
      out.sources[k] = { ...src, url: normalizePmtilesUrl(src.url, origin) };
    } else if (Array.isArray(src.tiles)) {
      out.sources[k] = {
        ...src,
        tiles: src.tiles.map((t: string) => (typeof t === "string" && t.startsWith("pmtiles://") ? normalizePmtilesUrl(t, origin) : t)),
      };
    }
  }
  return out;
}

function normalizePmtilesUrl(u: string, origin: string) {
  let inner = u.slice("pmtiles://".length).replace(/^\/+/, "");
  if (/^https?:\/\//i.test(inner)) return `pmtiles://${inner}`;
  const path = inner.startsWith("offline/") ? `/${inner}` : inner.startsWith("/") ? inner : `/${inner}`;
  return `pmtiles://${origin}${path}`;
}

function escapeHtml(s: string) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function addOrUpdateGeoJsonSource(map: MLMap, id: string, data: any, extraOpts?: Record<string, any>) {
  const src: any = map.getSource(id);
  if (!src) {
    map.addSource(id, { type: "geojson", data, ...extraOpts });
    return;
  }
  if (src?.setData) src.setData(data);
}

function easeToCoord(map: MLMap, coord: [number, number], opts?: { zoom?: number; duration?: number }) {
  try {
    const z = opts?.zoom ?? Math.max(map.getZoom(), 13);
    map.easeTo({ center: coord, zoom: Math.min(z, 17), duration: opts?.duration ?? 450 });
  } catch {}
}

/* ── Severity color helpers ──────────────────────────────────────────── */

const TRAFFIC_SEV_COLORS: Record<string, string> = {
  major: "#ef4444",
  moderate: "#f59e0b",
  minor: "#3b82f6",
  info: "#64748b",
  unknown: "#64748b",
};
const HAZARD_SEV_COLORS: Record<string, string> = { high: "#dc2626", medium: "#ea580c", low: "#2563eb", unknown: "#64748b" };

/* ══════════════════════════════════════════════════════════════════════
   Component
   ══════════════════════════════════════════════════════════════════════ */

export function TripMap(props: Props) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const mapRef = useRef<MLMap | null>(null);
  const popupRef = useRef<maplibregl.Popup | null>(null);
  const protocolRef = useRef<Protocol | null>(null);
  const accuracyAnimFrame = useRef<number | null>(null);

  const onNavToGuideRef = useRef(props.onNavigateToGuide);
  onNavToGuideRef.current = props.onNavigateToGuide;
  const onSugPressRef = useRef(props.onSuggestionPress);
  onSugPressRef.current = props.onSuggestionPress;
  const onTrafficPressRef = useRef(props.onTrafficEventPress);
  onTrafficPressRef.current = props.onTrafficEventPress;
  const onHazardPressRef = useRef(props.onHazardEventPress);
  onHazardPressRef.current = props.onHazardEventPress;

  const routeFC = useMemo(() => routeGeoJSON(props.geometry), [props.geometry]);
  const stopsFC = useMemo(() => stopsGeoJSON(props.stops), [props.stops]);
  const sugFC = useMemo(
    () => suggestionsGeoJSON(props.suggestions ?? [], props.filteredSuggestionIds ?? null),
    [props.suggestions, props.filteredSuggestionIds],
  );

  const trafficPtFC = useMemo(() => trafficPointsGeoJSON(props.traffic ?? null), [props.traffic]);
  const trafficLineFC = useMemo(() => trafficLinesGeoJSON(props.traffic ?? null), [props.traffic]);
  const trafficPolyFC = useMemo(() => trafficPolygonsGeoJSON(props.traffic ?? null), [props.traffic]);
  const hazardPtFC = useMemo(() => hazardPointsGeoJSON(props.hazards ?? null), [props.hazards]);
  const hazardPolyFC = useMemo(() => hazardPolygonsGeoJSON(props.hazards ?? null), [props.hazards]);

  const userLocFC = useMemo(() => userLocGeoJSON(props.userPosition), [props.userPosition]);
  const headingFC = useMemo(() => headingConeGeoJSON(props.userPosition), [props.userPosition]);

  const fuelFC = useMemo<GeoJSON.FeatureCollection>(() => {
    const stations = props.fuelStations;
    if (!stations || stations.length === 0) {
      return { type: "FeatureCollection", features: [] };
    }
    return {
      type: "FeatureCollection",
      features: stations.map((st) => ({
        type: "Feature" as const,
        geometry: { type: "Point" as const, coordinates: [st.lng, st.lat] },
        properties: {
          id: st.place_id,
          name: st.name,
          km: st.km_along_route,
          snap_m: st.snap_distance_m,
          side: st.side,
          // Determine color based on what comes AFTER this station
          fuel_level: "ok", // will be overridden below
        },
      })),
    };
  }, [props.fuelStations]);

  /* ── Build popup HTML ───────────────────────────────────────────────── */

  const buildSuggestionPopupHtml = useCallback((name: string, category: string, placeId: string) => {
    const cfg = getCatConfig(category);
    return `<div style="font-family:inherit;min-width:160px">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
        <div style="width:28px;height:28px;border-radius:8px;background:${cfg.color};display:grid;place-items:center;flex-shrink:0">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="${ICON_PATHS[cfg.icon] ?? ICON_PATHS.pin}"/></svg>
        </div>
        <div>
          <div style="font-size:14px;font-weight:900;letter-spacing:-0.2px;color:var(--roam-text)">${escapeHtml(name)}</div>
          <div style="font-size:11px;font-weight:700;color:var(--roam-text-muted);text-transform:capitalize;margin-top:1px">${escapeHtml(category.replace("_", " "))}</div>
        </div>
      </div>
      <button data-roam-guide-place="${escapeHtml(
        placeId,
      )}" style="display:block;width:100%;margin-top:8px;padding:8px 0;border:none;border-radius:10px;cursor:pointer;font-size:12px;font-weight:950;letter-spacing:0.2px;background:var(--roam-accent,#4a6c53);color:#fff;box-shadow:0 2px 8px rgba(74,108,83,0.35);transition:opacity 0.1s" onmouseover="this.style.opacity='0.85'" onmouseout="this.style.opacity='1'">View in Guide</button>
    </div>`;
  }, []);

  const buildOverlayPopupHtml = useCallback((title: string, severity: string, sevColor: string, description?: string | null) => {
    return `<div style="font-family:inherit;min-width:160px;max-width:260px">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
        <div style="flex:1;min-width:0">
          <div style="font-size:13px;font-weight:950;color:var(--roam-text);line-height:1.3">${escapeHtml(title)}</div>
          <span style="display:inline-block;margin-top:3px;font-size:10px;font-weight:900;text-transform:uppercase;letter-spacing:0.5px;color:${sevColor};background:color-mix(in srgb, ${sevColor} 12%, transparent);padding:2px 7px;border-radius:5px;">${escapeHtml(
            severity,
          )}</span>
        </div>
      </div>
      ${
        description
          ? `<div style="font-size:11px;font-weight:600;color:var(--roam-text-muted);line-height:1.5;margin-top:6px">${escapeHtml(
              description.slice(0, 200),
            )}${description.length > 200 ? "…" : ""}</div>`
          : ""
      }
    </div>`;
  }, []);

  /* ══════════════════════════════════════════════════════════════════════
     Init map once
     ══════════════════════════════════════════════════════════════════════ */
  useEffect(() => {
    if (!containerRef.current || mapRef.current) return;

    const origin = typeof window !== "undefined" ? window.location.origin : "";
    const protocol = new Protocol();
    protocolRef.current = protocol;
    maplibregl.addProtocol("pmtiles", protocol.tile.bind(protocol));

    const map = new maplibregl.Map({
      container: containerRef.current,
      style: { version: 8, sources: {}, layers: [] } as any,
      center: [(props.bbox.minLng + props.bbox.maxLng) / 2, (props.bbox.minLat + props.bbox.maxLat) / 2],
      zoom: 6,
      attributionControl: false,
      transformRequest: (url) => {
        if (typeof url === "string" && url.startsWith("pmtiles://")) return { url: normalizePmtilesUrl(url, origin) };
        return { url };
      },
    });
    mapRef.current = map;
    if (props.mapInstanceRef) props.mapInstanceRef.current = map;
    // Load style
    (async () => {
      try {
        const res = await fetch(assetsApi.styleUrl(props.styleId));
        let styleJson = await res.json();

        // If the local tile server is running, rewrite ALL source/glyph/sprite
        // URLs to point to localhost. This is the offline-first path.
        if (isFullyOfflineCapable()) {
          styleJson = rewriteStyleForLocalServer(styleJson);
        }

        // Then apply the existing PMTiles URL normalization for Capacitor safety
        map.setStyle(rewriteStyleForPMTiles(styleJson, origin), { diff: false });
      } catch (e) {
        console.error("[TripMap] style load failed", e);
      }
    })();

    // Stop click handler
    const registerStopClick = (layerId: string) => {
      map.on("click", layerId, (e: any) => {
        const id = e?.features?.[0]?.properties?.id;
        if (id) props.onStopPress?.(String(id));
      });
      map.on("mouseenter", layerId, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", layerId, () => (map.getCanvas().style.cursor = ""));
    };

    // Long press for placing stops
    let longPressTimer: ReturnType<typeof setTimeout> | null = null;
    let longPressPos: { x: number; y: number } | null = null;

    map.getCanvas().addEventListener("pointerdown", (e) => {
      longPressPos = { x: e.clientX, y: e.clientY };
      longPressTimer = setTimeout(() => {
        if (!longPressPos) return;
        const lngLat = map.unproject([e.offsetX, e.offsetY]);
        props.onMapLongPress?.(lngLat.lat, lngLat.lng);
      }, 600);
    });
    map.getCanvas().addEventListener("pointermove", (e) => {
      if (longPressPos && longPressTimer) {
        const dx = e.clientX - longPressPos.x,
          dy = e.clientY - longPressPos.y;
        if (Math.sqrt(dx * dx + dy * dy) > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }
    });
    map.getCanvas().addEventListener("pointerup", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      longPressPos = null;
    });

    // Global click handler for popup "View in Guide" button
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      const placeId = target?.getAttribute?.("data-roam-guide-place");
      if (placeId) {
        e.preventDefault();
        e.stopPropagation();
        onNavToGuideRef.current?.(placeId);
      }
    });

    map.on("style.load", async () => {
      await Promise.all([loadHeadingArrow(map), loadCategoryIcons(map), loadOverlayIcons(map), loadStopIcons(map), loadFuelIcons(map)]);

      /* ════════════════════════════════════════════════════════════════
         LAYER ORDER (bottom → top):
         1. Route (glow → casing → line)
         2. Traffic overlays (poly → line casing → line → pulse → icons)
         3. Hazard overlays (poly → outline → icons)
         4. Suggestions (clusters → unclustered → icons → labels)
         5. Stops (shadow → outer → inner → icons → labels → focus ring)
         6. User location (accuracy → heading → dots)
         7. Fuel stations (circle → icon → label)
         8. Alert highlight (ring → ping animation)
         ════════════════════════════════════════════════════════════════ */

      /* ── 1. Route layers — warm outback amber/gold ─────────────────── */
      addOrUpdateGeoJsonSource(map, ROUTE_SRC, routeFC);

      // Outer glow — warm amber haze
      if (!map.getLayer(ROUTE_GLOW)) {
        map.addLayer({
          id: ROUTE_GLOW,
          type: "line",
          source: ROUTE_SRC,
          layout: { "line-cap": "round", "line-join": "round" },
          paint: {
            "line-color": "rgba(212,148,58,0.4)",
            "line-width": ["interpolate", ["linear"], ["zoom"], 4, 10, 10, 16, 14, 24],
            "line-blur": ["interpolate", ["linear"], ["zoom"], 4, 8, 14, 14],
            "line-opacity": 0.5,
          },
        });
      }

      // Dark casing — deep brown-black for contrast
      if (!map.getLayer(ROUTE_CASING)) {
        map.addLayer({
          id: ROUTE_CASING,
          type: "line",
          source: ROUTE_SRC,
          layout: { "line-cap": "round", "line-join": "round" },
          paint: {
            "line-color": "rgba(45,32,18,0.7)",
            "line-width": ["interpolate", ["linear"], ["zoom"], 4, 5, 10, 9, 14, 13],
            "line-opacity": 0.65,
          },
        });
      }

      // Main route line — warm golden amber
      if (!map.getLayer(ROUTE_LINE)) {
        map.addLayer({
          id: ROUTE_LINE,
          type: "line",
          source: ROUTE_SRC,
          layout: { "line-cap": "round", "line-join": "round" },
          paint: {
            "line-color": "rgba(218,165,72,0.95)",
            "line-width": ["interpolate", ["linear"], ["zoom"], 4, 3, 10, 6.5, 14, 10],
            "line-opacity": 0.95,
          },
        });
      }

      /* ── 2. Traffic overlay layers (ABOVE route) ───────────────────── */
      addOrUpdateGeoJsonSource(map, TRAFFIC_POLY_SRC, trafficPolyFC);
      addOrUpdateGeoJsonSource(map, TRAFFIC_LINE_SRC, trafficLineFC);
      addOrUpdateGeoJsonSource(map, TRAFFIC_POINT_SRC, trafficPtFC);

      if (!map.getLayer(TRAFFIC_POLY_LAYER)) {
        map.addLayer({
          id: TRAFFIC_POLY_LAYER,
          type: "fill",
          source: TRAFFIC_POLY_SRC,
          paint: {
            "fill-color": [
              "match",
              ["get", "severity"],
              "major",
              "rgba(239,68,68,0.22)",
              "moderate",
              "rgba(245,158,11,0.18)",
              "minor",
              "rgba(59,130,246,0.12)",
              "rgba(100,116,139,0.08)",
            ],
            "fill-opacity": 0.85,
          },
        });
      }

      // Traffic line casing for extra weight
      if (!map.getLayer(TRAFFIC_LINE_CASING)) {
        map.addLayer({
          id: TRAFFIC_LINE_CASING,
          type: "line",
          source: TRAFFIC_LINE_SRC,
          layout: { "line-cap": "round", "line-join": "round" },
          paint: {
            "line-color": [
              "match",
              ["get", "severity"],
              "major",
              "rgba(153,27,27,0.5)",
              "moderate",
              "rgba(146,64,14,0.4)",
              "minor",
              "rgba(30,64,175,0.3)",
              "rgba(51,65,85,0.25)",
            ],
            "line-width": ["interpolate", ["linear"], ["zoom"], 6, 6, 12, 10, 16, 16],
            "line-opacity": 0.7,
          },
        });
      }

      if (!map.getLayer(TRAFFIC_LINE_LAYER)) {
        map.addLayer({
          id: TRAFFIC_LINE_LAYER,
          type: "line",
          source: TRAFFIC_LINE_SRC,
          layout: { "line-cap": "round", "line-join": "round" },
          paint: {
            "line-color": ["match", ["get", "severity"], "major", "#ef4444", "moderate", "#f59e0b", "minor", "#3b82f6", "#64748b"],
            "line-width": ["interpolate", ["linear"], ["zoom"], 6, 4, 12, 7, 16, 12],
            "line-opacity": 0.85,
            "line-dasharray": [2, 1.5],
          },
        });
      }

      // Pulsing halo behind traffic point icons
      if (!map.getLayer(TRAFFIC_PULSE_LAYER)) {
        map.addLayer({
          id: TRAFFIC_PULSE_LAYER,
          type: "circle",
          source: TRAFFIC_POINT_SRC,
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 6, 14, 12, 20, 16, 26],
            "circle-color": [
              "match",
              ["get", "severity"],
              "major",
              "rgba(239,68,68,0.18)",
              "moderate",
              "rgba(245,158,11,0.14)",
              "rgba(100,116,139,0.08)",
            ],
            "circle-stroke-color": [
              "match",
              ["get", "severity"],
              "major",
              "rgba(239,68,68,0.35)",
              "moderate",
              "rgba(245,158,11,0.28)",
              "rgba(100,116,139,0.18)",
            ],
            "circle-stroke-width": 2,
            "circle-opacity": 0.9,
          },
        });
      }

      if (!map.getLayer(TRAFFIC_POINT_LAYER)) {
        map.addLayer({
          id: TRAFFIC_POINT_LAYER,
          type: "symbol",
          source: TRAFFIC_POINT_SRC,
          layout: {
            "icon-image": ["get", "iconId"],
            "icon-size": ["interpolate", ["linear"], ["zoom"], 6, 0.7, 12, 0.9, 16, 1.1],
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
          paint: { "icon-opacity": 1 },
        });
      }

      // Traffic click → popup
      map.on("click", TRAFFIC_POINT_LAYER, (e: any) => {
        const f = e?.features?.[0];
        if (!f) return;
        const p = f.properties;
        const sevColor = TRAFFIC_SEV_COLORS[p?.severity ?? "unknown"] ?? "#64748b";
        const html = buildOverlayPopupHtml(p?.headline ?? "Traffic Event", p?.severity ?? "unknown", sevColor);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
        onTrafficPressRef.current?.(p?.id);
      });

      /* ── 3. Hazard overlay layers ──────────────────────────────────── */
      addOrUpdateGeoJsonSource(map, HAZARD_POLY_SRC, hazardPolyFC);
      addOrUpdateGeoJsonSource(map, HAZARD_POINT_SRC, hazardPtFC);

      if (!map.getLayer(HAZARD_POLY_LAYER)) {
        map.addLayer({
          id: HAZARD_POLY_LAYER,
          type: "fill",
          source: HAZARD_POLY_SRC,
          paint: {
            "fill-color": [
              "match",
              ["get", "kind"],
              "flood",    "rgba(59,130,246,0.20)",
              "fire",     "rgba(239,68,68,0.20)",
              "cyclone",  "rgba(124,58,237,0.18)",
              "storm",    "rgba(99,102,241,0.16)",
              "heat",     "rgba(234,88,12,0.16)",
              "wind",     "rgba(100,116,139,0.14)",
              "marine",   "rgba(14,165,233,0.14)",
              // Fallback to severity-based coloring for unknown kinds
              [
                "match",
                ["get", "severity"],
                "high",   "rgba(220,38,38,0.18)",
                "medium", "rgba(234,88,12,0.14)",
                "low",    "rgba(37,99,235,0.10)",
                "rgba(100,116,139,0.06)",
              ],
            ],
            "fill-opacity": 0.75,
          },
        });
      }
      if (!map.getLayer(HAZARD_POLY_OUTLINE)) {
        map.addLayer({
          id: HAZARD_POLY_OUTLINE,
          type: "line",
          source: HAZARD_POLY_SRC,
          paint: {
            "line-color": [
              "match",
              ["get", "kind"],
              "flood",    "rgba(59,130,246,0.55)",
              "fire",     "rgba(239,68,68,0.60)",
              "cyclone",  "rgba(124,58,237,0.55)",
              "storm",    "rgba(99,102,241,0.50)",
              "heat",     "rgba(234,88,12,0.50)",
              "wind",     "rgba(100,116,139,0.45)",
              "marine",   "rgba(14,165,233,0.45)",
              [
                "match",
                ["get", "severity"],
                "high",   "rgba(220,38,38,0.6)",
                "medium", "rgba(234,88,12,0.5)",
                "low",    "rgba(37,99,235,0.4)",
                "rgba(100,116,139,0.3)",
              ],
            ],
            "line-width": 2.5,
            "line-dasharray": [3, 2],
            "line-opacity": 0.85,
          },
        });
      }

      if (!map.getLayer(HAZARD_ICON_LAYER)) {
        map.addLayer({
          id: HAZARD_ICON_LAYER,
          type: "symbol",
          source: HAZARD_POINT_SRC,
          layout: {
            "icon-image": ["get", "iconId"],
            "icon-size": ["interpolate", ["linear"], ["zoom"], 6, 0.7, 12, 0.9, 16, 1.1],
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
          paint: { "icon-opacity": 1 },
        });
      }

      // Hazard click → popup
      map.on("click", HAZARD_ICON_LAYER, (e: any) => {
        const f = e?.features?.[0];
        if (!f) return;
        const p = f.properties;
        const sevColor = HAZARD_SEV_COLORS[p?.severity ?? "unknown"] ?? "#64748b";
        const html = buildOverlayPopupHtml(p?.title ?? "Hazard", p?.severity ?? "unknown", sevColor);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
        onHazardPressRef.current?.(p?.id);
      });

      // Traffic line click → popup
      map.on("click", TRAFFIC_LINE_LAYER, (e: any) => {
        const f = e?.features?.[0];
        if (!f) return;
        const p = f.properties;
        const sevColor = TRAFFIC_SEV_COLORS[p?.severity ?? "unknown"] ?? "#64748b";
        const html = buildOverlayPopupHtml(p?.headline ?? "Traffic Event", p?.severity ?? "unknown", sevColor);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
        onTrafficPressRef.current?.(p?.id);
      });

      // Traffic polygon click → popup
      map.on("click", TRAFFIC_POLY_LAYER, (e: any) => {
        const f = e?.features?.[0];
        if (!f) return;
        const p = f.properties;
        const sevColor = TRAFFIC_SEV_COLORS[p?.severity ?? "unknown"] ?? "#64748b";
        const html = buildOverlayPopupHtml(p?.headline ?? "Traffic Event", p?.severity ?? "unknown", sevColor);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
        onTrafficPressRef.current?.(p?.id);
      });

      // Hazard polygon click → popup
      map.on("click", HAZARD_POLY_LAYER, (e: any) => {
        const f = e?.features?.[0];
        if (!f) return;
        const p = f.properties;
        const sevColor = HAZARD_SEV_COLORS[p?.severity ?? "unknown"] ?? "#64748b";
        const html = buildOverlayPopupHtml(p?.title ?? "Hazard Zone", p?.severity ?? "unknown", sevColor, null);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
        onHazardPressRef.current?.(p?.id);
      });

      map.on("mouseenter", TRAFFIC_POINT_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", TRAFFIC_POINT_LAYER, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", TRAFFIC_LINE_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", TRAFFIC_LINE_LAYER, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", TRAFFIC_POLY_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", TRAFFIC_POLY_LAYER, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", HAZARD_ICON_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", HAZARD_ICON_LAYER, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", HAZARD_POLY_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", HAZARD_POLY_LAYER, () => (map.getCanvas().style.cursor = ""));
      /* ── 4. Suggestions (clustered + icon layer) ───────────────────── */
      addOrUpdateGeoJsonSource(map, SUG_SRC, sugFC, { cluster: true, clusterMaxZoom: 13, clusterRadius: 50 });

      if (!map.getLayer(SUG_CLUSTER_CIRCLE)) {
        map.addLayer({
          id: SUG_CLUSTER_CIRCLE,
          type: "circle",
          source: SUG_SRC,
          filter: ["has", "point_count"],
          paint: {
            "circle-color": ["step", ["get", "point_count"], "rgba(74,108,83,0.88)", 20, "rgba(180,83,9,0.88)", 100, "rgba(184,74,57,0.88)"],
            "circle-radius": ["step", ["get", "point_count"], 16, 20, 20, 100, 26],
            "circle-stroke-color": "rgba(255,255,255,0.3)",
            "circle-stroke-width": 2,
            "circle-opacity": 0.92,
          },
        });
      }
      if (!map.getLayer(SUG_CLUSTER_COUNT)) {
        map.addLayer({
          id: SUG_CLUSTER_COUNT,
          type: "symbol",
          source: SUG_SRC,
          filter: ["has", "point_count"],
          layout: { "text-field": ["get", "point_count_abbreviated"], "text-font": ["Noto Sans Bold"], "text-size": 12, "text-allow-overlap": true },
          paint: { "text-color": "#ffffff" },
        });
      }

      if (!map.getLayer(SUG_UNCLUSTERED)) {
        map.addLayer({
          id: SUG_UNCLUSTERED,
          type: "circle",
          source: SUG_SRC,
          filter: ["!", ["has", "point_count"]],
          paint: {
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              8,
              ["match", ["get", "sizeClass"], "lg", 6, "md", 4, 3],
              12,
              ["match", ["get", "sizeClass"], "lg", 9, "md", 7, 5],
              16,
              ["match", ["get", "sizeClass"], "lg", 12, "md", 10, 8],
            ],
            "circle-color": ["get", "color"],
            "circle-stroke-color": ["case", ["==", ["get", "id"], props.focusedSuggestionId ?? ""], "rgba(255,255,255,0.95)", "rgba(0,0,0,0.3)"],
            "circle-stroke-width": ["case", ["==", ["get", "id"], props.focusedSuggestionId ?? ""], 2.5, 1.2],
            "circle-opacity": 0.92,
          },
        });
      }

      if (!map.getLayer(SUG_ICON_LAYER)) {
        map.addLayer({
          id: SUG_ICON_LAYER,
          type: "symbol",
          source: SUG_SRC,
          filter: ["!", ["has", "point_count"]],
          minzoom: 10,
          layout: {
            "icon-image": ["get", "iconId"],
            "icon-size": ["interpolate", ["linear"], ["zoom"], 10, 0.55, 14, 0.8, 18, 1.0],
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
          paint: { "icon-opacity": 1 },
        });
      }

      if (!map.getLayer(SUG_LABEL_LAYER)) {
        map.addLayer({
          id: SUG_LABEL_LAYER,
          type: "symbol",
          source: SUG_SRC,
          filter: ["!", ["has", "point_count"]],
          minzoom: 13,
          layout: {
            "text-field": ["get", "name"],
            "text-font": ["Noto Sans Regular"],
            "text-size": ["interpolate", ["linear"], ["zoom"], 13, 10, 16, 13],
            "text-offset": [0, 1.4],
            "text-anchor": "top",
            "text-max-width": 10,
            "text-optional": true,
            "text-allow-overlap": false,
          },
          paint: { "text-color": "rgba(255,255,255,0.9)", "text-halo-color": "rgba(0,0,0,0.7)", "text-halo-width": 1.2 },
        });
      }

      // Cluster click → expand
      map.on("click", SUG_CLUSTER_CIRCLE, (e: any) => {
        const features = map.queryRenderedFeatures(e.point, { layers: [SUG_CLUSTER_CIRCLE] });
        if (!features.length) return;
        const clusterId = features[0].properties?.cluster_id;
        if (clusterId == null) return;
        const source = map.getSource(SUG_SRC) as any;
        if (!source?.getClusterExpansionZoom) return;
        source.getClusterExpansionZoom(clusterId, (err: any, zoom: number) => {
          if (err) return;
          const coords = (features[0].geometry as any)?.coordinates;
          if (coords) map.easeTo({ center: coords, zoom: Math.min(zoom, 16), duration: 350 });
        });
      });

      // Suggestion click → popup
      const handleSugClick = (e: any) => {
        const f = e?.features?.[0];
        const id = f?.properties?.id ? String(f.properties.id) : null;
        if (!id) return;
        const coords = (f.geometry as any)?.coordinates;
        if (Array.isArray(coords) && coords.length === 2) easeToCoord(map, [Number(coords[0]), Number(coords[1])], { zoom: Math.max(map.getZoom(), 13), duration: 420 });
        onSugPressRef.current?.(id);
        const html = buildSuggestionPopupHtml(f?.properties?.name ?? "", f?.properties?.category ?? "", id);
        try {
          popupRef.current?.remove();
          popupRef.current = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: "trip-map-popup", maxWidth: "280px" })
            .setLngLat(e.lngLat)
            .setHTML(html)
            .addTo(map);
        } catch {}
      };
      map.on("click", SUG_UNCLUSTERED, handleSugClick);
      map.on("click", SUG_ICON_LAYER, handleSugClick);

      map.on("mouseenter", SUG_CLUSTER_CIRCLE, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", SUG_CLUSTER_CIRCLE, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", SUG_UNCLUSTERED, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", SUG_UNCLUSTERED, () => (map.getCanvas().style.cursor = ""));
      map.on("mouseenter", SUG_ICON_LAYER, () => (map.getCanvas().style.cursor = "pointer"));
      map.on("mouseleave", SUG_ICON_LAYER, () => (map.getCanvas().style.cursor = ""));

      /* ── 5. Stop layers — beautiful themed markers ─────────────────── */
      addOrUpdateGeoJsonSource(map, STOPS_SRC, stopsFC);

      const stopColor = ["match", ["get", "type"], "start", "#16a34a", "end", "#dc2626", "via", "#9333ea", "#2563eb"] as any;

      // Drop shadow circle (subtle, larger, behind)
      if (!map.getLayer(STOPS_SHADOW)) {
        map.addLayer({
          id: STOPS_SHADOW,
          type: "circle",
          source: STOPS_SRC,
          minzoom: 5,
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 5, 6, 10, 10, 14, 15, 17, 20],
            "circle-color": "rgba(0,0,0,0.25)",
            "circle-blur": 0.6,
            "circle-translate": [0, 2],
          },
        });
      }

      // Outer ring — white border with themed color
      if (!map.getLayer(STOPS_OUTER)) {
        map.addLayer({
          id: STOPS_OUTER,
          type: "circle",
          source: STOPS_SRC,
          minzoom: 3,
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 3, 4, 6, 5.5, 10, 8, 14, 12, 17, 16],
            "circle-color": "#fff",
            "circle-stroke-color": stopColor,
            "circle-stroke-width": ["interpolate", ["linear"], ["zoom"], 3, 1.5, 10, 2.5, 14, 3.5],
            "circle-opacity": 1,
          },
        });
      }

      // Inner filled circle — themed color
      if (!map.getLayer(STOPS_INNER)) {
        map.addLayer({
          id: STOPS_INNER,
          type: "circle",
          source: STOPS_SRC,
          minzoom: 3,
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 3, 2.5, 6, 3.5, 10, 5.5, 14, 8, 17, 11],
            "circle-color": stopColor,
            "circle-opacity": 1,
          },
        });
      }

      // Subtle pulse on start/end at higher zooms
      if (!map.getLayer(STOP_PULSE)) {
        map.addLayer({
          id: STOP_PULSE,
          type: "circle",
          source: STOPS_SRC,
          minzoom: 8,
          filter: ["any", ["==", ["get", "type"], "start"], ["==", ["get", "type"], "end"]],
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 8, 14, 14, 22],
            "circle-color": "transparent",
            "circle-stroke-color": ["match", ["get", "type"], "start", "rgba(22,163,74,0.2)", "end", "rgba(220,38,38,0.2)", "transparent"],
            "circle-stroke-width": 2,
            "circle-opacity": 0.8,
          },
        });
      }

      // Icon symbols on stops (at higher zoom)
      if (!map.getLayer(STOP_ICON_LAYER)) {
        map.addLayer({
          id: STOP_ICON_LAYER,
          type: "symbol",
          source: STOPS_SRC,
          minzoom: 11,
          layout: {
            "icon-image": ["get", "iconId"],
            "icon-size": ["interpolate", ["linear"], ["zoom"], 11, 0.45, 14, 0.65, 17, 0.85],
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
          paint: { "icon-opacity": ["interpolate", ["linear"], ["zoom"], 11, 0.4, 13, 0.9] },
        });
      }

      // Labels
      if (!map.getLayer(STOP_LABELS)) {
        map.addLayer({
          id: STOP_LABELS,
          type: "symbol",
          source: STOPS_SRC,
          minzoom: 9,
          layout: {
            "text-field": ["get", "name"],
            "text-font": ["Noto Sans Bold"],
            "text-size": ["interpolate", ["linear"], ["zoom"], 9, 10, 14, 13, 16, 15],
            "text-offset": [0, 1.6],
            "text-anchor": "top",
            "text-max-width": 8,
            "text-optional": true,
            "text-allow-overlap": false,
          },
          paint: { "text-color": "rgba(255,255,255,0.95)", "text-halo-color": "rgba(0,0,0,0.75)", "text-halo-width": 1.5 },
        });
      }

      // Focus ring — animated outer highlight
      if (!map.getLayer(STOP_FOCUS_RING)) {
        map.addLayer({
          id: STOP_FOCUS_RING,
          type: "circle",
          source: STOPS_SRC,
          filter: ["==", ["get", "id"], props.focusedStopId ?? ""],
          paint: {
            "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 10, 10, 14, 14, 20, 17, 26],
            "circle-color": "transparent",
            "circle-stroke-color": "rgba(255,255,255,0.85)",
            "circle-stroke-width": 2.5,
            "circle-opacity": 1,
          },
        });
      }

      registerStopClick(STOPS_SHADOW);
      registerStopClick(STOPS_OUTER);
      registerStopClick(STOPS_INNER);

      /* ── 6. User location layers ───────────────────────────────────── */
      addOrUpdateGeoJsonSource(map, USER_LOC_SRC, userLocFC);
      addOrUpdateGeoJsonSource(map, USER_LOC_HEADING_SRC, headingFC);

      if (!map.getLayer(USER_LOC_ACCURACY)) {
        map.addLayer({
          id: USER_LOC_ACCURACY,
          type: "circle",
          source: USER_LOC_SRC,
          paint: {
            "circle-radius": 30,
            "circle-color": "rgba(37,99,235,0.07)",
            "circle-stroke-color": "rgba(37,99,235,0.22)",
            "circle-stroke-width": 1.5,
            "circle-opacity": 1,
          },
        });
      }

      if (!map.getLayer(USER_LOC_HEADING)) {
        map.addLayer({
          id: USER_LOC_HEADING,
          type: "symbol",
          source: USER_LOC_HEADING_SRC,
          layout: {
            "icon-image": HEADING_ARROW_ID,
            "icon-size": ["interpolate", ["linear"], ["zoom"], 6, 0.6, 14, 1.0, 18, 1.3],
            "icon-rotate": ["get", "heading"],
            "icon-rotation-alignment": "map",
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
          paint: { "icon-opacity": 0.9 },
        });
      }
      if (!map.getLayer(USER_LOC_DOT_OUTER)) {
        map.addLayer({
          id: USER_LOC_DOT_OUTER,
          type: "circle",
          source: USER_LOC_SRC,
          paint: { "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 6, 10, 9, 16, 12], "circle-color": "#ffffff", "circle-opacity": 0.95 },
        });
      }
      if (!map.getLayer(USER_LOC_DOT_INNER)) {
        map.addLayer({
          id: USER_LOC_DOT_INNER,
          type: "circle",
          source: USER_LOC_SRC,
          paint: { "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 4, 10, 6.5, 16, 9], "circle-color": "#2563eb", "circle-opacity": 1 },
        });
      }

      // ── Fuel station layers ──
      if (!map.getSource(FUEL_SRC)) {
        map.addSource(FUEL_SRC, { type: "geojson", data: fuelFC });
      } else {
        const s: any = map.getSource(FUEL_SRC);
        s?.setData?.(fuelFC);
      }

      if (!map.getLayer(FUEL_CIRCLE_LAYER)) {
        map.addLayer({
          id: FUEL_CIRCLE_LAYER,
          type: "circle",
          source: FUEL_SRC,
          paint: {
            "circle-radius": 12,
            "circle-color": "rgba(0,0,0,0.08)",
            "circle-blur": 0.6,
          },
        });
      }

      if (!map.getLayer(FUEL_ICON_LAYER)) {
        map.addLayer({
          id: FUEL_ICON_LAYER,
          type: "symbol",
          source: FUEL_SRC,
          layout: {
            "icon-image": ["match", ["get", "fuel_level"], "warn", "roam-fuel-warn", "critical", "roam-fuel-critical", "roam-fuel-ok"],
            "icon-size": 1,
            "icon-allow-overlap": true,
            "icon-ignore-placement": true,
          },
        });
      }

      if (!map.getLayer(FUEL_LABEL_LAYER)) {
        map.addLayer({
          id: FUEL_LABEL_LAYER,
          type: "symbol",
          source: FUEL_SRC,
          layout: {
            "text-field": ["get", "name"],
            "text-font": ["Open Sans Bold"],
            "text-size": 10,
            "text-offset": [0, 1.8],
            "text-anchor": "top",
            "text-max-width": 8,
          },
          paint: {
            "text-color": "#1a1a1a",
            "text-halo-color": "rgba(255,255,255,0.9)",
            "text-halo-width": 1.5,
          },
          minzoom: 9,
        });
      }

      // Initial fit
      try {
        map.fitBounds(bboxToBounds(props.bbox), { padding: 60, duration: 0 });
      } catch {}
    });

    // Accuracy ring radius on zoom
    map.on("zoom", () => {
      if (accuracyAnimFrame.current) cancelAnimationFrame(accuracyAnimFrame.current);
      accuracyAnimFrame.current = requestAnimationFrame(() => {
        if (!map.getLayer(USER_LOC_ACCURACY)) return;
        const pos = props.userPosition;
        if (!pos) return;
        map.setPaintProperty(USER_LOC_ACCURACY, "circle-radius", accuracyToPixels(pos.accuracy, pos.lat, map.getZoom()));
      });
    });

    return () => {
      if (accuracyAnimFrame.current) cancelAnimationFrame(accuracyAnimFrame.current);
      try {
        popupRef.current?.remove();
      } catch {}
      try {
        map.remove();
      } catch {}
      try {
        if (protocolRef.current) maplibregl.removeProtocol("pmtiles");
      } catch {}
      mapRef.current = null;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /* ── Style change ───────────────────────────────────────────────────── */
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const origin = typeof window !== "undefined" ? window.location.origin : "";
    (async () => {
      try {
        const res = await fetch(assetsApi.styleUrl(props.styleId));
        let styleJson = await res.json();
        if (isFullyOfflineCapable()) {
          styleJson = rewriteStyleForLocalServer(styleJson);
        }
        map.setStyle(rewriteStyleForPMTiles(styleJson, origin), { diff: false });
      } catch (e) {
        console.error("[TripMap] style load failed", e);
      }
    })();
  }, [props.styleId]);

  /* ── Data updates ───────────────────────────────────────────────────── */
  useEffect(() => {
    const s: any = mapRef.current?.getSource(ROUTE_SRC);
    s?.setData?.(routeFC);
  }, [routeFC]);
  useEffect(() => {
    const s: any = mapRef.current?.getSource(STOPS_SRC);
    s?.setData?.(stopsFC);
  }, [stopsFC]);

  useEffect(() => {
    const s: any = mapRef.current?.getSource(FUEL_SRC);
    s?.setData?.(fuelFC);
  }, [fuelFC]);

  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    if (map.getLayer(STOP_FOCUS_RING)) map.setFilter(STOP_FOCUS_RING, ["==", ["get", "id"], props.focusedStopId ?? ""]);
  }, [props.focusedStopId]);

  useEffect(() => {
    const s: any = mapRef.current?.getSource(SUG_SRC);
    s?.setData?.(sugFC);
  }, [sugFC]);

  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const s1: any = map.getSource(TRAFFIC_POINT_SRC);
    s1?.setData?.(trafficPtFC);
    const s2: any = map.getSource(TRAFFIC_LINE_SRC);
    s2?.setData?.(trafficLineFC);
    const s3: any = map.getSource(TRAFFIC_POLY_SRC);
    s3?.setData?.(trafficPolyFC);
  }, [trafficPtFC, trafficLineFC, trafficPolyFC]);

  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const s1: any = map.getSource(HAZARD_POINT_SRC);
    s1?.setData?.(hazardPtFC);
    const s2: any = map.getSource(HAZARD_POLY_SRC);
    s2?.setData?.(hazardPolyFC);
  }, [hazardPtFC, hazardPolyFC]);

  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const locSrc: any = map.getSource(USER_LOC_SRC);
    if (locSrc?.setData) locSrc.setData(userLocFC);
    const headSrc: any = map.getSource(USER_LOC_HEADING_SRC);
    if (headSrc?.setData) headSrc.setData(headingFC);
    const pos = props.userPosition;
    if (pos && map.getLayer(USER_LOC_ACCURACY)) {
      map.setPaintProperty(USER_LOC_ACCURACY, "circle-radius", accuracyToPixels(pos.accuracy, pos.lat, map.getZoom()));
    }
  }, [userLocFC, headingFC, props.userPosition]);

  /* ── Focus stop → ease ──────────────────────────────────────────────── */
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const id = props.focusedStopId ?? null;
    if (!id) return;
    const s = (props.stops ?? []).find((x) => String(x.id) === String(id));
    if (s) easeToCoord(map, [s.lng, s.lat], { zoom: Math.max(map.getZoom(), 12), duration: 420 });
  }, [props.focusedStopId, props.stops]);

  /* ── Focus suggestion → zoom/focus ──────────────────────────────────── */
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const id = props.focusedSuggestionId ?? null;
    if (!id) return;
    const p = (props.suggestions ?? []).find((x) => String(x.id) === String(id));
    if (p) {
      easeToCoord(map, [p.lng, p.lat], { zoom: Math.max(map.getZoom(), 13), duration: 420 });
      return;
    }
    try {
      const feats = map.querySourceFeatures(SUG_SRC);
      for (const f of feats as any[]) {
        if (f?.properties?.id && String(f.properties.id) === id) {
          const coords = (f.geometry as any)?.coordinates;
          if (Array.isArray(coords) && coords.length === 2) {
            easeToCoord(map, [Number(coords[0]), Number(coords[1])], { zoom: Math.max(map.getZoom(), 13), duration: 420 });
            break;
          }
        }
      }
    } catch {}
  }, [props.focusedSuggestionId, props.suggestions]);

  /* ── Highlighted alert → in-place pulse ring (no camera move) ────────── */
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const id = props.highlightedAlertId ?? null;
    const emptyFC: GeoJSON.FeatureCollection = { type: "FeatureCollection", features: [] };

    if (!id) {
      const src = map.getSource(ALERT_HIGHLIGHT_SRC) as any;
      if (src?.setData) src.setData(emptyFC);
      return;
    }

    let coord: [number, number] | null = null;
    for (const srcId of [TRAFFIC_POINT_SRC, HAZARD_POINT_SRC]) {
      try {
        const feats = (map.getSource(srcId) as any)?._data?.features ?? [];
        for (const f of feats) {
          if (f?.properties?.id === id && f?.geometry?.type === "Point") {
            coord = f.geometry.coordinates as [number, number];
            break;
          }
        }
      } catch {}
      if (coord) break;
    }

    if (!coord) {
      const src = map.getSource(ALERT_HIGHLIGHT_SRC) as any;
      if (src?.setData) src.setData(emptyFC);
      return;
    }

    const fc: GeoJSON.FeatureCollection = {
      type: "FeatureCollection",
      features: [{ type: "Feature", geometry: { type: "Point", coordinates: coord }, properties: {} }],
    };

    if (!map.getSource(ALERT_HIGHLIGHT_SRC)) {
      map.addSource(ALERT_HIGHLIGHT_SRC, { type: "geojson", data: fc });
    } else {
      (map.getSource(ALERT_HIGHLIGHT_SRC) as any).setData(fc);
    }

    if (!map.getLayer(ALERT_HIGHLIGHT_PING)) {
      map.addLayer({
        id: ALERT_HIGHLIGHT_PING,
        type: "circle",
        source: ALERT_HIGHLIGHT_SRC,
        paint: { "circle-radius": 0, "circle-color": "transparent", "circle-stroke-color": "rgba(239,68,68,0.6)", "circle-stroke-width": 2, "circle-opacity": 1 },
      });
    }

    if (!map.getLayer(ALERT_HIGHLIGHT_RING)) {
      map.addLayer({
        id: ALERT_HIGHLIGHT_RING,
        type: "circle",
        source: ALERT_HIGHLIGHT_SRC,
        paint: { "circle-radius": 18, "circle-color": "rgba(239,68,68,0.12)", "circle-stroke-color": "rgba(239,68,68,0.7)", "circle-stroke-width": 2.5 },
      });
    }

    let frame = 0;
    let raf: number;
    const animate = () => {
      frame++;
      const t = (frame % 60) / 60;
      const radius = 18 + t * 24;
      const opacity = 1 - t;
      try {
        map.setPaintProperty(ALERT_HIGHLIGHT_PING, "circle-radius", radius);
        map.setPaintProperty(ALERT_HIGHLIGHT_PING, "circle-stroke-color", `rgba(239,68,68,${(0.6 * opacity).toFixed(2)})`);
      } catch {}
      raf = requestAnimationFrame(animate);
    };
    raf = requestAnimationFrame(animate);

    return () => {
      cancelAnimationFrame(raf);
    };
  }, [props.highlightedAlertId]);
  useEffect(() => {
       const map = mapRef.current;
       if (!map) return;
       if (props.mapInstanceRef) props.mapInstanceRef.current = null;
       if (props.navigationMode) return; // camera controlled by useMapNavigationMode
       try {
         map.fitBounds(bboxToBounds(props.bbox), { padding: 60, duration: 250 });
       } catch {}
     }, [props.bbox.minLat, props.bbox.minLng, props.bbox.maxLat, props.bbox.maxLng, props.navigationMode]);
  
  return (
    <div className="trip-map-fullscreen">
      <div ref={containerRef} className="trip-map-inner" />
      <style>{`
        .trip-map-popup .maplibregl-popup-content {
          border-radius: 16px;
          padding: 14px 16px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.15);
          background: var(--roam-surface);
          color: var(--roam-text);
          backdrop-filter: blur(12px);
          -webkit-backdrop-filter: blur(12px);
        }
        .trip-map-popup .maplibregl-popup-close-button {
          font-size: 18px;
          font-weight: 900;
          color: var(--roam-text-muted);
          padding: 4px 8px;
          border-radius: 8px;
        }
        .trip-map-popup .maplibregl-popup-close-button:hover {
          background: var(--roam-surface-hover);
          color: var(--roam-text);
        }
        .trip-map-popup .maplibregl-popup-tip {
          border-top-color: var(--roam-surface);
        }
      `}</style>
    </div>
  );
}


===== src/components/trip/TripSuggestionsPanel.tsx =====

// src/components/trip/TripSuggestionsPanel.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import type { PlaceCategory, PlaceItem, PlacesPack } from "@/lib/types/places";
import { haptic } from "@/lib/native/haptics";

import type { LucideIcon } from "lucide-react";
import {
  Search,
  Layers,
  Fuel,
  Zap,
  ParkingMeter,
  Bath,
  Droplets,
  Trash2,
  Wrench,
  Hospital,
  Pill,
  ShoppingCart,
  Building2,
  Banknote,
  Shirt,
  Star,
  Coffee,
  Utensils,
  Beer,
  Wine,
  Tent,
  Bed,
  Eye,
  Waves,
  Mountain,
  TreePine,
  Thermometer,
  Baby,
  Compass,
  Info,
  Landmark,
  Camera,
  Store,
  MapPin,
} from "lucide-react";

function fmtCat(c: PlaceCategory) {
  return c.replace(/_/g, " ");
}

// ──────────────────────────────────────────────────────────────
// All categories — matches backend _CORRIDOR_DEFAULT_CATS exactly.
// Organised: safety → supplies → food → accommodation →
// nature → family → culture → geocoding
// ──────────────────────────────────────────────────────────────

const ALL_CATS: PlaceCategory[] = [
  // Essentials & safety
  "fuel", "ev_charging", "rest_area", "toilet", "water",
  "dump_point", "mechanic", "hospital", "pharmacy",
  // Supplies
  "grocery", "town", "atm", "laundromat",
  // Food & drink
  "bakery", "cafe", "restaurant", "fast_food", "pub", "bar",
  // Accommodation
  "camp", "hotel", "motel", "hostel",
  // Nature & outdoors
  "viewpoint", "waterfall", "swimming_hole", "beach",
  "national_park", "hiking", "picnic", "hot_spring",
  // Family & recreation
  "playground", "pool", "zoo", "theme_park",
  // Culture & sightseeing
  "visitor_info", "museum", "gallery", "heritage",
  "winery", "brewery", "attraction", "market", "park",
];

// ──────────────────────────────────────────────────────────────
// Chip config — icon + label for the filter bar
// ──────────────────────────────────────────────────────────────

type ChipDef = { key: PlaceCategory | "all"; label: string; Icon: LucideIcon };

const CHIP_DEFS: ChipDef[] = [
  { key: "all",           label: "All",         Icon: Layers },
  // Safety & essentials
  { key: "fuel",          label: "Fuel",        Icon: Fuel },
  { key: "ev_charging",   label: "EV",          Icon: Zap },
  { key: "rest_area",     label: "Rest",        Icon: ParkingMeter },
  { key: "toilet",        label: "Toilets",     Icon: Bath },
  { key: "water",         label: "Water",       Icon: Droplets },
  { key: "dump_point",    label: "Dump",        Icon: Trash2 },
  { key: "mechanic",      label: "Mechanic",    Icon: Wrench },
  { key: "hospital",      label: "Hospital",    Icon: Hospital },
  { key: "pharmacy",      label: "Pharmacy",    Icon: Pill },
  // Supplies
  { key: "grocery",       label: "Grocery",     Icon: ShoppingCart },
  { key: "town",          label: "Towns",       Icon: Building2 },
  { key: "atm",           label: "ATM",         Icon: Banknote },
  { key: "laundromat",    label: "Laundry",     Icon: Shirt },
  // Food & drink
  { key: "bakery",        label: "Bakery",      Icon: Star },
  { key: "cafe",          label: "Café",        Icon: Coffee },
  { key: "restaurant",    label: "Food",        Icon: Utensils },
  { key: "fast_food",     label: "Takeaway",    Icon: Utensils },
  { key: "pub",           label: "Pub",         Icon: Beer },
  { key: "bar",           label: "Bar",         Icon: Beer },
  // Accommodation
  { key: "camp",          label: "Camp",        Icon: Tent },
  { key: "hotel",         label: "Hotel",       Icon: Bed },
  { key: "motel",         label: "Motel",       Icon: Bed },
  { key: "hostel",        label: "Hostel",      Icon: Bed },
  // Nature & outdoors
  { key: "viewpoint",     label: "Views",       Icon: Eye },
  { key: "waterfall",     label: "Waterfall",   Icon: Waves },
  { key: "swimming_hole", label: "Swim",        Icon: Waves },
  { key: "beach",         label: "Beach",       Icon: Waves },
  { key: "national_park", label: "Nat Parks",   Icon: TreePine },
  { key: "hiking",        label: "Hiking",      Icon: Mountain },
  { key: "picnic",        label: "Picnic",      Icon: TreePine },
  { key: "hot_spring",    label: "Hot Spring",  Icon: Thermometer },
  // Family & recreation
  { key: "playground",    label: "Kids",        Icon: Baby },
  { key: "pool",          label: "Pool",        Icon: Waves },
  { key: "zoo",           label: "Zoo",         Icon: Compass },
  { key: "theme_park",    label: "Theme Park",  Icon: Star },
  // Culture & sightseeing
  { key: "visitor_info",  label: "Info",        Icon: Info },
  { key: "museum",        label: "Museum",      Icon: Landmark },
  { key: "gallery",       label: "Gallery",     Icon: Landmark },
  { key: "heritage",      label: "Heritage",    Icon: Landmark },
  { key: "winery",        label: "Wine",        Icon: Wine },
  { key: "brewery",       label: "Brew",        Icon: Beer },
  { key: "attraction",    label: "Sights",      Icon: Camera },
  { key: "market",        label: "Market",      Icon: Store },
  { key: "park",          label: "Park",        Icon: TreePine },
];

const CATEGORY_ICON: Record<string, LucideIcon> = {};
for (const c of CHIP_DEFS) CATEGORY_ICON[c.key] = c.Icon;

// ──────────────────────────────────────────────────────────────
// Score: priority sort when no search query is active.
// Higher score → shown first.
// Tuned for Australian road trips: fuel/water/rest are king,
// then food, sleep, nature discoveries, then everything else.
// ──────────────────────────────────────────────────────────────

function scorePlace(p: PlaceItem): number {
  const cat = String(p.category ?? "");

  // ── Essentials & safety ─────────────────────────────────
  if (cat === "fuel")          return 100;
  if (cat === "ev_charging")   return 98;
  if (cat === "water")         return 95;
  if (cat === "rest_area")     return 93;
  if (cat === "toilet")        return 90;
  if (cat === "hospital")      return 88;
  if (cat === "pharmacy")      return 85;
  if (cat === "mechanic")      return 83;
  if (cat === "dump_point")    return 80;

  // ── Anchor towns ────────────────────────────────────────
  if (cat === "town")          return 78;

  // ── Supplies ────────────────────────────────────────────
  if (cat === "grocery")       return 75;
  if (cat === "atm")           return 60;
  if (cat === "laundromat")    return 55;

  // ── Food & drink ────────────────────────────────────────
  if (cat === "bakery")        return 72;
  if (cat === "cafe")          return 70;
  if (cat === "restaurant")    return 68;
  if (cat === "fast_food")     return 65;
  if (cat === "pub")           return 62;
  if (cat === "bar")           return 58;

  // ── Accommodation ───────────────────────────────────────
  if (cat === "camp")          return 76;
  if (cat === "motel")         return 66;
  if (cat === "hotel")         return 64;
  if (cat === "hostel")        return 56;

  // ── Nature & outdoors ───────────────────────────────────
  if (cat === "viewpoint")     return 50;
  if (cat === "national_park") return 49;
  if (cat === "waterfall")     return 48;
  if (cat === "swimming_hole") return 47;
  if (cat === "beach")         return 46;
  if (cat === "hiking")        return 45;
  if (cat === "hot_spring")    return 44;
  if (cat === "picnic")        return 42;

  // ── Family & recreation ─────────────────────────────────
  if (cat === "playground")    return 38;
  if (cat === "pool")          return 37;
  if (cat === "zoo")           return 36;
  if (cat === "theme_park")    return 35;

  // ── Culture & sightseeing ───────────────────────────────
  if (cat === "winery")        return 40;
  if (cat === "brewery")       return 39;
  if (cat === "visitor_info")  return 34;
  if (cat === "museum")        return 33;
  if (cat === "gallery")       return 32;
  if (cat === "heritage")      return 31;
  if (cat === "attraction")    return 30;
  if (cat === "market")        return 29;
  if (cat === "park")          return 28;

  return 20;
}

// ──────────────────────────────────────────────────────────────
// Component
// ──────────────────────────────────────────────────────────────

export function TripSuggestionsPanel(props: {
  places: PlacesPack;
  focusedPlaceId?: string | null;
  onFocusPlace?: (placeId: string | null) => void;
  onAddStopFromPlace?: (place: PlaceItem) => void;
  enableSearch?: boolean;
  initialCats?: PlaceCategory[];
  maxHeight?: string | number;
}) {
  const items = props.places.items ?? [];
  const [q, setQ] = useState("");

  // Default: show ALL categories (was previously a hardcoded subset of 14)
  const [activeCat, setActiveCat] = useState<PlaceCategory | "all">(
    props.initialCats?.length === 1 ? props.initialCats[0] : "all",
  );

  const listRef = useRef<HTMLDivElement | null>(null);
  const rowRefs = useRef<Map<string, HTMLDivElement>>(new Map());

  const filtered = useMemo(() => {
    const qq = q.trim().toLowerCase();
    const out = items
      .filter((p) => (activeCat === "all" ? true : p.category === activeCat))
      .filter((p) => {
        if (!qq) return true;
        return (
          (p.name ?? "").toLowerCase().includes(qq) ||
          String(p.category ?? "").toLowerCase().includes(qq)
        );
      })
      .slice(0, 1200);

    if (!qq) out.sort((a, b) => scorePlace(b) - scorePlace(a));
    return out.slice(0, 600);
  }, [items, q, activeCat]);

  // Count per category for badge display
  const categoryCounts = useMemo(() => {
    const counts: Record<string, number> = {};
    for (const p of items) {
      const cat = p.category ?? "town";
      counts[cat] = (counts[cat] ?? 0) + 1;
    }
    return counts;
  }, [items]);

  useEffect(() => {
    const id = props.focusedPlaceId ?? null;
    if (!id) return;
    const el = rowRefs.current.get(id);
    el?.scrollIntoView({ behavior: "smooth", block: "nearest" });
  }, [props.focusedPlaceId]);

  return (
    <div className="trip-flex-col">
      {/* Header and Search */}
      <div className="trip-flex-row trip-justify-between trip-align-center trip-mb-sm">
        <div>
          <h3 className="trip-title">Library</h3>
          <p className="trip-muted-small trip-mt-xs">
            {items.length} known locations
            {activeCat !== "all" ? ` · ${filtered.length} ${fmtCat(activeCat)}` : ""}
          </p>
        </div>

        {props.enableSearch && (
          <div className="trip-search-box">
            <span className="trip-search-icon">
              <Search />
            </span>
            <input
              value={q}
              onChange={(e) => setQ(e.currentTarget.value)}
              placeholder="Filter..."
              className="trip-input-borderless"
              aria-label="Search places"
            />
          </div>
        )}
      </div>

      {/* Categories Row (Horizontal Scroll) — full set with icons */}
      <div
        style={{
          display: "flex",
          gap: 8,
          overflowX: "auto",
          paddingBottom: 4,
          WebkitOverflowScrolling: "touch",
          marginBottom: 10,
        }}
      >
        {CHIP_DEFS.map((chip) => {
          const isActive = activeCat === chip.key;
          const count = chip.key === "all" ? items.length : (categoryCounts[chip.key] ?? 0);
          const CI = chip.Icon;

          // Skip chips with 0 items (except "all")
          if (chip.key !== "all" && count === 0) return null;

          return (
            <button
              key={chip.key}
              type="button"
              className="trip-interactive"
              onClick={() => {
                haptic.selection();
                setActiveCat(chip.key);
              }}
              style={{
                flex: "0 0 auto",
                borderRadius: 999,
                border: "none",
                padding: "8px 12px",
                fontSize: 13,
                fontWeight: 950,
                background: isActive
                  ? "var(--roam-surface-hover)"
                  : "var(--roam-surface)",
                color: isActive ? "var(--roam-text)" : "var(--roam-text-muted)",
                boxShadow: isActive
                  ? "var(--shadow-button)"
                  : "var(--shadow-soft)",
                display: "flex",
                gap: 6,
                alignItems: "center",
                cursor: "pointer",
                whiteSpace: "nowrap",
              }}
            >
              <CI size={14} />
              {chip.label}
              {count > 0 && chip.key !== "all" ? (
                <span
                  style={{
                    fontSize: 10,
                    fontWeight: 950,
                    background: isActive ? "var(--roam-accent)" : "rgba(0,0,0,0.06)",
                    color: isActive ? "white" : "var(--roam-text-muted)",
                    borderRadius: 999,
                    padding: "1px 5px",
                    minWidth: 16,
                    textAlign: "center",
                  }}
                >
                  {count}
                </span>
              ) : null}
            </button>
          );
        })}
      </div>

      {/* Results List */}
      <div
        ref={listRef}
        className="trip-list-compact"
        style={{ maxHeight: props.maxHeight ?? "35vh", overflowY: "auto" }}
      >
        {filtered.length ? (
          filtered.map((p) => {
            const focused = props.focusedPlaceId === p.id;
            const CatIcon = CATEGORY_ICON[p.category] ?? MapPin;
            const extra: any = p.extra ?? {};
            const suburb =
              extra["addr:suburb"] || extra["addr:city"] || extra.address;

            return (
              <div
                key={p.id}
                ref={(el) => {
                  if (el) rowRefs.current.set(p.id, el);
                  else rowRefs.current.delete(p.id);
                }}
                role="button"
                tabIndex={0}
                className="trip-list-row"
                data-focused={focused}
                onClick={() => {
                  haptic.selection();
                  props.onFocusPlace?.(p.id);
                }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    haptic.selection();
                    props.onFocusPlace?.(p.id);
                  }
                }}
              >
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    gap: 10,
                    flex: 1,
                    minWidth: 0,
                  }}
                >
                  <div
                    style={{
                      width: 30,
                      height: 30,
                      borderRadius: 8,
                      background: "var(--roam-surface-hover)",
                      display: "grid",
                      placeItems: "center",
                      flexShrink: 0,
                    }}
                  >
                    <CatIcon size={15} />
                  </div>
                  <div className="trip-list-row-content" style={{ minWidth: 0 }}>
                    <div className="trip-title trip-truncate">{p.name}</div>
                    <div className="trip-muted-small trip-truncate trip-mt-xs">
                      {fmtCat(p.category)}
                      {suburb
                        ? ` · ${typeof suburb === "string" ? suburb.split(",")[0] : suburb}`
                        : ""}
                    </div>
                  </div>
                </div>

                {props.onAddStopFromPlace && (
                  <button
                    type="button"
                    className="trip-btn-xs trip-btn-secondary"
                    onClick={(e) => {
                      e.stopPropagation();
                      haptic.tap();
                      props.onAddStopFromPlace?.(p);
                    }}
                  >
                    + Add
                  </button>
                )}
              </div>
            );
          })
        ) : (
          <div className="trip-empty-state">
            No matches found
            {activeCat !== "all" ? ` for "${fmtCat(activeCat)}"` : ""}.
            {activeCat !== "all" ? " Try All." : " Adjust filters."}
          </div>
        )}
      </div>
    </div>
  );
}

===== src/components/trip/TripView.tsx =====

// src/components/trip/TripView.tsx
"use client";

import { useEffect, useMemo, useState, useCallback } from "react";
import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay } from "@/lib/types/navigation";
import type { TripStop } from "@/lib/types/trip";
import type { PlacesPack, PlaceItem } from "@/lib/types/places";
import type { RoamPosition } from "@/lib/native/geolocation";
import type { FuelAnalysis } from "@/lib/types/fuel";
import { haptic } from "@/lib/native/haptics";
import { hideKeyboard } from "@/lib/native/keyboard";
import { shortId } from "@/lib/utils/ids";

import {
  Flag,
  MapPin,
  Diamond,
  ChevronUp,
  ChevronDown,
  X,
  Plus,
  RotateCcw,
  Save,
  Loader2,
  Route,
  Map as MapIcon,
} from "lucide-react";

import {
  useAlerts,
  NextAlertBanner,
  LegAlertStrip,
  RouteAssessment,
  type AlertHighlightEvent,
} from "@/components/trip/TripAlertsPanel";
import { TripSuggestionsPanel } from "@/components/trip/TripSuggestionsPanel";
import { FuelSummaryCard } from "@/components/fuel/FuelSummaryCard";

import s from "./Tripview.module.css";

/* ── Types ────────────────────────────────────────────────────────────── */

export type TripEditorRebuildMode = "auto" | "online" | "offline";

type ActiveSection = "route" | "places";

/* ── Helpers ──────────────────────────────────────────────────────────── */

function ensureStopIds(stops: TripStop[]): TripStop[] {
  return (stops ?? []).map((st) => (st.id ? st : { ...st, id: shortId() }));
}

function isLockedStop(st: TripStop) {
  const t = st.type ?? "poi";
  return t === "start" || t === "end";
}

function stopLabel(st: TripStop, idx: number) {
  const t = st.type ?? "poi";
  const name = st.name?.trim();
  if (name) return name;
  if (t === "start") return "Start";
  if (t === "end") return "End";
  return `Stop ${idx + 1}`;
}

function resolveType(st: TripStop): string {
  return st.type ?? "poi";
}

function StopIcon({ type, size = 15 }: { type?: string; size?: number }) {
  const props = { size, strokeWidth: 2.5 };
  switch (type) {
    case "start": return <Flag {...props} />;
    case "end":   return <Flag {...props} />;
    case "via":   return <Diamond {...props} />;
    default:      return <MapPin {...props} />;
  }
}

function formatDist(m: number): string {
  if (m < 1000) return `${Math.round(m)} m`;
  return `${(m / 1000).toFixed(1)} km`;
}

function formatDur(sec: number): string {
  const hrs = Math.floor(sec / 3600);
  const mins = Math.round((sec % 3600) / 60);
  if (hrs === 0) return `${mins} min`;
  return `${hrs}h ${mins}m`;
}

/** Join class names, filtering out falsy values */
function cx(...names: (string | false | null | undefined)[]): string {
  return names.filter(Boolean).join(" ");
}

/* ── Component ────────────────────────────────────────────────────────── */

export function TripView({
  planId,
  navpack,
  corridor,
  places,
  traffic,
  hazards,
  focusedStopId,
  onFocusStop,
  focusedPlaceId,
  onFocusPlace,
  onRebuildRequested,
  onAddSuggestion,
  highlightedAlertId,
  onHighlightAlert,
  userPosition,
  fuelAnalysis,
  onOpenFuelSettings,
}: {
  planId: string;
  navpack: NavPack | null;
  corridor: CorridorGraphPack | null;
  places?: PlacesPack | null;
  traffic?: TrafficOverlay | null;
  hazards?: HazardOverlay | null;
  focusedStopId: string | null;
  onFocusStop: (id: string | null) => void;
  focusedPlaceId?: string | null;
  onFocusPlace?: (placeId: string | null) => void;
  onRebuildRequested?: (args: { stops: TripStop[]; mode: TripEditorRebuildMode }) => Promise<void>;
  onAddSuggestion?: (place: PlaceItem) => Promise<void> | void;
  highlightedAlertId?: string | null;
  onHighlightAlert?: (ev: AlertHighlightEvent) => void;
  userPosition?: RoamPosition | null;
  fuelAnalysis?: FuelAnalysis | null;
  onOpenFuelSettings?: () => void;
}) {
  /* ── Editor state ───────────────────────────────────────────────────── */
  const [stops, setStops] = useState<TripStop[]>(() => ensureStopIds(navpack?.req?.stops ?? []));
  const [dirty, setDirty] = useState(false);
  const [busy, setBusy] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const [activeSection, setActiveSection] = useState<ActiveSection>("route");
  const [mode] = useState<TripEditorRebuildMode>("auto");

  useEffect(() => {
    setStops(ensureStopIds(navpack?.req?.stops ?? []));
    setDirty(false);
    setErr(null);
  }, [navpack]);

  const canRebuild = stops.length >= 2 && !!corridor && !!onRebuildRequested;

  /* ── Alert intelligence ─────────────────────────────────────────────── */
  const routeGeometry = navpack?.primary?.geometry ?? null;
  const stopsForProjection = useMemo(
    () =>
      stops.filter((st) => typeof st.lat === "number" && typeof st.lng === "number") as Array<{
        lat: number;
        lng: number;
      }>,
    [stops],
  );

  const {
    all: allAlerts,
    next: nextAlert,
    routeBlockers,
    alertsForLeg,
    highCount,
    totalCount,
    staleness,
    assessment,
    hideBehind,
    toggleHideBehind,
    behindCount,
    dismissAlert,
    dismissedCount,
  } = useAlerts(traffic, hazards, routeGeometry, userPosition, stopsForProjection);

  /* ── Stop editing ───────────────────────────────────────────────────── */
  const moveStop = useCallback(
    (fromIdx: number, dir: -1 | 1) => {
      haptic.selection();
      setStops((prev) => {
        const toIdx = fromIdx + dir;
        if (toIdx < 0 || toIdx >= prev.length) return prev;
        const from = prev[fromIdx];
        const to = prev[toIdx];
        if (!from || !to || isLockedStop(from) || isLockedStop(to)) return prev;
        const out = [...prev];
        const [moved] = out.splice(fromIdx, 1);
        out.splice(toIdx, 0, moved);
        return out;
      });
      setDirty(true);
    },
    [],
  );

  const removeStop = useCallback(
    (id?: string | null) => {
      if (!id) return;
      haptic.medium();
      setStops((prev) => {
        const found = prev.find((x) => x.id === id);
        if (!found || isLockedStop(found)) return prev;
        return prev.filter((x) => x.id !== id);
      });
      if (focusedStopId === id) onFocusStop(null);
      setDirty(true);
    },
    [focusedStopId, onFocusStop],
  );

  const addStopFromPlace = useCallback(
    (p: PlaceItem) => {
      haptic.tap();
      if (onAddSuggestion) {
        onAddSuggestion(p);
        return;
      }
      setStops((prev) => {
        const out = [...prev];
        const endIdx = out.findIndex((st) => (st.type ?? "poi") === "end");
        const next: TripStop = { id: shortId(), type: "poi", name: p.name, lat: p.lat, lng: p.lng };
        if (endIdx >= 0) out.splice(endIdx, 0, next);
        else out.push(next);
        return out;
      });
      setDirty(true);
      hideKeyboard();
      setActiveSection("route");
    },
    [onAddSuggestion],
  );

  const reset = useCallback(() => {
    haptic.tap();
    setStops(ensureStopIds(navpack?.req?.stops ?? []));
    setDirty(false);
    setErr(null);
  }, [navpack]);

  const rebuild = useCallback(async () => {
    if (!canRebuild || !onRebuildRequested) return;
    haptic.medium();
    hideKeyboard();
    setBusy("rebuilding");
    setErr(null);
    try {
      await onRebuildRequested({ stops: ensureStopIds(stops), mode });
      setDirty(false);
      haptic.success();
    } catch (e: any) {
      setErr(e?.message ?? "Rebuild failed");
      haptic.error();
    } finally {
      setBusy(null);
    }
  }, [canRebuild, onRebuildRequested, stops, mode]);

  /* ── Derived ────────────────────────────────────────────────────────── */
  const distance = navpack?.primary?.distance_m ?? 0;
  const duration = navpack?.primary?.duration_s ?? 0;
  const placesCount = places?.items?.length ?? 0;

  /* ── No-route fallback ──────────────────────────────────────────────── */
  if (!navpack) {
    return <div className={s.noRoute}>No route active.</div>;
  }

  /* ── Section tabs config ────────────────────────────────────────────── */
  const tabs: { key: ActiveSection; label: string; icon: React.ReactNode; badge?: string }[] = [
    { key: "route", label: "Route", icon: <Route size={14} strokeWidth={2.5} /> },
    {
      key: "places",
      label: "Places",
      icon: <MapIcon size={14} strokeWidth={2.5} />,
      badge: placesCount > 0 ? String(placesCount) : undefined,
    },
  ];

  return (
    <div className={s.root}>
      {/* ── Route summary ──────────────────────────────────────────────── */}
      <div className={s.summaryCard}>
        <div className={s.summaryRow}>
          <div className={s.summaryLabel}>Route Overview</div>
          <div className={s.summaryStats}>
            {formatDist(distance)} · {formatDur(duration)}
          </div>
        </div>
        {dirty && (
          <div className={s.dirtyBanner}>
            <Save size={12} strokeWidth={2.5} />
            Unsaved route changes
          </div>
        )}
      </div>

      {/* ── Route assessment (pre-departure safety summary) ────────── */}
      <RouteAssessment
        assessment={assessment}
        staleness={staleness}
        onHighlight={onHighlightAlert}
      />

      {/* ── Fuel summary card (between route summary and alerts) ────── */}
      <FuelSummaryCard
        analysis={fuelAnalysis ?? null}
        onOpenSettings={onOpenFuelSettings}
      />

      <NextAlertBanner
        next={nextAlert}
        totalCount={totalCount}
        highCount={highCount}
        allAlerts={allAlerts}
        routeBlockers={routeBlockers}
        highlighted={highlightedAlertId}
        onHighlight={onHighlightAlert}
        onDismiss={dismissAlert}
        onRebuildRequested={canRebuild ? rebuild : undefined}
        staleness={staleness}
        hideBehind={hideBehind}
        onToggleHideBehind={toggleHideBehind}
        behindCount={behindCount}
        dismissedCount={dismissedCount}
      />
      {/* ── Error ──────────────────────────────────────────────────────── */}
      {err && <div className={s.errorBox}>{err}</div>}

      {/* ── Section tabs ───────────────────────────────────────────────── */}
      <div className={s.tabBar}>
        {tabs.map((tab) => {
          const active = activeSection === tab.key;
          return (
            <button
              key={tab.key}
              type="button"
              className={cx(s.tab, active && s.tabActive)}
              onClick={() => {
                haptic.selection();
                setActiveSection(tab.key);
              }}
            >
              {tab.icon}
              {tab.label}
              {tab.badge && <span className={s.tabBadge}>{tab.badge}</span>}
            </button>
          );
        })}
      </div>

      {/* ══ Route section ═══════════════════════════════════════════════ */}
      {activeSection === "route" && (
        <div className={s.stopList}>
          {stops.map((stop, index) => {
            const type = resolveType(stop);
            const isFocused = focusedStopId === stop.id;
            const locked = isLockedStop(stop);
            const legAlerts =
            index < stops.length - 1 ? alertsForLeg(index, index + 1) : [];
            return (
              <div key={stop.id ?? index} className={s.stopEntry}>
                {/* Stop card */}
                <div
                  className={cx(s.stopCard, isFocused && s.stopCardFocused)}
                  data-stop-type={type}
                  onClick={() => {
                    haptic.selection();
                    onFocusStop(stop.id ?? null);
                  }}
                >
                  {/* Marker icon */}
                  <div className={s.stopMarker} data-type={type}>
                    <StopIcon type={type} />
                    <div className={s.indexBadge} data-type={type}>
                      {index + 1}
                    </div>
                  </div>

                  {/* Name + meta */}
                  <div className={s.stopContent}>
                    <div className={s.stopName}>{stopLabel(stop, index)}</div>
                    <div className={s.stopMeta}>
                      {typeof stop.lat === "number" && typeof stop.lng === "number" && (
                        <span className={s.stopCoords}>
                          {stop.lat.toFixed(4)}, {stop.lng.toFixed(4)}
                        </span>
                      )}
                      <span className={s.stopTypeBadge} data-type={type}>
                        {type}
                      </span>
                    </div>
                  </div>

                  {/* Edit controls */}
                  {!locked && (
                    <div className={s.stopControls}>
                      {index > 1 && (
                        <button
                          type="button"
                          className={s.controlBtn}
                          disabled={!!busy}
                          onClick={(e) => {
                            e.stopPropagation();
                            moveStop(index, -1);
                          }}
                          aria-label="Move up"
                        >
                          <ChevronUp size={14} strokeWidth={2.5} />
                        </button>
                      )}
                      {index < stops.length - 2 && (
                        <button
                          type="button"
                          className={s.controlBtn}
                          disabled={!!busy}
                          onClick={(e) => {
                            e.stopPropagation();
                            moveStop(index, 1);
                          }}
                          aria-label="Move down"
                        >
                          <ChevronDown size={14} strokeWidth={2.5} />
                        </button>
                      )}
                      <button
                        type="button"
                        className={s.controlBtnDanger}
                        disabled={!!busy}
                        onClick={(e) => {
                          e.stopPropagation();
                          removeStop(stop.id);
                        }}
                        aria-label="Remove stop"
                      >
                        <X size={14} strokeWidth={2.5} />
                      </button>
                    </div>
                  )}
                </div>

                {/* Inline leg alerts */}
                {legAlerts.length > 0 && (
                 <LegAlertStrip
                 alerts={legAlerts}
                 highlighted={highlightedAlertId}
                 onHighlight={onHighlightAlert}
                 onDismiss={dismissAlert}
               />
                )}

                {/* Connector line between stops */}
                {index < stops.length - 1 && legAlerts.length === 0 && (
                  <div className={s.connector}>
                    <div className={s.connectorLine} />
                  </div>
                )}
              </div>
            );
          })}

          {/* Add stop button */}
          <button
            type="button"
            className={s.addStopBtn}
            disabled={!!busy}
            onClick={() => {
              haptic.tap();
              setActiveSection("places");
            }}
          >
            <Plus size={15} strokeWidth={2.5} />
            Add Stop from Places
          </button>

          {/* Save / Reset footer */}
          {dirty && (
            <div className={s.footer}>
              <button
                type="button"
                className={s.resetBtn}
                disabled={!!busy}
                onClick={reset}
              >
                <RotateCcw size={13} strokeWidth={2.5} />
                Reset
              </button>
              <button
                type="button"
                className={cx(s.saveBtn, (!canRebuild || !!busy) && s.saveBtnDisabled)}
                disabled={!!busy || !canRebuild}
                onClick={rebuild}
              >
                {busy ? (
                  <>
                    <Loader2 size={14} strokeWidth={2.5} className={s.spinner} />
                    Saving…
                  </>
                ) : (
                  <>
                    <Save size={14} strokeWidth={2.5} />
                    Save Route
                  </>
                )}
              </button>
            </div>
          )}
        </div>
      )}

      {/* ══ Places section ══════════════════════════════════════════════ */}
      {activeSection === "places" && (
        <div className={s.placesSection}>
          {places && placesCount > 0 ? (
            <TripSuggestionsPanel
              places={places}
              enableSearch={true}
              maxHeight="50vh"
              focusedPlaceId={focusedPlaceId ?? null}
              onFocusPlace={onFocusPlace}
              onAddStopFromPlace={addStopFromPlace}
            />
          ) : (
            <div className={s.emptyPlaces}>
              <div className={s.emptyPlacesIcon}>
                <MapIcon size={28} strokeWidth={1.5} />
              </div>
              <div className={s.emptyPlacesTitle}>No places loaded yet</div>
              <div className={s.emptyPlacesSub}>
                Places will appear here once your route corridor is loaded
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

===== src/components/trips/new/MapStyleSwitcher.tsx =====

"use client";

import React from "react";
import { haptic } from "@/lib/native/haptics";
import { Sun, Moon, Map as MapIcon, Satellite } from "lucide-react";

export type MapBaseMode = "vector" | "hybrid";
export type VectorTheme = "bright" | "dark";

export function MapStyleSwitcher(props: {
  mode: MapBaseMode;
  vectorTheme: VectorTheme;
  onChange: (next: { mode: MapBaseMode; vectorTheme: VectorTheme }) => void;
}) {
  const { mode, vectorTheme, onChange } = props;

  const SegBtn = ({
    active,
    onClick,
    children,
    title,
    ariaLabel,
  }: {
    active: boolean;
    onClick: () => void;
    children: React.ReactNode;
    title?: string;
    ariaLabel?: string;
  }) => (
    <button
      type="button"
      className="trip-interactive"
      onClick={onClick}
      aria-pressed={active}
      title={title}
      aria-label={ariaLabel}
      style={{
        all: "unset",
        cursor: "pointer",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: 8,
        height: 40,
        padding: "0 14px",
        borderRadius: 12,
        fontSize: 14,
        fontWeight: 800,
        letterSpacing: -0.2,
        color: active ? "var(--roam-surface)" : "var(--roam-text)",
        background: active ? "var(--roam-text)" : "transparent",
        WebkitTapHighlightColor: "transparent",
        transition: "background 160ms ease, color 160ms ease, transform 120ms ease",
        transform: active ? "scale(1.02)" : "scale(1)",
      }}
    >
      {children}
    </button>
  );

  const IconBtn = ({
    active,
    onClick,
    children,
    title,
    ariaLabel,
  }: {
    active: boolean;
    onClick: () => void;
    children: React.ReactNode;
    title: string;
    ariaLabel: string;
  }) => (
    <button
      type="button"
      className="trip-interactive"
      onClick={onClick}
      aria-pressed={active}
      title={title}
      aria-label={ariaLabel}
      style={{
        all: "unset",
        cursor: "pointer",
        width: 40,
        height: 40,
        borderRadius: 12,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        color: active ? "var(--roam-surface)" : "var(--roam-text)",
        background: active ? "var(--roam-text)" : "transparent",
        WebkitTapHighlightColor: "transparent",
        transition: "background 160ms ease, color 160ms ease, transform 120ms ease",
        transform: active ? "scale(1.02)" : "scale(1)",
      }}
    >
      {children}
    </button>
  );

  return (
    <div
      className=""
      role="group"
      aria-label="Map style"
      style={{
        position: "absolute",
        top: 12,
        right: 12,
        zIndex: 30,
        display: "flex",
        flexDirection: "column",
        gap: 8,
        pointerEvents: "auto",
      }}
    >
      {/* Main segmented control */}
      <div
        style={{
          display: "inline-flex",
          alignItems: "center",
          gap: 4,
          padding: 4,
          borderRadius: 14,
          background: "rgba(0,0,0,0.35)",
          backdropFilter: "blur(10px)",
          border: "1px solid rgba(255,255,255,0.16)",
          boxShadow: "0 10px 26px rgba(0,0,0,0.22)",
        }}
      >
        <SegBtn
          active={mode === "vector"}
          onClick={() => {
            haptic.selection();
            onChange({ mode: "vector", vectorTheme });
          }}
          title="Map"
        >
          <MapIcon size={16} />
          Map
        </SegBtn>

        <SegBtn
          active={mode === "hybrid"}
          onClick={() => {
            haptic.selection();
            onChange({ mode: "hybrid", vectorTheme });
          }}
          title="Satellite"
        >
          <Satellite size={16} />
          Sat
        </SegBtn>
      </div>

      {/* Theme toggle (only when in vector) */}
      {mode === "vector" && (
        <div
          style={{
            alignSelf: "flex-end",
            display: "inline-flex",
            alignItems: "center",
            gap: 4,
            padding: 4,
            borderRadius: 14,
            background: "rgba(0,0,0,0.35)",
            backdropFilter: "blur(10px)",
            border: "1px solid rgba(255,255,255,0.16)",
            boxShadow: "0 10px 26px rgba(0,0,0,0.22)",
          }}
        >
          <IconBtn
            active={vectorTheme === "bright"}
            title="Bright"
            ariaLabel="Bright theme"
            onClick={() => {
              haptic.selection();
              onChange({ mode: "vector", vectorTheme: "bright" });
            }}
          >
            <Sun size={16} />
          </IconBtn>

          <IconBtn
            active={vectorTheme === "dark"}
            title="Dark"
            ariaLabel="Dark theme"
            onClick={() => {
              haptic.selection();
              onChange({ mode: "vector", vectorTheme: "dark" });
            }}
          >
            <Moon size={16} />
          </IconBtn>
        </div>
      )}
    </div>
  );
}


===== src/components/trips/new/NewTripMap.tsx =====

// src/components/new/NewTripMap.tsx
"use client";

import { useEffect, useMemo, useRef, useCallback } from "react";
import maplibregl, { type Map as MLMap, type GeoJSONSource } from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import { Protocol } from "pmtiles";

import type { TripStop } from "@/lib/types/trip";
import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay } from "@/lib/types/navigation";
import type { PlacesPack } from "@/lib/types/places";
import type { NavCoord } from "@/lib/types/geo";
import type { RoamPosition } from "@/lib/native/geolocation";
import { assetsApi } from "@/lib/api/assets";
import { polyline6ToGeoJSONLine } from "@/lib/nav/polyline6";
import { rewriteStyleForLocalServer, isFullyOfflineCapable } from "@/lib/offline/basemapManager";

/* ── Source / layer IDs ──────────────────────────────────────────────── */

const ROUTE_SOURCE = "roam_route";
const ROUTE_LAYER = "roam_route_line";
const STOPS_SOURCE = "roam_stops";
const STOPS_LAYER = "roam_stops_pts";
const PLACES_SOURCE = "roam_places";
const PLACES_LAYER = "roam_places_pts";
const TRAFFIC_SOURCE = "roam_traffic";
const TRAFFIC_LAYER = "roam_traffic_pts";
const HAZARDS_SOURCE = "roam_hazards";
const HAZARDS_LAYER = "roam_hazards_pts";

const USER_LOC_SRC = "roam-user-loc-src";
const USER_LOC_ACCURACY = "roam-user-loc-accuracy";
const USER_LOC_DOT_OUTER = "roam-user-loc-dot-outer";
const USER_LOC_DOT_INNER = "roam-user-loc-dot-inner";
const USER_LOC_HEADING_SRC = "roam-user-heading-src";
const USER_LOC_HEADING = "roam-user-loc-heading";

const HEADING_ARROW_ID = "roam-heading-arrow";
const HEADING_ARROW_SVG = `<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
  <defs><linearGradient id="hg" x1="24" y1="4" x2="24" y2="28" gradientUnits="userSpaceOnUse">
    <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.85"/>
    <stop offset="100%" stop-color="#2563eb" stop-opacity="0.15"/>
  </linearGradient></defs>
  <path d="M24 4 L36 28 L24 22 L12 28 Z" fill="url(#hg)" stroke="#2563eb" stroke-width="1" stroke-opacity="0.4"/>
</svg>`;

const EMPTY_FC: GeoJSON.FeatureCollection = { type: "FeatureCollection", features: [] };

/* ── Helpers ─────────────────────────────────────────────────────────── */

function normalizePath(p: string) {
  let x = (p ?? "").trim().replace(/^\/+/, "/");
  if (!x.startsWith("/")) x = `/${x}`;
  return x;
}

function toAbsoluteUrl(pathOrUrl: string) {
  if (/^https?:\/\//i.test(pathOrUrl)) return pathOrUrl;
  if (typeof window === "undefined") return pathOrUrl;
  return `${window.location.origin}${pathOrUrl.startsWith("/") ? pathOrUrl : `/${pathOrUrl}`}`;
}

function rewritePmtilesUrl(url: string) {
  if (!url.startsWith("pmtiles://")) return url;
  const inner = url.slice("pmtiles://".length);
  if (/^https?:\/\//i.test(inner)) return url;
  return `pmtiles://${toAbsoluteUrl(normalizePath(inner))}`;
}

function accuracyToPixels(accuracyM: number, lat: number, zoom: number): number {
  const mpp = (Math.cos((lat * Math.PI) / 180) * 2 * Math.PI * 6371008.8) / (256 * Math.pow(2, zoom));
  return Math.max(12, Math.min(200, accuracyM / mpp));
}

function userLocGeoJSON(pos: RoamPosition | null | undefined): GeoJSON.FeatureCollection {
  if (!pos) return EMPTY_FC;
  return {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      properties: { accuracy: pos.accuracy },
      geometry: { type: "Point", coordinates: [pos.lng, pos.lat] },
    }],
  };
}

function headingGeoJSON(pos: RoamPosition | null | undefined): GeoJSON.FeatureCollection {
  if (!pos || pos.heading == null || pos.speed == null || pos.speed < 0.5) return EMPTY_FC;
  return {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      properties: { heading: pos.heading },
      geometry: { type: "Point", coordinates: [pos.lng, pos.lat] },
    }],
  };
}

function loadHeadingArrow(map: MLMap): Promise<void> {
  return new Promise((resolve) => {
    if (map.hasImage(HEADING_ARROW_ID)) { resolve(); return; }
    const img = new Image(48, 48);
    img.onload = () => {
      try { if (!map.hasImage(HEADING_ARROW_ID)) map.addImage(HEADING_ARROW_ID, img, { sdf: false }); } catch {}
      resolve();
    };
    img.onerror = () => resolve();
    img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(HEADING_ARROW_SVG)}`;
  });
}

function pointFromBbox(b: number[] | null | undefined): [number, number] | null {
  if (!b || b.length !== 4) return null;
  const [minLng, minLat, maxLng, maxLat] = b;
  if (![minLng, minLat, maxLng, maxLat].every((x) => typeof x === "number" && Number.isFinite(x))) return null;
  return [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
}

function tryPointFromGeoJSON(g: any): [number, number] | null {
  try {
    if (g?.type === "Point" && Array.isArray(g.coordinates) && g.coordinates.length >= 2) {
      const lng = Number(g.coordinates[0]), lat = Number(g.coordinates[1]);
      if (Number.isFinite(lng) && Number.isFinite(lat)) return [lng, lat];
    }
  } catch {}
  return null;
}

/**
 * Safely check if the map is alive and style is loaded.
 */
function mapReady(map: MLMap | null): map is MLMap {
  if (!map) return false;
  try {
    map.getCanvas();
    const loaded = (map as any).isStyleLoaded?.();
    return loaded === true;
  } catch {
    return false;
  }
}

/**
 * Fetch a style JSON and rewrite it for the local tile server if available.
 * Falls back to the raw style JSON if the tile server isn't running.
 */
async function fetchAndRewriteStyle(styleUrl: string): Promise<any> {
  const res = await fetch(styleUrl);
  let styleJson = await res.json();
  if (isFullyOfflineCapable()) {
    styleJson = rewriteStyleForLocalServer(styleJson);
  }
  return styleJson;
}

/* ── Component ───────────────────────────────────────────────────────── */

export function NewTripMap(props: {
  stops: TripStop[];
  navPack: NavPack | null;
  styleId: string;
  onMapCenterChanged?: (c: NavCoord) => void;
  corridorPack?: CorridorGraphPack | null;
  placesPack?: PlacesPack | null;
  traffic?: TrafficOverlay | null;
  hazards?: HazardOverlay | null;
  userPosition?: RoamPosition | null;
}) {
  const elRef = useRef<HTMLDivElement | null>(null);
  const mapRef = useRef<MLMap | null>(null);
  const initRef = useRef(false);

  const onCenterRef = useRef(props.onMapCenterChanged);
  onCenterRef.current = props.onMapCenterChanged;

  const stylePath = useMemo(() => assetsApi.styleUrl(props.styleId), [props.styleId]);
  const styleAbsUrl = useMemo(() => toAbsoluteUrl(stylePath), [stylePath]);

  const userLocFC = useMemo(() => userLocGeoJSON(props.userPosition), [props.userPosition]);
  const headingFC = useMemo(() => headingGeoJSON(props.userPosition), [props.userPosition]);

  /**
   * Full layer setup — called once on init and again on every style swap.
   */
  const setupAllLayers = useCallback(async (map: MLMap) => {
    if (!mapReady(map)) return;
    ensureDataSources(map);
    ensureUserLocationSources(map);
    ensureUserLocationLayers(map);
    await loadHeadingArrow(map);
    ensureHeadingLayer(map);
  }, []);

  // ── Init ──────────────────────────────────────────────────
  useEffect(() => {
    if (!elRef.current || initRef.current) return;
    initRef.current = true;

    const protocol = new Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile.bind(protocol));

    // Start with an empty style — we load + rewrite the real one async
    const map = new maplibregl.Map({
      container: elRef.current,
      style: { version: 8, sources: {}, layers: [] } as any,
      center: [153.026, -27.4705],
      zoom: 10,
      attributionControl: false,
      transformRequest: (url) => {
        if (url.startsWith("pmtiles://")) return { url: rewritePmtilesUrl(url) };
        return { url };
      },
    });

    mapRef.current = map;

    map.on("moveend", () => {
      const c = map.getCenter();
      onCenterRef.current?.({ lat: c.lat, lng: c.lng });
    });

    // Fetch, rewrite for local tile server, then set style
    (async () => {
      try {
        const styleJson = await fetchAndRewriteStyle(styleAbsUrl);
        map.setStyle(styleJson);
      } catch (e) {
        console.error("[NewTripMap] style load failed, falling back to URL:", e);
        map.setStyle(styleAbsUrl);
      }
    })();

    map.on("style.load", async () => {
      await setupAllLayers(map);
      syncAll(map, props);
      syncUserLocation(map, userLocFC, headingFC, props.userPosition);
    });

    return () => {
      mapRef.current = null;
      initRef.current = false;
      try { map.remove(); } catch {}
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ── Style changes ─────────────────────────────────────────
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    let cancelled = false;

    const onStyleLoad = async () => {
      if (cancelled) return;
      await setupAllLayers(map);
      syncAll(map, props);
      syncUserLocation(map, userLocFC, headingFC, props.userPosition);
    };

    map.once("style.load", onStyleLoad);

    // Fetch, rewrite, then set (instead of passing raw URL)
    (async () => {
      try {
        const styleJson = await fetchAndRewriteStyle(styleAbsUrl);
        if (!cancelled) map.setStyle(styleJson);
      } catch {
        if (!cancelled) map.setStyle(styleAbsUrl);
      }
    })();

    return () => {
      cancelled = true;
      try { map.off("style.load", onStyleLoad); } catch {}
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [styleAbsUrl]);

  // ── Data syncs ────────────────────────────────────────────
  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) { ensureDataSources(m); syncStops(m, props.stops); }
  }, [props.stops]);

  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) { ensureDataSources(m); syncRoute(m, props.navPack); }
  }, [props.navPack]);

  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) { ensureDataSources(m); syncPlaces(m, props.placesPack ?? null); }
  }, [props.placesPack]);

  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) { ensureDataSources(m); syncTraffic(m, props.traffic ?? null); }
  }, [props.traffic]);

  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) { ensureDataSources(m); syncHazards(m, props.hazards ?? null); }
  }, [props.hazards]);

  // ── User location ─────────────────────────────────────────
  useEffect(() => {
    const m = mapRef.current;
    if (mapReady(m)) syncUserLocation(m, userLocFC, headingFC, props.userPosition);
  }, [userLocFC, headingFC, props.userPosition]);

  return (
    <div className="trip-map-fullscreen">
      <div ref={elRef} className="trip-map-inner" />
    </div>
  );
}

/* ── Map setup helpers ────────────────────────────────────────────────── */

function ensureDataSources(map: MLMap) {
  if (!map.getSource(ROUTE_SOURCE)) {
    map.addSource(ROUTE_SOURCE, { type: "geojson", data: EMPTY_FC });
    map.addLayer({
      id: ROUTE_LAYER, type: "line", source: ROUTE_SOURCE,
      paint: {
        "line-width": ["interpolate", ["linear"], ["zoom"], 4, 3, 10, 5, 14, 8],
        "line-opacity": 0.9,
        "line-color": "#2e7cf6",
      },
    });
  }
  if (!map.getSource(STOPS_SOURCE)) {
    map.addSource(STOPS_SOURCE, { type: "geojson", data: EMPTY_FC });
    map.addLayer({
      id: STOPS_LAYER, type: "circle", source: STOPS_SOURCE,
      paint: {
        "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 4, 10, 7, 14, 9],
        "circle-opacity": 0.95,
        "circle-color": "#ffffff",
        "circle-stroke-width": 2,
        "circle-stroke-opacity": 0.9,
        "circle-stroke-color": "#111827",
      },
    });
  }
  if (!map.getSource(PLACES_SOURCE)) {
    map.addSource(PLACES_SOURCE, { type: "geojson", data: EMPTY_FC });
    map.addLayer({
      id: PLACES_LAYER, type: "circle", source: PLACES_SOURCE,
      paint: {
        "circle-radius": 4.5,
        "circle-opacity": 0.85,
        "circle-color": "#34d399",
        "circle-stroke-width": 1,
        "circle-stroke-opacity": 0.8,
        "circle-stroke-color": "#0b1220",
      },
    });
  }
  if (!map.getSource(TRAFFIC_SOURCE)) {
    map.addSource(TRAFFIC_SOURCE, { type: "geojson", data: EMPTY_FC });
    map.addLayer({
      id: TRAFFIC_LAYER, type: "circle", source: TRAFFIC_SOURCE,
      paint: {
        "circle-radius": 5.5,
        "circle-opacity": 0.85,
        "circle-color": "#f59e0b",
        "circle-stroke-width": 1,
        "circle-stroke-opacity": 0.9,
        "circle-stroke-color": "#0b1220",
      },
    });
  }
  if (!map.getSource(HAZARDS_SOURCE)) {
    map.addSource(HAZARDS_SOURCE, { type: "geojson", data: EMPTY_FC });
    map.addLayer({
      id: HAZARDS_LAYER, type: "circle", source: HAZARDS_SOURCE,
      paint: {
        "circle-radius": 6.5,
        "circle-opacity": 0.85,
        "circle-color": "#ef4444",
        "circle-stroke-width": 1,
        "circle-stroke-opacity": 0.9,
        "circle-stroke-color": "#0b1220",
      },
    });
  }
}

function ensureUserLocationSources(map: MLMap) {
  if (!map.getSource(USER_LOC_SRC)) {
    map.addSource(USER_LOC_SRC, { type: "geojson", data: EMPTY_FC });
  }
  if (!map.getSource(USER_LOC_HEADING_SRC)) {
    map.addSource(USER_LOC_HEADING_SRC, { type: "geojson", data: EMPTY_FC });
  }
}

function ensureUserLocationLayers(map: MLMap) {
  if (!map.getSource(USER_LOC_SRC)) return;

  if (!map.getLayer(USER_LOC_ACCURACY)) {
    map.addLayer({
      id: USER_LOC_ACCURACY, type: "circle", source: USER_LOC_SRC,
      paint: {
        "circle-radius": 30,
        "circle-color": "rgba(37,99,235,0.08)",
        "circle-stroke-color": "rgba(37,99,235,0.25)",
        "circle-stroke-width": 1.5,
        "circle-opacity": 1,
      },
    });
  }
  if (!map.getLayer(USER_LOC_DOT_OUTER)) {
    map.addLayer({
      id: USER_LOC_DOT_OUTER, type: "circle", source: USER_LOC_SRC,
      paint: {
        "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 6, 10, 9, 16, 12],
        "circle-color": "#ffffff",
        "circle-opacity": 0.95,
      },
    });
  }
  if (!map.getLayer(USER_LOC_DOT_INNER)) {
    map.addLayer({
      id: USER_LOC_DOT_INNER, type: "circle", source: USER_LOC_SRC,
      paint: {
        "circle-radius": ["interpolate", ["linear"], ["zoom"], 4, 4, 10, 6.5, 16, 9],
        "circle-color": "#2563eb",
        "circle-opacity": 1,
      },
    });
  }
}

function ensureHeadingLayer(map: MLMap) {
  if (!map.getSource(USER_LOC_HEADING_SRC)) return;
  if (!map.hasImage(HEADING_ARROW_ID)) return;
  if (map.getLayer(USER_LOC_HEADING)) return;

  try {
    map.addLayer({
      id: USER_LOC_HEADING, type: "symbol", source: USER_LOC_HEADING_SRC,
      layout: {
        "icon-image": HEADING_ARROW_ID,
        "icon-size": ["interpolate", ["linear"], ["zoom"], 6, 0.6, 14, 1.0, 18, 1.3],
        "icon-rotate": ["get", "heading"],
        "icon-rotation-alignment": "map",
        "icon-allow-overlap": true,
        "icon-ignore-placement": true,
      },
      paint: { "icon-opacity": 0.9 },
    });
  } catch (e) {
    console.warn("[NewTripMap] ensureHeadingLayer failed (harmless):", e);
  }
}

function syncUserLocation(
  map: MLMap,
  locFC: GeoJSON.FeatureCollection,
  headFC: GeoJSON.FeatureCollection,
  pos: RoamPosition | null | undefined,
) {
  const locSrc = map.getSource(USER_LOC_SRC) as GeoJSONSource | undefined;
  if (locSrc) locSrc.setData(locFC);

  const headSrc = map.getSource(USER_LOC_HEADING_SRC) as GeoJSONSource | undefined;
  if (headSrc) headSrc.setData(headFC);

  if (pos && map.getLayer(USER_LOC_ACCURACY)) {
    const px = accuracyToPixels(pos.accuracy, pos.lat, map.getZoom());
    map.setPaintProperty(USER_LOC_ACCURACY, "circle-radius", px);
  }
}

/* ── Data sync functions ──────────────────────────────────────────────── */

function syncAll(map: MLMap, props: any) {
  syncStops(map, props.stops);
  syncRoute(map, props.navPack);
  syncPlaces(map, props.placesPack ?? null);
  syncTraffic(map, props.traffic ?? null);
  syncHazards(map, props.hazards ?? null);
}

function syncStops(map: MLMap, stops: TripStop[]) {
  const src = map.getSource(STOPS_SOURCE) as GeoJSONSource | undefined;
  if (!src) return;
  src.setData({
    type: "FeatureCollection",
    features: stops.map((s, idx) => ({
      type: "Feature" as const,
      geometry: { type: "Point" as const, coordinates: [s.lng, s.lat] as [number, number] },
      properties: { id: s.id ?? String(idx), type: s.type ?? "poi", name: s.name ?? "", idx },
    })),
  });
}

function syncRoute(map: MLMap, navPack: NavPack | null) {
  const src = map.getSource(ROUTE_SOURCE) as GeoJSONSource | undefined;
  if (!src) return;

  const poly6 =
    (navPack as any)?.primary?.geometry ??
    (navPack as any)?.routes?.primary?.geometry ??
    (navPack as any)?.geometry ??
    null;

  if (!poly6) {
    src.setData(EMPTY_FC);
    return;
  }

  const line = polyline6ToGeoJSONLine(String(poly6));
  src.setData({
    type: "FeatureCollection",
    features: [{ type: "Feature", geometry: line, properties: {} }],
  });

  const b =
    (navPack as any)?.primary?.bbox ??
    (navPack as any)?.routes?.primary?.bbox ??
    (navPack as any)?.bbox ??
    null;

  if (b && typeof b === "object" && "minLng" in b) {
    map.fitBounds(
      [[b.minLng, b.minLat], [b.maxLng, b.maxLat]],
      { padding: 80, duration: 600 },
    );
  }
}

function syncPlaces(map: MLMap, pack: PlacesPack | null) {
  const src = map.getSource(PLACES_SOURCE) as GeoJSONSource | undefined;
  if (!src) return;

  const items: any[] = (pack as any)?.items ?? (pack as any)?.places ?? [];
  if (!items.length) {
    src.setData(EMPTY_FC);
    return;
  }

  const MAX_MAP_FEATURES = 2000;
  const capped = items.length > MAX_MAP_FEATURES ? items.slice(0, MAX_MAP_FEATURES) : items;

  src.setData({
    type: "FeatureCollection",
    features: capped.map((it) => ({
      type: "Feature" as const,
      geometry: { type: "Point" as const, coordinates: [it.lng, it.lat] as [number, number] },
      properties: { id: it.id, name: it.name, category: it.category },
    })),
  });
}

function syncTraffic(map: MLMap, overlay: TrafficOverlay | null) {
  const src = map.getSource(TRAFFIC_SOURCE) as GeoJSONSource | undefined;
  if (!src) return;

  const items: any[] = (overlay as any)?.items ?? [];
  if (!items.length) {
    src.setData(EMPTY_FC);
    return;
  }

  src.setData({
    type: "FeatureCollection",
    features: items
      .map((ev) => {
        const p = tryPointFromGeoJSON(ev.geometry) ?? pointFromBbox(ev.bbox);
        if (!p) return null;
        return {
          type: "Feature" as const,
          geometry: { type: "Point" as const, coordinates: p },
          properties: { id: ev.id, type: ev.type ?? "unknown", severity: ev.severity ?? "unknown" },
        };
      })
      .filter(Boolean) as any[],
  });
}

function syncHazards(map: MLMap, overlay: HazardOverlay | null) {
  const src = map.getSource(HAZARDS_SOURCE) as GeoJSONSource | undefined;
  if (!src) return;

  const items: any[] = (overlay as any)?.items ?? [];
  if (!items.length) {
    src.setData(EMPTY_FC);
    return;
  }

  src.setData({
    type: "FeatureCollection",
    features: items
      .map((ev) => {
        const p = tryPointFromGeoJSON(ev.geometry) ?? pointFromBbox(ev.bbox);
        if (!p) return null;
        return {
          type: "Feature" as const,
          geometry: { type: "Point" as const, coordinates: p },
          properties: { id: ev.id, kind: ev.kind ?? "unknown", severity: ev.severity ?? "unknown" },
        };
      })
      .filter(Boolean) as any[],
  });
}

===== src/components/trips/new/PlaceSearchModal.tsx =====

// src/components/new/PlaceSearchModal.tsx
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import type { NavCoord } from "@/lib/types/geo";
import { placesApi } from "@/lib/api/places";
import type { PlaceItem } from "@/lib/types/places";
import { Search } from "lucide-react"

import { haptic } from "@/lib/native/haptics";
import { hideKeyboard } from "@/lib/native/keyboard";

const DEBOUNCE_MS = 300;
const MIN_QUERY_LEN = 2;

export function PlaceSearchModal(props: {
  open: boolean;
  stopId: string | null;
  mapCenter: NavCoord | null;
  onClose: () => void;
  onPick: (args: { stopId: string; name: string; lat: number; lng: number }) => void;
}) {
  const [q, setQ] = useState("");
  const [loading, setLoading] = useState(false);
  const [items, setItems] = useState<PlaceItem[]>([]);
  const [err, setErr] = useState<string | null>(null);
  const [hasSearched, setHasSearched] = useState(false);

  const abortRef = useRef<AbortController | null>(null);
  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const inputRef = useRef<HTMLInputElement | null>(null);

  const enabled = props.open && !!props.stopId;

  useEffect(() => {
    if (!props.open) {
      setQ(""); setItems([]); setErr(null); setHasSearched(false);
      abortRef.current?.abort();
      if (debounceRef.current) clearTimeout(debounceRef.current);
    }
  }, [props.open]);

  useEffect(() => {
    if (props.open) {
      const t = setTimeout(() => inputRef.current?.focus(), 60);
      return () => clearTimeout(t);
    }
  }, [props.open]);

  const doSearch = useCallback(async (query: string) => {
    if (!enabled) return;
    const trimmed = query.trim();
    if (trimmed.length < MIN_QUERY_LEN) { setItems([]); setHasSearched(false); return; }

    abortRef.current?.abort();
    const ac = new AbortController(); abortRef.current = ac;
    setLoading(true); setErr(null);

    try {
      const center = props.mapCenter ?? { lat: -27.4705, lng: 153.026 };
      const res = await placesApi.search({ center, radius_m: 50000, query: trimmed, limit: 10, categories: [] });
      if (ac.signal.aborted) return;
      setItems(res.items ?? []); setHasSearched(true);
    } catch (e: unknown) {
      if (ac.signal.aborted) return;
      setItems([]); setHasSearched(true); setErr(e instanceof Error ? e.message : "Search failed");
    } finally {
      if (!ac.signal.aborted) setLoading(false);
    }
  }, [enabled, props.mapCenter]);

  const onInput = useCallback((value: string) => {
    setQ(value);
    if (debounceRef.current) clearTimeout(debounceRef.current);
    if (value.trim().length < MIN_QUERY_LEN) { setItems([]); setHasSearched(false); setLoading(false); return; }
    setLoading(true);
    debounceRef.current = setTimeout(() => doSearch(value), DEBOUNCE_MS);
  }, [doSearch]);

  const onKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (debounceRef.current) clearTimeout(debounceRef.current);
      hideKeyboard();
      doSearch(q);
    }
  }, [doSearch, q]);

  const handleClose = () => {
    haptic.tap();
    hideKeyboard();
    props.onClose();
  };

  const handlePick = (it: PlaceItem) => {
    if (!props.stopId) return;
    haptic.success();
    hideKeyboard();
    props.onPick({ stopId: props.stopId, name: it.name, lat: it.lat, lng: it.lng });
  };

  if (!props.open) return null;

  return (
    <div className="trip-modal-overlay" role="dialog" aria-modal="true" onClick={handleClose}>
      <div className="trip-modal" onClick={(e) => e.stopPropagation()}>
        <div className="trip-drag-handle" />

        <div className="trip-row-between" style={{ marginBottom: 8 }}>
          <div className="trip-h1">Search Location</div>
          <button type="button" onClick={handleClose} className="trip-interactive trip-btn-icon" aria-label="Close">✕</button>
        </div>

        <div className="trip-search-box">
          <span style={{ marginRight: 12, fontSize: "1.2rem", opacity: 0.5 }}><Search/></span>
          <input
            ref={inputRef} value={q} onChange={(e) => onInput(e.target.value)} onKeyDown={onKeyDown}
            placeholder="Where to?" autoComplete="off" autoCorrect="off" spellCheck={false} className="trip-input"
          />
          {q.length > 0 && (
            <button type="button"
              onClick={() => { haptic.tap(); setQ(""); setItems([]); setHasSearched(false); setErr(null); inputRef.current?.focus(); }}
              className="trip-interactive" style={{ background: "none", border: "none", color: "var(--roam-text-muted)", fontSize: "1.2rem", padding: "8px" }}>✕</button>
          )}
        </div>

        {loading && <div style={{ height: 3, background: "var(--roam-accent)", borderRadius: 2, animation: "roam-pulse 1s ease-in-out infinite", marginTop: 4 }} />}
        {err && <div className="trip-err-box" style={{ marginTop: 8 }}>{err}</div>}

        <div style={{ flex: 1, overflowY: "auto", marginTop: 12 }}>
          {!loading && !hasSearched && q.length < MIN_QUERY_LEN && (
            <div className="trip-muted" style={{ textAlign: "center", marginTop: 60 }}>Type at least {MIN_QUERY_LEN} characters to search.</div>
          )}
          {!loading && hasSearched && items.length === 0 && (
            <div className="trip-muted" style={{ textAlign: "center", marginTop: 60 }}>No results found.</div>
          )}

          {items.map((it) => {
            const address = (it.extra as Record<string, unknown>)?.address as string | undefined;
            return (
              <button key={it.id} type="button" className="trip-interactive trip-list-row" onClick={() => handlePick(it)}>
                <div className="trip-h2">{it.name}</div>
                <div className="trip-muted-small trip-truncate" style={{ marginTop: 6 }}>
                  {address || `${it.category} · ${it.lat.toFixed(4)}, ${it.lng.toFixed(4)}`}
                </div>
              </button>
            );
          })}
        </div>
      </div>
      <style>{`@keyframes roam-pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }`}</style>
    </div>
  );
}

===== src/components/trips/new/StopRow.tsx =====

"use client";

import { useState, useRef, useCallback, useEffect } from "react";
import type { TripStop } from "@/lib/types/trip";
import type { PlaceItem } from "@/lib/types/places";
import { placesApi } from "@/lib/api/places";
import { Search, Navigation, Loader2 } from "lucide-react";

import { haptic } from "@/lib/native/haptics";
import { getCurrentPosition } from "@/lib/native/geolocation";
import { hideKeyboard } from "@/lib/native/keyboard";

const DEBOUNCE_MS = 300;
const MIN_QUERY_LEN = 2;

function badgeForType(type?: string) {
  switch (type) {
    case "start": return "Start";
    case "end": return "End";
    case "via": return "Via";
    default: return "Stop";
  }
}

export function StopRow(props: {
  stop: TripStop;
  idx: number;
  count: number;
  onEdit: (patch: Partial<Pick<TripStop, "name" | "lat" | "lng">>) => void;
  onSearch: () => void;
  onRemove: () => void;
  onMoveUp: () => void;
  onMoveDown: () => void;
  onUseMyLocation?: () => void;
}) {
  const s = props.stop;
  const [locating, setLocating] = useState(false);

  // --- Inline Search State ---
  const [isFocused, setIsFocused] = useState(false);
  const [q, setQ] = useState(s.name ?? "");
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState<PlaceItem[]>([]);
  
  const abortRef = useRef<AbortController | null>(null);
  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  const canMoveUp = props.idx > 0 && s.type !== "start" && s.type !== "end";
  const canMoveDown = props.idx < props.count - 1 && s.type !== "start" && s.type !== "end";
  const canRemove = s.type !== "start" && s.type !== "end";
  const isLocked = s.type === "start" || s.type === "end";

  useEffect(() => {
    if (!isFocused) setQ(s.name ?? "");
  }, [s.name, isFocused]);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (wrapperRef.current && !wrapperRef.current.contains(e.target as Node)) {
        setIsFocused(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const doSearch = useCallback(async (query: string) => {
    const trimmed = query.trim();
    if (trimmed.length < MIN_QUERY_LEN) { setResults([]); return; }

    abortRef.current?.abort();
    const ac = new AbortController(); 
    abortRef.current = ac;
    setLoading(true);

    try {
      const center = { lat: s.lat || -27.4705, lng: s.lng || 153.026 };
      const res = await placesApi.search({ center, radius_m: 50000, query: trimmed, limit: 5, categories: [] });
      if (ac.signal.aborted) return;
      setResults(res.items ?? []);
    } catch (e: unknown) {
      if (ac.signal.aborted) return;
      setResults([]);
    } finally {
      if (!ac.signal.aborted) setLoading(false);
    }
  }, [s.lat, s.lng]);

  const onInput = (value: string) => {
    setQ(value);
    props.onEdit({ name: value });
    
    if (debounceRef.current) clearTimeout(debounceRef.current);
    if (value.trim().length < MIN_QUERY_LEN) { 
      setResults([]); 
      setLoading(false); 
      return; 
    }
    
    setLoading(true);
    debounceRef.current = setTimeout(() => doSearch(value), DEBOUNCE_MS);
  };

  const handlePick = (it: PlaceItem) => {
    haptic.success();
    hideKeyboard();
    props.onEdit({ name: it.name, lat: it.lat, lng: it.lng });
    setQ(it.name);
    setIsFocused(false);
  };

  const handleUseMyLocation = async () => {
    if (props.onUseMyLocation) {
      haptic.tap();
      props.onUseMyLocation();
      return;
    }

    setLocating(true);
    haptic.tap();
    try {
      const pos = await getCurrentPosition();
      props.onEdit({ lat: pos.lat, lng: pos.lng, name: "My Location" });
      setQ("My Location");
      haptic.success();
    } catch (e: any) {
      haptic.error();
    } finally {
      setLocating(false);
    }
  };

  return (
    // Replaced `className="trip-stop-row"` with an explicit inline layout to kill errant click targets
    <div 
      ref={wrapperRef}
      style={{ 
        display: "flex", 
        gap: 12, 
        padding: "16px 0", 
        borderBottom: "1px solid var(--roam-border)",
        alignItems: "flex-start",
        position: "relative",
        cursor: "default" 
      }}
    >
      <div style={{ display: "flex", flexDirection: "column", alignItems: "center", paddingTop: 8 }}>
        <div className={`trip-badge ${isLocked ? 'trip-badge-blue' : 'trip-badge-soft'}`}>
          {badgeForType(s.type)}
        </div>
      </div>

      <div style={{ display: "flex", flexDirection: "column", gap: 8, minWidth: 0, flex: 1 }}>
        <div style={{ position: "relative", width: "100%" }}>
          <div style={{ position: "absolute", left: 12, top: "50%", transform: "translateY(-50%)", color: "var(--roam-text-muted)" }}>
            {loading ? <Loader2 size={18} style={{ animation: "roam-spin 1s linear infinite" }} /> : <Search size={18} />}
          </div>
          <input
            value={q}
            onFocus={() => setIsFocused(true)}
            onChange={(e) => onInput(e.target.value)}
            placeholder="Search for a place..."
            className="trip-input"
            style={{ 
              paddingLeft: 40, 
              width: "100%", 
              height: 44, // Ensures a properly sized touch target
              fontSize: 15,
              borderRadius: 12
            }}
          />
          
          {isFocused && (q.length >= MIN_QUERY_LEN) && (
            <div 
              style={{
                position: "absolute",
                top: "calc(100% + 8px)",
                left: 0,
                right: 0,
                background: "var(--roam-surface)",
                border: "1px solid var(--roam-border)",
                borderRadius: 12,
                boxShadow: "0 12px 30px -5px rgba(0, 0, 0, 0.25)",
                zIndex: 50,
                overflow: "hidden",
                maxHeight: 220,
                overflowY: "auto"
              }}
            >
              {results.length === 0 && !loading && (
                <div style={{ padding: 16, fontSize: 14, color: "var(--roam-text-muted)", textAlign: "center" }}>
                  No places found.
                </div>
              )}
              {results.map(it => (
                <button
                  key={it.id}
                  type="button"
                  onClick={() => handlePick(it)}
                  style={{
                    width: "100%",
                    padding: "12px 16px",
                    background: "transparent",
                    border: "none",
                    borderBottom: "1px solid var(--roam-border)",
                    textAlign: "left",
                    cursor: "pointer",
                    display: "flex",
                    flexDirection: "column",
                    gap: 4
                  }}
                >
                  <span style={{ fontSize: 15, fontWeight: 600, color: "var(--roam-text)" }}>{it.name}</span>
                  <span style={{ fontSize: 13, color: "var(--roam-text-muted)", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>
                    {((it.extra as any)?.address) || `${it.category} · ${it.lat.toFixed(3)}, ${it.lng.toFixed(3)}`}
                  </span>
                </button>
              ))}
            </div>
          )}
        </div>

        <div style={{ fontSize: 13, color: "var(--roam-text-muted)", opacity: 0.8 }}>
          {s.lat.toFixed(5)}, {s.lng.toFixed(5)}
        </div>

        {(props.onUseMyLocation || s.type === "start") && (
          <button
            type="button"
            onClick={handleUseMyLocation}
            disabled={locating}
            className="trip-interactive"
            style={{ 
              display: "flex", 
              alignItems: "center", 
              justifyContent: "center",
              gap: 8, 
              background: "var(--roam-accent-soft, rgba(59, 130, 246, 0.1))", 
              border: "none", 
              color: "var(--roam-accent, #3b82f6)", 
              fontWeight: 700, 
              fontSize: 14,
              padding: "12px 16px", 
              borderRadius: 10,
              opacity: locating ? 0.6 : 1,
              width: "100%", // Big, chunky, impossible to miss
              minHeight: 44,
              marginTop: 4
            }}
          >
            <Navigation size={16} />
            {locating ? "Locating…" : "Use My Location"}
          </button>
        )}
      </div>

      <div style={{ display: "flex", flexDirection: "column", gap: 6, paddingTop: 4 }}>
        {canMoveUp && (
          <button type="button" onClick={() => { haptic.selection(); props.onMoveUp(); }} className="trip-interactive trip-btn-icon" style={{ height: 32, width: 32 }} aria-label="Move up">↑</button>
        )}
        {canMoveDown && (
          <button type="button" onClick={() => { haptic.selection(); props.onMoveDown(); }} className="trip-interactive trip-btn-icon" style={{ height: 32, width: 32 }} aria-label="Move down">↓</button>
        )}
        {canRemove && (
          <button type="button" onClick={() => { haptic.medium(); props.onRemove(); }} className="trip-interactive trip-btn-icon" style={{ height: 32, width: 32, color: "var(--roam-danger)" }} aria-label="Remove stop">✕</button>
        )}
      </div>
      
      <style>{`@keyframes roam-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`}</style>
    </div>
  );
}

===== src/components/trips/new/StopsEditor.tsx =====

"use client";

import React, { useEffect, useRef, useState } from "react";
import type { TripStop } from "@/lib/types/trip";
import type { OfflineBundleManifest } from "@/lib/types/bundle";
import { StopRow } from "./StopRow";
import { haptic } from "@/lib/native/haptics";
import { hideKeyboard } from "@/lib/native/keyboard";

import { useRouter } from "next/navigation";
import {
  Rocket,
  Route,
  Map,
  MapPin,
  Cloud,
  AlertTriangle,
  Package,
  Check,
  Loader2,
  X,
  ArrowLeft,
  UserRound,
} from "lucide-react";

/* ── Types ────────────────────────────────────────────────────────────── */

type OfflineBuildPhase =
  | "idle"
  | "routing"
  | "corridor_ensure"
  | "corridor_get"
  | "places_corridor"
  | "traffic_poll"
  | "hazards_poll"
  | "bundle_build"
  | "ready"
  | "error";

/* ── Build pipeline step definitions ─────────────────────────────────── */

type PipelineStep = {
  id: string;
  phases: OfflineBuildPhase[];
  icon: React.ReactNode;
  label: string;
  activeLabel: string;
  doneLabel: string;
  color: string;
};

const PIPELINE_STEPS: PipelineStep[] = [
  {
    id: "route",
    phases: ["routing"],
    icon: <Route size={18} />,
    label: "Build route",
    activeLabel: "Finding the best route…",
    doneLabel: "Route locked in",
    color: "#3b82f6",
  },
  {
    id: "corridor",
    phases: ["corridor_ensure", "corridor_get"],
    icon: <Map size={18} />,
    label: "Offline corridor",
    activeLabel: "Mapping your offline zone…",
    doneLabel: "Corridor ready",
    color: "#8b5cf6",
  },
  {
    id: "places",
    phases: ["places_corridor"],
    icon: <MapPin size={18} />,
    label: "Cache places",
    activeLabel: "Saving fuel, food & rest stops…",
    doneLabel: "Places cached",
    color: "#f59e0b",
  },
  {
    id: "traffic",
    phases: ["traffic_poll"],
    icon: <Cloud size={18} />,
    label: "Traffic snapshot",
    activeLabel: "Grabbing live traffic…",
    doneLabel: "Traffic saved",
    color: "#06b6d4",
  },
  {
    id: "hazards",
    phases: ["hazards_poll"],
    icon: <AlertTriangle size={18} />,
    label: "Hazard warnings",
    activeLabel: "Checking road warnings…",
    doneLabel: "Warnings loaded",
    color: "#ef4444",
  },
  {
    id: "bundle",
    phases: ["bundle_build"],
    icon: <Package size={18} />,
    label: "Package bundle",
    activeLabel: "Packaging everything for offline…",
    doneLabel: "Bundle ready",
    color: "#22c55e",
  },
];

function getStepState(step: PipelineStep, currentPhase: OfflineBuildPhase): "pending" | "active" | "done" {
  const allPhases: OfflineBuildPhase[] = PIPELINE_STEPS.flatMap((s) => s.phases);
  const currentIdx = allPhases.indexOf(currentPhase);
  const stepStartIdx = allPhases.indexOf(step.phases[0]);
  const stepEndIdx = allPhases.indexOf(step.phases[step.phases.length - 1]);

  if (currentPhase === "ready" || currentPhase === "error") {
    if (currentPhase === "ready") return "done";
    if (currentIdx > stepEndIdx) return "done";
    if (currentIdx >= stepStartIdx && currentIdx <= stepEndIdx) return "active";
    return "pending";
  }

  if (currentIdx > stepEndIdx) return "done";
  if (currentIdx >= stepStartIdx && currentIdx <= stepEndIdx) return "active";
  return "pending";
}

/* ── Animated spinner ────────────────────────────────────────────────── */

function Spinner({ color, size = 18 }: { color: string; size?: number }) {
  return (
    <Loader2
      size={size}
      style={{
        color,
        animation: "roam-spin 0.8s linear infinite",
      }}
    />
  );
}

/* ── Elapsed timer ───────────────────────────────────────────────────── */

function ElapsedTimer({ startedAt }: { startedAt: number }) {
  const [now, setNow] = useState(Date.now());

  useEffect(() => {
    const id = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(id);
  }, []);

  const secs = Math.max(0, Math.floor((now - startedAt) / 1000));
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  const display = m > 0 ? `${m}:${s.toString().padStart(2, "0")}` : `${s}s`;

  return (
    <span
      style={{
        fontSize: 12,
        fontWeight: 600,
        color: "var(--roam-text-muted)",
        fontVariantNumeric: "tabular-nums",
      }}
    >
      {display}
    </span>
  );
}

/* ── Build Progress View (takes over the sheet) ──────────────────────── */

function BuildProgressView({
  phase,
  error,
  saved,
  startedAt,
  onCancel,
}: {
  phase: OfflineBuildPhase;
  error: string | null;
  saved: boolean;
  startedAt: number;
  onCancel: () => void;
}) {
  const isError = phase === "error";
  const isDone = phase === "ready" && saved;

  const completedCount = PIPELINE_STEPS.filter((s) => getStepState(s, phase) === "done").length;
  const progressFraction = isDone ? 1 : completedCount / PIPELINE_STEPS.length;

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        padding: "28px 20px 20px",
        gap: 20,
        minHeight: 0,
        flex: 1,
        overflow: "hidden",
      }}
    >
      <div style={{ textAlign: "center" }}>
        <div style={{ position: "relative", width: 72, height: 72, margin: "0 auto 14px" }}>
          <svg width={72} height={72} viewBox="0 0 72 72" style={{ transform: "rotate(-90deg)" }}>
            <circle cx={36} cy={36} r={30} fill="none" stroke="var(--roam-border)" strokeWidth={4} />
            <circle
              cx={36}
              cy={36}
              r={30}
              fill="none"
              stroke={isError ? "#ef4444" : isDone ? "#22c55e" : "#3b82f6"}
              strokeWidth={4}
              strokeLinecap="round"
              strokeDasharray={`${2 * Math.PI * 30}`}
              strokeDashoffset={`${2 * Math.PI * 30 * (1 - progressFraction)}`}
              style={{
                transition: "stroke-dashoffset 0.6s cubic-bezier(0.4, 0, 0.2, 1), stroke 0.3s",
              }}
            />
          </svg>
          <div style={{ position: "absolute", inset: 0, display: "flex", alignItems: "center", justifyContent: "center" }}>
            {isError ? (
              <X size={26} style={{ color: "#ef4444" }} />
            ) : isDone ? (
              <Check
                size={26}
                style={{
                  color: "#22c55e",
                  animation: "roam-pop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
                }}
              />
            ) : (
              <Rocket
                size={24}
                style={{
                  color: "#3b82f6",
                  animation: "roam-pulse 1.5s ease-in-out infinite",
                }}
              />
            )}
          </div>
        </div>

        <div style={{ fontSize: 18, fontWeight: 800, color: "var(--roam-text)", letterSpacing: -0.3 }}>
          {isError ? "Something went wrong" : isDone ? "You're all set!" : "Building your trip"}
        </div>
        <div style={{ fontSize: 13, color: "var(--roam-text-muted)", marginTop: 4, fontWeight: 500 }}>
          {isError ? "Tap back to fix your stops and try again" : isDone ? "Your trip is saved and ready for offline" : "Hang tight — this takes a moment"}
        </div>
        {!isDone && !isError && (
          <div style={{ marginTop: 6 }}>
            <ElapsedTimer startedAt={startedAt} />
          </div>
        )}
      </div>

      <div style={{ width: "100%", maxWidth: 360, display: "flex", flexDirection: "column", gap: 2 }}>
        {PIPELINE_STEPS.map((step) => {
          const state = getStepState(step, phase);
          const isActive = state === "active";
          const isDoneStep = state === "done";

          return (
            <div
              key={step.id}
              style={{
                display: "flex",
                alignItems: "center",
                gap: 12,
                padding: "10px 14px",
                borderRadius: 12,
                background: isActive ? `${step.color}0D` : "transparent",
                transition: "background 0.3s, opacity 0.3s",
                opacity: state === "pending" ? 0.35 : 1,
              }}
            >
              <div
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 10,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  background: isDoneStep ? `${step.color}1A` : isActive ? `${step.color}1A` : "var(--roam-surface)",
                  border: isActive ? `1.5px solid ${step.color}40` : "1px solid var(--roam-border)",
                  color: isDoneStep || isActive ? step.color : "var(--roam-text-muted)",
                  transition: "all 0.3s",
                  flexShrink: 0,
                }}
              >
                {isActive ? <Spinner color={step.color} size={16} /> : isDoneStep ? <Check size={15} strokeWidth={3} /> : <span style={{ opacity: 0.5 }}>{step.icon}</span>}
              </div>

              <div style={{ flex: 1, minWidth: 0 }}>
                <div
                  style={{
                    fontSize: 13,
                    fontWeight: isActive ? 700 : 600,
                    color: isActive ? "var(--roam-text)" : isDoneStep ? "var(--roam-text)" : "var(--roam-text-muted)",
                    transition: "color 0.3s",
                  }}
                >
                  {isActive ? step.activeLabel : isDoneStep ? step.doneLabel : step.label}
                </div>
              </div>

              {isDoneStep && (
                <Check
                  size={14}
                  strokeWidth={3}
                  style={{
                    color: step.color,
                    flexShrink: 0,
                    animation: "roam-pop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)",
                  }}
                />
              )}
            </div>
          );
        })}
      </div>

      {isError && error && (
        <div
          style={{
            width: "100%",
            maxWidth: 360,
            padding: "10px 14px",
            borderRadius: 10,
            background: "rgba(239,68,68,0.06)",
            border: "1px solid rgba(239,68,68,0.15)",
            fontSize: 12,
            color: "#ef4444",
            fontWeight: 600,
            lineHeight: 1.4,
            wordBreak: "break-word",
          }}
        >
          {error}
        </div>
      )}

      {isError && (
        <button
          type="button"
          onClick={() => {
            haptic.light();
            onCancel();
          }}
          style={{
            all: "unset",
            cursor: "pointer",
            display: "inline-flex",
            alignItems: "center",
            gap: 6,
            padding: "10px 20px",
            borderRadius: 10,
            fontSize: 14,
            fontWeight: 700,
            color: "var(--roam-text)",
            background: "var(--roam-surface)",
            border: "1px solid var(--roam-border)",
            WebkitTapHighlightColor: "transparent",
          }}
        >
          <ArrowLeft size={16} />
          Back to editor
        </button>
      )}
    </div>
  );
}

/* ── Main Component ──────────────────────────────────────────────────── */

export function StopsEditor(props: {
  profile: string;
  onProfileChange: (p: string) => void;

  stops: TripStop[];
  onAddStop: (type?: "poi" | "via") => void;
  onRemoveStop: (id: string) => void;
  onReorderStop: (fromIdx: number, toIdx: number) => void;

  onEditStop: (id: string, patch: Partial<Pick<TripStop, "name" | "lat" | "lng">>) => void;
  onUseMyLocation: () => void;
  onSearchStop: (id: string) => void;
  onJoinPlan: () => void; // ✅ Added

  onBuildRoute: () => void;
  canBuildRoute: boolean;
  routing: boolean;
  error: string | null;

  onBuildOffline: () => void;

  onDownloadOffline: () => void;
  onSaveOffline: () => void;
  onResetOffline: () => void;

  offlinePhase: OfflineBuildPhase;
  offlineError: string | null;
  offlineManifest: OfflineBundleManifest | null;
  canDownloadOffline: boolean;

  savingOffline: boolean;
  savedOffline: boolean;
}) {
  const router = useRouter();

  // --- Smooth Drag Controller ---
  const [snapState, setSnapState] = useState<"peek" | "expanded">("peek");
  const [dragOffset, setDragOffset] = useState(0);
  const isDragging = useRef(false);
  const dragData = useRef({ startY: 0, lastY: 0, lastTime: 0, velocity: 0 });

  // Track when build started for elapsed timer
  const buildStartRef = useRef<number>(0);
  const isBuilding = props.offlinePhase !== "idle";

  useEffect(() => {
    if (isBuilding && props.offlinePhase !== "error") {
      setSnapState("expanded");
      if (buildStartRef.current === 0) buildStartRef.current = Date.now();
    }
  }, [isBuilding, props.offlinePhase]);

  useEffect(() => {
    if (props.offlinePhase === "idle") buildStartRef.current = 0;
  }, [props.offlinePhase]);

  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    if (isBuilding) return;
    isDragging.current = true;
    dragData.current = { startY: e.clientY, lastY: e.clientY, lastTime: Date.now(), velocity: 0 };
    e.currentTarget.setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!isDragging.current) return;
    const currentY = e.clientY;
    const currentTime = Date.now();
    const deltaY = currentY - dragData.current.lastY;
    const deltaTime = currentTime - dragData.current.lastTime;
    if (deltaTime > 0) dragData.current.velocity = deltaY / deltaTime;
    dragData.current.lastY = currentY;
    dragData.current.lastTime = currentTime;

    const totalDelta = currentY - dragData.current.startY;
    if (snapState === "expanded" && totalDelta < 0) setDragOffset(totalDelta * 0.15);
    else if (snapState === "peek" && totalDelta > 0) setDragOffset(totalDelta * 0.15);
    else setDragOffset(totalDelta);
  };

  const handlePointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
    isDragging.current = false;
    try {
      e.currentTarget.releasePointerCapture(e.pointerId);
    } catch {}

    const { velocity } = dragData.current;
    let snapped = false;

    if (snapState === "peek" && (dragOffset < -60 || velocity < -0.5)) {
      setSnapState("expanded");
      snapped = true;
    }
    if (snapState === "expanded" && (dragOffset > 60 || velocity > 0.5)) {
      setSnapState("peek");
      snapped = true;
    }
    if (snapped) haptic.tap();
    setDragOffset(0);
  };

  const peekOffsetStr = `calc(100% - 260px - var(--roam-safe-bottom))`;
  const baseTransform = snapState === "peek" ? peekOffsetStr : "0px";
  const finalTransform = `translateY(calc(${baseTransform} + ${dragOffset}px))`;

  const canSave = props.canBuildRoute && !props.savingOffline;

  return (
    <div
      className="trip-bottom-sheet-wrap"
      style={{
        transform: finalTransform,
        transition: isDragging.current ? "none" : "transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)",
      }}
    >
      <style>{`
        @keyframes roam-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes roam-pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(0.92); } }
        @keyframes roam-pop { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.15); } 100% { transform: scale(1); opacity: 1; } }
      `}</style>

      <div className="trip-bottom-sheet">
        {/* DRAG HEADER */}
        <div
          className="trip-sheet-header trip-interactive"
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
          style={{ cursor: isBuilding ? "default" : undefined }}
        >
          <div className="trip-drag-handle" />

          <div className="trip-row-between">
            <div>
              <h1 className="trip-h1">{isBuilding ? "Building Trip" : "Plan Trip"}</h1>
              <div className="trip-muted" style={{ marginTop: 2 }}>
                {isBuilding ? "Preparing your offline bundle" : "Add stops. Tap save. Done."}
              </div>
            </div>

            {/* ✅ Action Buttons (Join + User) */}
            <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
              <button
                type="button"
                className="trip-interactive"
                aria-label="Join Plan"
                title="Join Plan"
                onPointerDown={(e) => e.stopPropagation()} // Prevent drag conflict
                onClick={() => {
                  haptic.light();
                  props.onJoinPlan();
                }}
                style={{
                  height: 42,
                  padding: "0 14px",
                  borderRadius: 999,
                  display: "inline-flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: 6,
                  background: "var(--roam-surface)",
                  color: "var(--roam-text)",
                  border: "1px solid var(--roam-border)",
                  boxShadow: "var(--shadow-soft)",
                  WebkitTapHighlightColor: "transparent",
                  fontSize: 14,
                  fontWeight: 600,
                }}
              >
                <span style={{ fontSize: 16 }}>🔗</span>
                Join
              </button>

              <button
                type="button"
                className="trip-interactive trip-btn-icon"
                aria-label="Account"
                title="Account"
                onPointerDown={(e) => e.stopPropagation()} // Prevent drag conflict
                onClick={() => {
                  haptic.selection();
                  router.push("/login");
                }}
                style={{
                  width: 42,
                  height: 42,
                  borderRadius: 999,
                  display: "inline-flex",
                  alignItems: "center",
                  justifyContent: "center",
                  background: "var(--roam-surface)",
                  color: "var(--roam-text)",
                  border: "1px solid var(--roam-border)",
                  boxShadow: "var(--shadow-soft)",
                  WebkitTapHighlightColor: "transparent",
                }}
              >
                <UserRound size={18} />
              </button>
            </div>
          </div>
        </div>

        {/* CONTENT: either editor or build progress */}
        <div className="trip-sheet-content">
          {isBuilding ? (
            <BuildProgressView
              phase={props.offlinePhase as OfflineBuildPhase}
              error={props.offlineError}
              saved={props.savedOffline}
              startedAt={buildStartRef.current || Date.now()}
              onCancel={props.onResetOffline}
            />
          ) : (
            <>
              <div className="trip-flex-col">
                {props.stops.map((s, idx) => (
                  <StopRow
                    key={s.id ?? `${idx}`}
                    stop={s}
                    idx={idx}
                    count={props.stops.length}
                    onEdit={(patch) => {
                      if (s.id) props.onEditStop(s.id, patch);
                    }}
                    onSearch={() => {
                      if (s.id) {
                        haptic.tap();
                        props.onSearchStop(s.id);
                      }
                    }}
                    onRemove={() => {
                      if (s.id) {
                        haptic.medium();
                        props.onRemoveStop(s.id);
                      }
                    }}
                    onMoveUp={() => {
                      haptic.selection();
                      props.onReorderStop(idx, idx - 1);
                    }}
                    onMoveDown={() => {
                      haptic.selection();
                      props.onReorderStop(idx, idx + 1);
                    }}
                    onUseMyLocation={s.type === "start" ? props.onUseMyLocation : undefined}
                  />
                ))}
              </div>

              <div className="trip-actions" style={{ gridTemplateColumns: "1fr 1fr", marginTop: 8 }}>
                <button
                  type="button"
                  onClick={() => {
                    haptic.tap();
                    props.onAddStop("poi");
                  }}
                  className="trip-interactive trip-btn trip-btn-secondary"
                >
                  + Add Stop
                </button>

                <button
                  type="button"
                  onClick={() => {
                    haptic.medium();
                    hideKeyboard();
                    props.onBuildOffline();
                  }}
                  disabled={!canSave}
                  className="trip-interactive trip-btn trip-btn-primary"
                  style={{ display: "inline-flex", alignItems: "center", justifyContent: "center", gap: 8 }}
                >
                  <Rocket size={16} />
                  Let's do it
                </button>
              </div>

              {props.error && <div className="trip-err-box">{props.error}</div>}
            </>
          )}
        </div>
      </div>
    </div>
  );
}

===== src/components/trips/new/useNewTripDraft.ts =====

// src/components/trips/new/useNewTripDraft.ts
"use client";

import { useCallback, useMemo, useState } from "react";
import type { TripStop, TripStopType } from "@/lib/types/trip";
import { shortId } from "@/lib/utils/ids";
import type { NavCoord } from "@/lib/types/geo";

type StopPatch = Partial<Pick<TripStop, "type" | "name" | "lat" | "lng">>;

function ensureStartEnd(stops: TripStop[]): TripStop[] {
  let out = [...stops];
  const hasStart = out.some((s) => s.type === "start");
  const hasEnd = out.some((s) => s.type === "end");

  if (!hasStart) out = [{ id: shortId(), type: "start", name: "Start", lat: -27.4705, lng: 153.0260 }, ...out];
  if (!hasEnd) out = [...out, { id: shortId(), type: "end", name: "End", lat: -27.4698, lng: 153.0251 }];
  return out;
}

export function useNewTripDraft() {
  // Defaults are placeholders (Brisbane-ish) so UI isn’t empty.
  // User can tap “Use my location” for Start immediately.
  const [stops, setStops] = useState<TripStop[]>(
    ensureStartEnd([]),
  );

  const [profile, setProfile] = useState<string>("drive");
  const [prefs] = useState<Record<string, any>>({});
  const [avoid] = useState<string[]>([]);
  const [depart_at] = useState<string | null>(null);

  const [mapCenter, setMapCenter] = useState<NavCoord | null>(null);

  const updateStop = useCallback((id: string, patch: StopPatch) => {
    setStops((prev) =>
      prev.map((s) => (s.id === id ? { ...s, ...patch } : s)),
    );
  }, []);

  const addStop = useCallback((type: TripStopType = "poi") => {
    setStops((prev) => {
      const id = shortId();
      const center = mapCenter ?? { lat: prev[0]?.lat ?? -27.47, lng: prev[0]?.lng ?? 153.02 };
      const next: TripStop = { id, type, name: type === "poi" ? "Stop" : type, lat: center.lat, lng: center.lng };

      // insert before end if exists
      const endIdx = prev.findIndex((s) => s.type === "end");
      if (endIdx >= 0) {
        const out = [...prev];
        out.splice(endIdx, 0, next);
        return out;
      }
      return [...prev, next];
    });
  }, [mapCenter]);

  const removeStop = useCallback((id: string) => {
    setStops((prev) => {
      const s = prev.find((x) => x.id === id);
      if (!s) return prev;
      // never remove start/end (keep UX stable)
      if (s.type === "start" || s.type === "end") return prev;
      return prev.filter((x) => x.id !== id);
    });
  }, []);

  const reorderStop = useCallback((fromIdx: number, toIdx: number) => {
    setStops((prev) => {
      if (fromIdx < 0 || fromIdx >= prev.length) return prev;
      if (toIdx < 0 || toIdx >= prev.length) return prev;

      // lock start at 0, end at last
      const from = prev[fromIdx];
      const to = prev[toIdx];
      if (!from || !to) return prev;
      if (from.type === "start" || from.type === "end") return prev;
      if (to.type === "start" || to.type === "end") return prev;

      const out = [...prev];
      const [moved] = out.splice(fromIdx, 1);
      out.splice(toIdx, 0, moved);
      return out;
    });
  }, []);

  const useMyLocationForStart = useCallback(async () => {
    const start = stops.find((s) => s.type === "start");
    if (!start?.id) return;

    if (!("geolocation" in navigator)) return;

    const pos = await new Promise<GeolocationPosition>((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: true,
        timeout: 8000,
        maximumAge: 5000,
      });
    });

    updateStop(start.id, {
      lat: pos.coords.latitude,
      lng: pos.coords.longitude,
      name: "My location",
    });
    setMapCenter({ lat: pos.coords.latitude, lng: pos.coords.longitude });
  }, [stops, updateStop]);

  const stopSummary = useMemo(() => {
    const n = stops.length;
    const hasStart = stops.some((s) => s.type === "start");
    const hasEnd = stops.some((s) => s.type === "end");
    return { n, hasStart, hasEnd };
  }, [stops]);

  return {
    stops,
    profile,
    prefs,
    avoid,
    depart_at,

    mapCenter,
    setMapCenter,

    setStops,
    setProfile,
    addStop,
    removeStop,
    reorderStop,
    updateStop,
    useMyLocationForStart,

    stopSummary,
  };
}


===== src/components/ui/BottomTabBar.tsx =====

// src/components/ui/BottomTabBar.tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { memo, useCallback } from "react";
import type { ReactNode } from "react";
import { haptic } from "@/lib/native/haptics";

/* ── Types ────────────────────────────────────────────────────────────── */

type Tab = {
  key: string;
  href: string;
  label: string;
  /** Renders the icon — receives active state for filled/outlined swap */
  icon: (active: boolean) => ReactNode;
  /** Center raised button (Trip) */
  isCenter?: boolean;
  /** SOS emphasized styling */
  emergency?: boolean;
};

/* ── Class helper ─────────────────────────────────────────────────────── */

function cx(...names: (string | false | null | undefined)[]): string {
  return names.filter(Boolean).join(" ");
}

/* ── Icons ────────────────────────────────────────────────────────────
   Native convention: active = filled, inactive = outlined (stroke only).
   All icons are 24×24 viewBox, rendered at container size via CSS.
   Kept as inline SVG for zero-bundle-cost + instant paint.
   ──────────────────────────────────────────────────────────────────── */

/** Trip — map with fold lines (center tab, shown inside raised button) */
function IconTrip(active: boolean) {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      {active ? (
        <path
          fill="currentColor"
          d="M9 2.5L3.5 4.8a1 1 0 0 0-.5.9v15a.8.8 0 0 0 1.1.7L9 19l6 2.5 5.5-2.3a1 1 0 0 0 .5-.9v-15a.8.8 0 0 0-1.1-.7L15 5 9 2.5z"
        />
      ) : (
        <>
          <path
            fill="none"
            stroke="currentColor"
            strokeWidth="1.8"
            strokeLinejoin="round"
            d="M9 3L3.7 5.2a.8.8 0 0 0-.7.8V20a.6.6 0 0 0 .9.5L9 18.5l6 2.5 5.3-2.2a.8.8 0 0 0 .7-.8V4a.6.6 0 0 0-.9-.5L15 5.5 9 3z"
          />
          <line
            stroke="currentColor" strokeWidth="1.5"
            x1="9" y1="3" x2="9" y2="18.5" opacity="0.35"
          />
          <line
            stroke="currentColor" strokeWidth="1.5"
            x1="15" y1="5.5" x2="15" y2="21" opacity="0.35"
          />
        </>
      )}
    </svg>
  );
}

/** Explore — compass (discover places along route) */
function IconGuide(active: boolean) {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      {active ? (
        <>
          <circle fill="currentColor" cx="12" cy="12" r="10" />
          <path
            fill="var(--roam-surface, #f4efe6)"
            d="M14.5 7.5l-6 3-1 5 6-3z"
          />
        </>
      ) : (
        <>
          <circle
            fill="none" stroke="currentColor" strokeWidth="1.8"
            cx="12" cy="12" r="9.2"
          />
          <path
            fill="currentColor" opacity="0.85"
            d="M14.5 7.5l-6 3-1 5 6-3z"
          />
        </>
      )}
    </svg>
  );
}

/** SOS — shield with exclamation (emergency) */
function IconSos(active: boolean) {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      {active ? (
        <>
          <path
            fill="currentColor"
            d="M12 2L4 6v5.1c0 5.1 3.4 9.8 8 11 4.6-1.2 8-5.9 8-11V6l-8-4z"
          />
          <rect fill="var(--roam-surface, #f4efe6)" x="11" y="7" width="2" height="6" rx="1" />
          <rect fill="var(--roam-surface, #f4efe6)" x="11" y="15" width="2" height="2" rx="1" />
        </>
      ) : (
        <>
          <path
            fill="none" stroke="currentColor" strokeWidth="1.8" strokeLinejoin="round"
            d="M12 3L4.5 6.8v4.3c0 4.8 3.2 9.2 7.5 10.4 4.3-1.2 7.5-5.6 7.5-10.4V6.8L12 3z"
          />
          <line
            stroke="currentColor" strokeWidth="2" strokeLinecap="round"
            x1="12" y1="8" x2="12" y2="13"
          />
          <circle fill="currentColor" cx="12" cy="16" r="1.1" />
        </>
      )}
    </svg>
  );
}

/* ── Tab definitions (spec: New | Plans | Trip | Explore | SOS) ───────── */

const TABS: Tab[] = [
  { key: "guide",     href: "/guide",     label: "Guide",     icon: IconGuide },
  { key: "trip",    href: "/trip",    label: "Trip",    icon: IconTrip, isCenter: true },
  { key: "sos",     href: "/sos",     label: "SOS",     icon: IconSos, emergency: true },
];

/* ── Component ────────────────────────────────────────────────────────── */

export const BottomTabBar = memo(function BottomTabBar() {
  const pathname = usePathname();

  const resolveActive = useCallback(
    (href: string) =>
      pathname === href || (pathname ? pathname.startsWith(`${href}/`) : false),
    [pathname],
  );

  // "/" redirects to /trip per spec
  const activeKey =
    TABS.find((t) => resolveActive(t.href))?.key ??
    (pathname === "/" ? "trip" : null);

  return (
    <div className="roam-tabs-wrap" role="navigation" aria-label="Primary">
      <nav className="roam-tabs" role="tablist" aria-label="Primary tabs">
        {TABS.map((tab) => {
          const active = tab.key === activeKey;

          return (
            <Link
              key={tab.key}
              href={tab.href}
              role="tab"
              aria-selected={active}
              aria-label={tab.label}
              aria-current={active ? ("page" as const) : undefined}
              className={cx(
                "roam-tab",
                tab.isCenter && "roam-tab-center",
                active && "roam-tab-active",
                tab.emergency && "roam-tab-sos",
              )}
              data-active={active ? "true" : "false"}
              draggable={false}
              prefetch={false}
              onPointerDown={() => {
                if (!active) haptic.tap();
              }}
            >
              {tab.isCenter ? (
                /* ── Center raised Trip button ──────────────────────── */
                <>
                  <span className="roam-tab-bump" aria-hidden="true" />
                  <span className="roam-tab-inner">
                    <span className="roam-tab-icon" aria-hidden="true">
                      {tab.icon(active)}
                    </span>
                  </span>
                  <span className="roam-tab-label">{tab.label}</span>
                </>
              ) : (
                /* ── Standard tab ───────────────────────────────────── */
                <>
                  <span className="roam-tab-icon" aria-hidden="true">
                    {tab.icon(active)}
                  </span>
                  <span className="roam-tab-label">{tab.label}</span>
                </>
              )}
            </Link>
          );
        })}
      </nav>
    </div>
  );
});

===== src/components/ui/NotFoundClient.tsx =====

"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";

export function NotFoundClient() {
  const router = useRouter();

  return (
    <div
      className="trip-app-container trip-wrap-center"
      style={{
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        padding: "0 24px",
        textAlign: "center",
      }}
    >
      {/* Icon / Graphic Container */}
      <div 
        style={{ 
          width: 80, 
          height: 80, 
          backgroundColor: "var(--roam-surface-hover)", 
          borderRadius: "50%", 
          display: "grid", 
          placeItems: "center",
          marginBottom: 24,
          color: "var(--brand-ochre)"
        }}
      >
        <svg 
          width="40" 
          height="40" 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2.5" 
          strokeLinecap="round" 
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="10" />
          <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" />
        </svg>
      </div>

      <h1 className="trip-h1" style={{ marginBottom: 12 }}>
        Off the beaten track
      </h1>
      
      <p className="trip-muted" style={{ marginBottom: 32, maxWidth: 300, lineHeight: 1.5 }}>
        Looks like you've wandered a bit too far. We couldn't find the page you're looking for.
      </p>

      {/* Valid Next.js Link for the home route */}
      <Link 
        href="/" 
        style={{ textDecoration: "none", width: "100%", maxWidth: 300 }}
      >
        <button 
          className="trip-interactive trip-btn trip-btn-primary"
          style={{ width: "100%" }}
        >
          Return to Base
        </button>
      </Link>
      
      {/* Client-side router action for going back */}
      <div style={{ width: "100%", maxWidth: 300, marginTop: 16 }}>
        <button 
          onClick={() => router.back()}
          className="trip-interactive trip-btn trip-btn-secondary"
          style={{ width: "100%" }}
        >
          Go Back
        </button>
      </div>
    </div>
  );
}

===== src/components/ui/SyncStatusBadge.tsx =====

"use client";

import { usePlanSync } from "@/lib/hooks/usePlanSync";

/**
 * Tiny badge showing sync status. Drop this into headers, plan list rows, etc.
 *
 * States:
 * - Online + no pending  → green dot (synced)
 * - Online + syncing     → blue pulse (syncing)
 * - Online + pending > 0 → amber dot + count
 * - Offline              → grey dot + "Offline"
 */
export function SyncStatusBadge() {
  const { online, syncing, pendingCount } = usePlanSync();

  if (!online) {
    return (
      <span style={styles.badge}>
        <span style={{ ...styles.dot, background: "var(--roam-text-muted)" }} />
        <span className="trip-muted-small">Offline</span>
      </span>
    );
  }

  if (syncing) {
    return (
      <span style={styles.badge}>
        <span style={{ ...styles.dot, background: "var(--brand-sky)", animation: "fadeIn 1s ease-in-out infinite alternate" }} />
        <span className="trip-muted-small" style={{ color: "var(--brand-sky)" }}>Syncing…</span>
      </span>
    );
  }

  if (pendingCount > 0) {
    return (
      <span style={styles.badge}>
        <span style={{ ...styles.dot, background: "var(--brand-ochre)" }} />
        <span className="trip-muted-small" style={{ color: "var(--brand-ochre)" }}>{pendingCount} pending</span>
      </span>
    );
  }

  return (
    <span style={styles.badge}>
      <span style={{ ...styles.dot, background: "var(--roam-success)" }} />
      <span className="trip-muted-small" style={{ color: "var(--roam-success)" }}>Synced</span>
    </span>
  );
}

const styles: Record<string, React.CSSProperties> = {
  badge: {
    display: "inline-flex",
    alignItems: "center",
    gap: 6,
    padding: "4px 8px",
    background: "var(--roam-surface-hover)",
    borderRadius: "var(--r-pill)",
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: "50%",
    flexShrink: 0,
  },
};

===== src/components/ui/UserIconButton.tsx =====

"use client";

import { useRouter } from "next/navigation";
import { UserRound } from "lucide-react";
import { haptic } from "@/lib/native/haptics";

export function UserIconButton() {
  const router = useRouter();

  return (
    <button
      type="button"
      className="trip-interactive trip-btn-icon"
      aria-label="Account"
      title="Account"
      onClick={() => {
        haptic.selection();
        router.push("/login");
      }}
      style={{
        width: 42,
        height: 42,
        borderRadius: 999,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        background: "var(--roam-surface)",
        color: "var(--roam-text)",
        border: "1px solid var(--roam-border)",
        boxShadow: "var(--shadow-soft)",
      }}
    >
      <UserRound size={18} />
    </button>
  );
}


===== src/lib/api/assets.ts =====

// src/lib/api/assets.ts
//
// Roam Asset API (Hybrid — local tile server preferred, Supabase fallback)
//
// Invariants:
// - Styles are shipped inside the app bundle (static export): /public/offline/styles/*
// - PMTiles served from LOCAL tile server if basemap is installed (offline-first)
// - PMTiles fall back to Supabase Storage (public bucket) when tile server is not running
// - Glyphs: local tile server when running, CDN fallback
//
// The local tile server (RoamTileServer native plugin) serves files from device
// storage with proper Range/206 support for PMTiles streaming.

import {
  getTileServerUrl,
  isFullyOfflineCapable,
  getPmtilesUrl,
  getGlyphsUrl,
  getSpriteUrl,
} from "@/lib/offline/basemapManager";

/* ── Internals ────────────────────────────────────────────────────────── */

function safeId(id: string): string {
  return encodeURIComponent(id);
}

function trimSlashes(x: string) {
  return (x ?? "").replace(/^\/+|\/+$/g, "");
}

function supaBaseUrl(): string {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
  return url.replace(/\/+$/g, "");
}

function bucket(): string {
  return process.env.NEXT_PUBLIC_SUPABASE_TILES_BUCKET || "tiles";
}

function tilesPrefix(): string {
  return trimSlashes(process.env.NEXT_PUBLIC_SUPABASE_TILES_PREFIX || "tiles");
}

function joinPath(...parts: string[]) {
  return parts
    .filter(Boolean)
    .map((p) => trimSlashes(p))
    .filter(Boolean)
    .join("/");
}

function supaPublicObjectUrl(pathInBucket: string): string {
  const base = supaBaseUrl();
  if (!base) return `/${trimSlashes(pathInBucket)}`;
  const b = bucket();
  const p = trimSlashes(pathInBucket);
  return `${base}/storage/v1/object/public/${b}/${p}`;
}

/* ── Public API ──────────────────────────────────────────────────────── */

export const assetsApi = {
  /**
   * PMTiles URL — prefers local tile server, falls back to Supabase.
   *
   * When tile server is running:
   *   → pmtiles://http://127.0.0.1:8765/tiles/australia.pmtiles
   *
   * When tile server is NOT running (online mode):
   *   → pmtiles://https://xxx.supabase.co/storage/v1/object/public/tiles/tiles/australia.pmtiles
   */
  tileUrl(tileId: string = "australia"): string {
    const serverUrl = getTileServerUrl();
    if (serverUrl) {
      return `pmtiles://${serverUrl}/tiles/${safeId(tileId)}.pmtiles`;
    }
    // Fallback: Supabase remote
    const file = `${safeId(tileId)}.pmtiles`;
    const p = joinPath(tilesPrefix(), file);
    return `pmtiles://${supaPublicObjectUrl(p)}`;
  },

  /**
   * Raw tile URL without pmtiles:// prefix.
   * Used when constructing source objects directly.
   */
  tileUrlRaw(tileId: string = "australia"): string {
    const serverUrl = getTileServerUrl();
    if (serverUrl) {
      return `${serverUrl}/tiles/${safeId(tileId)}.pmtiles`;
    }
    const file = `${safeId(tileId)}.pmtiles`;
    const p = joinPath(tilesPrefix(), file);
    return supaPublicObjectUrl(p);
  },

  /**
   * Style JSON URL (always bundled, same-origin).
   *
   * Example:
   *   styleUrl("roam-basemap-vector-bright")
   *   → /offline/styles/roam-basemap-vector-bright.style.json
   */
  styleUrl(styleId: string): string {
    return `/offline/styles/${safeId(styleId)}.style.json`;
  },

  /**
   * Glyphs URL template — local tile server when available, CDN fallback.
   *
   * When local:  http://127.0.0.1:8765/glyphs/{fontstack}/{range}.pbf
   * When remote: https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf
   */
  glyphsUrl(): string {
    return getGlyphsUrl();
  },

  /**
   * Sprite URL — local tile server when available, undefined if none.
   * Returns the URL without file extension (MapLibre adds .json / .png).
   */
  spriteUrl(): string | undefined {
    return getSpriteUrl();
  },

  /**
   * Whether the local tile server is running and basemap is installed.
   * Use this to decide whether to show "offline ready" UI.
   */
  isLocalTileServerActive(): boolean {
    return isFullyOfflineCapable();
  },

  /**
   * Get the local tile server base URL, or null.
   */
  localServerUrl(): string | null {
    return getTileServerUrl();
  },
};

===== src/lib/api/bundle.ts =====

// src/lib/api/bundle.ts
import { api } from "./client";
import type { OfflineBundleManifest } from "@/lib/types/bundle";

export type BundleBuildRequest = {
  plan_id: string;
  route_key: string;
  geometry: string; // polyline6
  profile?: string; // default "drive"
  buffer_m?: number | null;
  max_edges?: number | null;
  styles?: string[]; // default []
};

export const bundleApi = {
  // POST /bundle/build -> OfflineBundleManifest
  build: (req: BundleBuildRequest) => api.post<OfflineBundleManifest>("/bundle/build", req),

  // GET /bundle/{plan_id} -> OfflineBundleManifest
  get: (plan_id: string) => api.get<OfflineBundleManifest>(`/bundle/${encodeURIComponent(plan_id)}`),

  // GET /bundle/{plan_id}/download -> zip
  // NOTE: client.ts is JSON oriented, so for binary we use fetch directly.
  downloadUrl: (plan_id: string) => {
    const base = (process.env.NEXT_PUBLIC_API_BASE ?? "").replace(/\/+$/, "");
    const path = `/bundle/${encodeURIComponent(plan_id)}/download`;
    return base ? `${base}${path}` : path;
  },
};


===== src/lib/api/client.ts =====

// src/lib/api/client.ts
export type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE";

export type ApiRequestOptions = {
  method?: HttpMethod;
  query?: Record<string, string | number | boolean | null | undefined>;
  headers?: Record<string, string | undefined>;
  body?: unknown; // JSON by default unless BodyInit-like
  signal?: AbortSignal;
  timeoutMs?: number;
  parseAs?: "json" | "text";
  /** Retry transient failures (timeout, network error). Default 0 = no retry. */
  retries?: number;
  /** Base delay between retries in ms. Exponential backoff applied. Default 1000. */
  retryDelayMs?: number;
};

export class ApiError extends Error {
  status: number;
  url: string;
  details?: unknown;

  constructor(args: { status: number; url: string; message: string; details?: unknown }) {
    super(args.message);
    this.name = "ApiError";
    this.status = args.status;
    this.url = args.url;
    this.details = args.details;
  }
}

function isBodyInitLike(v: unknown): v is BodyInit {
  return (
    typeof v === "string" ||
    v instanceof Blob ||
    v instanceof ArrayBuffer ||
    v instanceof FormData ||
    v instanceof URLSearchParams ||
    v instanceof ReadableStream
  );
}

function buildQueryString(
  query?: Record<string, string | number | boolean | null | undefined>,
): string {
  if (!query) return "";
  const params = new URLSearchParams();
  for (const [k, v] of Object.entries(query)) {
    if (v === undefined || v === null) continue;
    params.set(k, String(v));
  }
  const s = params.toString();
  return s ? `?${s}` : "";
}

function getApiBase(): string {
  const base = process.env.NEXT_PUBLIC_API_BASE;
  if (!base) return "";
  return base.replace(/\/+$/, "");
}

/** Remove undefined header values so the result is Record<string,string>. */
function sanitizeHeaders(input?: Record<string, string | undefined>): Record<string, string> {
  const out: Record<string, string> = {};
  if (!input) return out;
  for (const [k, v] of Object.entries(input)) {
    if (v === undefined) continue;
    out[k] = v;
  }
  return out;
}

function toNiceMessage(v: unknown): string {
  if (v == null) return "";
  if (typeof v === "string") return v;
  try {
    return JSON.stringify(v, null, 2);
  } catch {
    return String(v);
  }
}

/** Whether an error is transient and worth retrying */
function isTransient(err: unknown): boolean {
  // Abort due to timeout
  if (err instanceof DOMException && err.name === "AbortError") return true;
  // Network failures (DNS, connection refused, etc.)
  if (err instanceof TypeError && /fetch|network|failed/i.test(err.message)) return true;
  // Server errors that are typically transient
  if (err instanceof ApiError && (err.status === 502 || err.status === 503 || err.status === 504 || err.status === 429)) return true;
  return false;
}

export class ApiClient {
  private base: string;

  constructor(base?: string) {
    this.base = (base ?? getApiBase()).replace(/\/+$/, "");
  }

  async http<T>(path: string, opts: ApiRequestOptions = {}): Promise<T> {
    const retries = opts.retries ?? 0;
    const retryDelay = opts.retryDelayMs ?? 1_000;
    let lastError: unknown;

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        return await this._doFetch<T>(path, opts, attempt);
      } catch (err) {
        lastError = err;

        // Don't retry if caller explicitly aborted
        if (opts.signal?.aborted) throw err;
        // Don't retry non-transient errors
        if (!isTransient(err)) throw err;
        // Don't retry if we've exhausted attempts
        if (attempt >= retries) throw err;

        const delay = retryDelay * Math.pow(2, attempt); // 1s, 2s, 4s...
        console.warn(
          `[api] ${opts.method ?? "GET"} ${path} attempt ${attempt + 1} failed (${err instanceof Error ? err.message : err}), retrying in ${delay}ms…`,
        );
        await new Promise((r) => setTimeout(r, delay));
      }
    }

    throw lastError;
  }

  private async _doFetch<T>(path: string, opts: ApiRequestOptions, attempt: number): Promise<T> {
    const method = opts.method ?? "GET";
    const url = this.base
      ? `${this.base}${path}${buildQueryString(opts.query)}`
      : `${path}${buildQueryString(opts.query)}`;

    const headers: Record<string, string> = sanitizeHeaders(opts.headers);

    let body: BodyInit | undefined;

    if (opts.body !== undefined && opts.body !== null && method !== "GET") {
      if (isBodyInitLike(opts.body)) {
        body = opts.body;
      } else {
        if (!headers["Content-Type"]) headers["Content-Type"] = "application/json";
        body = JSON.stringify(opts.body);
      }
    }

    const timeoutMs = opts.timeoutMs ?? 120_000;
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), timeoutMs);

    // Bridge an external abort signal into our controller
    if (opts.signal) {
      if (opts.signal.aborted) controller.abort();
      else opts.signal.addEventListener("abort", () => controller.abort(), { once: true });
    }

    // ── Timing ────────────────────────────────────────────────────
    const t0 = performance.now();
    const tag = `[api] ${method} ${path}${attempt > 0 ? ` (retry #${attempt})` : ""}`;

    try {
      const res = await fetch(url, {
        method,
        headers,
        body,
        signal: controller.signal,
        cache: "no-store",
      });

      const elapsed = Math.round(performance.now() - t0);

      const parseAs = opts.parseAs ?? "json";
      const contentType = res.headers.get("content-type") || "";

      let payload: unknown = null;
      try {
        if (parseAs === "text") {
          payload = await res.text();
        } else if (contentType.includes("application/json")) {
          payload = await res.json();
        } else {
          const txt = await res.text();
          payload = txt ? txt : null;
        }
      } catch {
        payload = null;
      }

      if (!res.ok) {
        const detail =
          payload && typeof payload === "object" && payload !== null && "detail" in payload
            ? (payload as any).detail
            : null;

        const message =
          detail != null
            ? toNiceMessage(detail)
            : typeof payload === "string"
              ? payload
              : `HTTP ${res.status}`;

        console.warn(`${tag} → ${res.status} in ${elapsed}ms`, message);

        throw new ApiError({
          status: res.status,
          url,
          message,
          details: payload,
        });
      }

      // Log timing — warn if slow (>5s)
      if (elapsed > 5_000) {
        console.warn(`${tag} → ${res.status} in ${elapsed}ms ⚠ SLOW`);
      } else {
        console.debug(`${tag} → ${res.status} in ${elapsed}ms`);
      }

      return payload as T;
    } catch (err) {
      const elapsed = Math.round(performance.now() - t0);

      // Enrich timeout errors with a clearer message
      if (err instanceof DOMException && err.name === "AbortError") {
        console.error(`${tag} → TIMEOUT after ${elapsed}ms (limit: ${timeoutMs}ms)`);
        const timeoutErr = new Error(`Request timed out after ${Math.round(timeoutMs / 1000)}s: ${method} ${path}`);
        timeoutErr.name = "TimeoutError";
        (timeoutErr as any).elapsed = elapsed;
        (timeoutErr as any).url = url;
        throw timeoutErr;
      }

      // Network error logging
      if (err instanceof TypeError) {
        console.error(`${tag} → NETWORK ERROR after ${elapsed}ms:`, err.message);
      }

      throw err;
    } finally {
      clearTimeout(t);
    }
  }

  get<T>(path: string, opts: Omit<ApiRequestOptions, "method" | "body"> = {}) {
    return this.http<T>(path, { ...opts, method: "GET" });
  }

  post<T>(path: string, body?: unknown, opts: Omit<ApiRequestOptions, "method" | "body"> = {}) {
    return this.http<T>(path, { ...opts, method: "POST", body });
  }

  put<T>(path: string, body?: unknown, opts: Omit<ApiRequestOptions, "method" | "body"> = {}) {
    return this.http<T>(path, { ...opts, method: "PUT", body });
  }

  patch<T>(path: string, body?: unknown, opts: Omit<ApiRequestOptions, "method" | "body"> = {}) {
    return this.http<T>(path, { ...opts, method: "PATCH", body });
  }

  delete<T>(path: string, opts: Omit<ApiRequestOptions, "method" | "body"> = {}) {
    return this.http<T>(path, { ...opts, method: "DELETE" });
  }
}

export const api = new ApiClient();

===== src/lib/api/guide.ts =====

// src/lib/api/guide.ts
import { api } from "./client";
import type { GuideTurnRequest, GuideTurnResponse } from "@/lib/types/guide";

export const guideApi = {
  // POST /guide/turn -> GuideTurnResponse
  turn: (req: GuideTurnRequest) => api.post<GuideTurnResponse>("/guide/turn", req),
};


===== src/lib/api/health.ts =====

// src/lib/api/health.ts
import { api } from "./client";

export type HealthResponse = { ok: boolean };

export const healthApi = {
  get: () => api.get<HealthResponse>("/health"),
};


===== src/lib/api/index.ts =====

// src/lib/api/index.ts
export { api, ApiClient, ApiError } from "./client";

export { healthApi } from "./health";
export { navApi } from "./nav";
export { placesApi } from "./places";
export { bundleApi } from "./bundle";


===== src/lib/api/nav.ts =====

// src/lib/api/nav.ts
import { api } from "./client";
import type { BBox4 } from "@/lib/types/geo";
import type {
  NavPack,
  NavRequest,
  CorridorGraphMeta,
  CorridorGraphPack,
  TrafficOverlay,
  HazardOverlay,
  ElevationRequest,
  ElevationResponse,
} from "@/lib/types/navigation";

export type CorridorEnsureRequest = {
  route_key: string;
  geometry: string; // polyline6
  profile?: string; // default "drive"
  buffer_m?: number | null;
  max_edges?: number | null;
};

export type OverlayPollRequest = {
  bbox: BBox4;
  cache_seconds?: number | null;
  timeout_s?: number | null;
};

export type HazardsPollRequest = {
  bbox: BBox4;
  sources?: string[]; // default []
  cache_seconds?: number | null;
  timeout_s?: number | null;
};

export const navApi = {
  // POST /nav/route -> NavPack
  route: (req: NavRequest) => api.post<NavPack>("/nav/route", req),

  // POST /nav/corridor/ensure -> CorridorGraphMeta
  corridorEnsure: (req: CorridorEnsureRequest) =>
    api.post<CorridorGraphMeta>("/nav/corridor/ensure", req),

  // GET /nav/corridor/{corridor_key} -> CorridorGraphPack
  corridorGet: (corridor_key: string) =>
    api.get<CorridorGraphPack>(`/nav/corridor/${encodeURIComponent(corridor_key)}`),

  // POST /nav/elevation -> ElevationResponse
  elevation: (req: ElevationRequest) =>
    api.post<ElevationResponse>("/nav/elevation", req),

  // POST /nav/traffic/poll -> TrafficOverlay
  trafficPoll: (req: OverlayPollRequest) => api.post<TrafficOverlay>("/nav/traffic/poll", req),

  // POST /nav/hazards/poll -> HazardOverlay
  hazardsPoll: (req: HazardsPollRequest) => api.post<HazardOverlay>("/nav/hazards/poll", req),
};

===== src/lib/api/places.ts =====

// src/lib/api/places.ts
import { api } from "./client";
import type {
  PlacesRequest,
  PlacesPack,
  CorridorPlacesRequest,
  PlacesSuggestRequest,
  PlacesSuggestResponse,
} from "@/lib/types/places";

export const placesApi = {
  // POST /places/search -> PlacesPack
  search: (req: PlacesRequest) => api.post<PlacesPack>("/places/search", req),

  // POST /places/corridor -> PlacesPack
  // This endpoint is heavy: Overpass queries + Supa bulk upserts.
  // 30s default timeout is not enough — use 120s.
  corridor: (req: CorridorPlacesRequest) =>
    api.post<PlacesPack>("/places/corridor", req, { timeoutMs: 120_000 }),

  // POST /places/suggest -> PlacesSuggestResponse
  // Also heavy: multiple search rounds along the route.
  suggest: (req: PlacesSuggestRequest) =>
    api.post<PlacesSuggestResponse>("/places/suggest", req, { timeoutMs: 120_000 }),
};

===== src/lib/emergency/emergencyActions.ts =====

"use client";

import type { User } from "@supabase/supabase-js";
import type { EmergencyContact } from "@/lib/types/emergency";

import { upsertEmergencyContact, deleteEmergencyContact } from "@/lib/offline/emergencyStore";
import { enqueueEmergencyUpsert, enqueueEmergencyDelete } from "@/lib/offline/emergencyQueue";
import { emergencyPushQueue } from "@/lib/offline/emergencySync";

export async function saveEmergencyContactLocalFirst(args: {
  user: User | null;
  isOnline: boolean;
  contact: EmergencyContact;
}) {
  const saved = await upsertEmergencyContact(args.contact);

  // Queue the FULL contact so cloud gets timestamps too
  await enqueueEmergencyUpsert(saved);

  // Try immediate push, but do not fail the UX if it errors.
  if (args.user && args.isOnline) {
    try {
      await emergencyPushQueue(args.user);
    } catch (e) {
      // keep queued; autosync will surface the error in the page banner
      console.warn("[emergency] push failed, queued for retry:", e);
    }
  }

  return saved;
}

export async function deleteEmergencyContactLocalFirst(args: {
  user: User | null;
  isOnline: boolean;
  id: string;
}) {
  await deleteEmergencyContact(args.id);
  await enqueueEmergencyDelete({ id: args.id });

  if (args.user && args.isOnline) {
    try {
      await emergencyPushQueue(args.user);
    } catch (e) {
      console.warn("[emergency] delete push failed, queued for retry:", e);
    }
  }
}


===== src/lib/guide/addToTrip.ts =====

// src/lib/guide/addToTrip.ts
"use client";

import type { OfflinePlanRecord } from "@/lib/offline/plansStore";
import { updateOfflinePlanAtomic } from "@/lib/offline/plansStore";

import type { TripStop } from "@/lib/types/trip";
import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay } from "@/lib/types/navigation";
import type { PlacesPack, PlaceItem } from "@/lib/types/places";
import type { FuelAnalysis } from "@/lib/types/fuel";

import { putPack } from "@/lib/offline/packsStore";

// ✅ Use the async wrapper that recomputes fuel after A* reroute
import { rebuildNavpackOfflineWithFuel } from "@/lib/offline/rebuildNavpack";

// ✅ Online fuel analysis
import { analyzeFuel } from "@/lib/nav/fuelAnalysis";
import { getVehicleFuelProfile } from "@/lib/offline/fuelProfileStore";

import { healthApi } from "@/lib/api/health";
import { navApi } from "@/lib/api/nav";
import { placesApi } from "@/lib/api/places";

import { planSync } from "@/lib/offline/planSync";

export type RebuildMode = "auto" | "online" | "offline";

function ensureStopIds(stops: TripStop[]): TripStop[] {
  return (stops ?? []).map((s, i) =>
    s.id ? s : { ...s, id: `${Date.now()}_${i}_${Math.random().toString(16).slice(2)}` },
  );
}

function insertStopBeforeEnd(stops: TripStop[], next: TripStop): TripStop[] {
  const out = [...stops];
  const endIdx = out.findIndex((s) => (s.type ?? "poi") === "end");
  if (endIdx >= 0) out.splice(endIdx, 0, next);
  else out.push(next);
  return out;
}

async function backendHealthOk(): Promise<boolean> {
  try {
    const res = await healthApi.get();
    return !!res?.ok;
  } catch {
    return false;
  }
}

async function onlineRebuild(args: {
  plan: OfflinePlanRecord;
  stopsRaw: TripStop[];
  profile: string;
}) {
  const { plan, stopsRaw, profile } = args;

  const stops = ensureStopIds(stopsRaw);

  const nextNav = await navApi.route({ stops, profile, prefs: {}, avoid: [], depart_at: null });
  const geom = nextNav?.primary?.geometry;
  if (!geom) throw new Error("Backend returned navpack without primary.geometry");

  const meta = await navApi.corridorEnsure({
    route_key: nextNav.primary.route_key,
    geometry: geom,
    profile,
    buffer_m: null,
    max_edges: null,
  });
  const corridorKey = meta?.corridor_key;
  if (!corridorKey) throw new Error("corridorEnsure returned no corridor_key");

  const nextCorr = await navApi.corridorGet(corridorKey);

  let nextPlaces: PlacesPack | null = null;
  try {
    nextPlaces = await placesApi.corridor({
      corridor_key: corridorKey,
      geometry: geom,
      buffer_km: 15,
      limit: 8000,
    });
  } catch {
    nextPlaces = null;
  }

  let nextTraffic: TrafficOverlay | null = null;
  let nextHazards: HazardOverlay | null = null;
  const bbox = nextNav?.primary?.bbox;
  if (bbox) {
    try { nextTraffic = await navApi.trafficPoll({ bbox }); } catch { nextTraffic = null; }
    try { nextHazards = await navApi.hazardsPoll({ bbox, sources: [] }); } catch { nextHazards = null; }
  }

  // ── Fuel analysis on online rebuild ──
  let fuelAnalysis: FuelAnalysis | null = null;
  if (nextPlaces?.items?.length && geom) {
    try {
      const fuelProfile = await getVehicleFuelProfile();
      fuelAnalysis = analyzeFuel(
        geom,
        nextPlaces.items,
        fuelProfile,
        nextNav.primary.route_key,
      );
    } catch (e) {
      console.warn("[addToTrip] online fuel analysis failed:", e);
    }
  }

  await Promise.all([
    putPack(plan.plan_id, "navpack", nextNav),
    putPack(plan.plan_id, "corridor", nextCorr),
    nextPlaces ? putPack(plan.plan_id, "places", nextPlaces) : Promise.resolve(),
    nextTraffic ? putPack(plan.plan_id, "traffic", nextTraffic) : Promise.resolve(),
    nextHazards ? putPack(plan.plan_id, "hazards", nextHazards) : Promise.resolve(),
    fuelAnalysis ? putPack(plan.plan_id, "fuel_analysis", fuelAnalysis) : Promise.resolve(),
  ]);

  await updateOfflinePlanAtomic(plan.plan_id, {
    route_key: nextNav.primary.route_key,
    corridor_key: corridorKey,
    places_key: nextPlaces?.places_key ?? null,
    traffic_key: (nextTraffic as any)?.traffic_key ?? null,
    hazards_key: (nextHazards as any)?.hazards_key ?? null,
    preview: {
      stops,
      geometry: nextNav.primary.geometry,
      bbox: nextNav.primary.bbox,
      distance_m: nextNav.primary.distance_m,
      duration_s: nextNav.primary.duration_s,
      profile: nextNav.primary.profile,
    },
  });

  await planSync.enqueuePlanUpsert(plan.plan_id);

  return {
    navpack: nextNav as NavPack,
    corridor: nextCorr as CorridorGraphPack,
    places: nextPlaces as PlacesPack | null,
    traffic: nextTraffic,
    hazards: nextHazards,
    fuelAnalysis,
  };
}

async function offlineRebuild(args: {
  plan: OfflinePlanRecord;
  prevNavpack: NavPack;
  corridor: CorridorGraphPack;
  stopsRaw: TripStop[];
}) {
  const { plan, prevNavpack, corridor, stopsRaw } = args;

  const stops = ensureStopIds(stopsRaw);
  const route_key = prevNavpack?.primary?.route_key ?? plan.route_key;

  // ✅ Rebuild + reanalyze fuel (uses cached PlacesPack + vehicle profile)
  const { navpack: rebuilt, fuelAnalysis } = await rebuildNavpackOfflineWithFuel({
    planId: plan.plan_id,
    prevNavpack,
    corridor,
    stops,
    route_key,
    reason: "reroute",
  });

  await putPack(plan.plan_id, "navpack", rebuilt);
  if (fuelAnalysis) {
    await putPack(plan.plan_id, "fuel_analysis", fuelAnalysis);
  }
  await updateOfflinePlanAtomic(plan.plan_id, {
    route_key: rebuilt.primary.route_key,
    preview: {
      stops,
      geometry: rebuilt.primary.geometry,
      bbox: rebuilt.primary.bbox,
      distance_m: rebuilt.primary.distance_m,
      duration_s: rebuilt.primary.duration_s,
      profile: rebuilt.primary.profile,
    },
  });

  await planSync.enqueuePlanUpsert(plan.plan_id);

  return { navpack: rebuilt as NavPack, fuelAnalysis };
}

async function rebuildFromStops(args: {
  plan: OfflinePlanRecord;
  mode: RebuildMode;
  profile: string;
  prevNavpack: NavPack | null;
  corridor: CorridorGraphPack | null;
  stops: TripStop[];
}) {
  const { plan, mode, profile, prevNavpack, corridor, stops } = args;

  if (mode === "offline") {
    if (!prevNavpack || !corridor) throw new Error("Missing packs for offline rebuild");
    return offlineRebuild({ plan, prevNavpack, corridor, stopsRaw: stops });
  }

  if (mode === "online") {
    const ok = await backendHealthOk();
    if (!ok) throw new Error("Backend not reachable. Switch to Offline or go online.");
    return onlineRebuild({ plan, stopsRaw: stops, profile });
  }

  // auto
  const ok = await backendHealthOk();
  if (ok) return onlineRebuild({ plan, stopsRaw: stops, profile });

  if (!prevNavpack || !corridor) throw new Error("Backend offline and missing packs for offline rebuild.");

  try {
    return offlineRebuild({ plan, prevNavpack, corridor, stopsRaw: stops });
  } catch (e: any) {
    throw new Error(
      (e?.message ?? "Offline rebuild failed") +
        "\n\nBackend is offline. If stops moved outside the stored corridor, you must go online to refresh the corridor.",
    );
  }
}

/**
 * Canonical "Add to Trip" entrypoint.
 * Inserts the place as a POI stop before the end stop and rebuilds.
 */
export async function addPlaceToTrip(args: {
  plan: OfflinePlanRecord;
  place: PlaceItem;

  navpack: NavPack; // required because we need current stops
  corridor: CorridorGraphPack | null; // only required for offline path

  profile: string;
  mode?: RebuildMode;
}) {
  const { plan, place, navpack, corridor, profile, mode = "auto" } = args;

  const baseStops = ensureStopIds(navpack.req.stops);

  const nextStop: TripStop = {
    id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
    type: "poi",
    name: place.name,
    lat: place.lat,
    lng: place.lng,
  };

  const nextStops = insertStopBeforeEnd(baseStops, nextStop);

  return rebuildFromStops({
    plan,
    mode,
    profile,
    prevNavpack: navpack,
    corridor,
    stops: nextStops,
  });
}

===== src/lib/guide/guideEngine.ts =====

// src/lib/guide/guideEngine.ts
"use client";

import type { TripStop } from "@/lib/types/trip";
import type { NavPack, CorridorGraphPack, TrafficOverlay, HazardOverlay } from "@/lib/types/navigation";
import type { PlacesPack, PlacesSuggestResponse, PlaceItem } from "@/lib/types/places";
import type { OfflineBundleManifest } from "@/lib/types/bundle";

import type {
  GuidePack,
  GuideContext,
  GuideMsg,
  GuideTurnRequest,
  GuideTurnResponse,
  GuideToolCall,
  GuideToolResult,
  DiscoveredPlace,
  TripProgress,
  WirePlace,
  GuideAction,
} from "@/lib/types/guide";

import { guideApi } from "@/lib/api/guide";
import { placesApi } from "@/lib/api/places";
import { putGuidePack, getGuidePack, listGuidePacks } from "@/lib/offline/guidePacksStore";
import { haversineKm } from "@/lib/guide/tripProgress";
import { extractIntent, filterAndRankPlaces, type RankedPlace } from "@/lib/guide/intentMapper";

function nowIso() {
  return new Date().toISOString();
}

async function hashString(s: string): Promise<string> {
  const enc = new TextEncoder().encode(s);
  const buf = await crypto.subtle.digest("SHA-256", enc);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map((b) => b.toString(16).padStart(2, "0")).join("").slice(0, 24);
}

// ──────────────────────────────────────────────────────────────
// Wire payload limits
// ──────────────────────────────────────────────────────────────

const WIRE_MAX_THREAD = 10;
const WIRE_MAX_TOOL_RESULTS = 3;
const WIRE_MAX_ITEMS_PER_RESULT = 15;
const WIRE_MAX_RELEVANT_PLACES = 40;
const MAX_DISCOVERED_PLACES = 500;

// ──────────────────────────────────────────────────────────────
// Bootstrap
// ──────────────────────────────────────────────────────────────

export type GuideBootstrap = {
  planId?: string | null;
  label?: string | null;
  stops: TripStop[];
  navpack?: NavPack | null;
  corridor?: CorridorGraphPack | null;
  places?: PlacesPack | null;
  traffic?: TrafficOverlay | null;
  hazards?: HazardOverlay | null;
  manifest?: OfflineBundleManifest | null;
  progress?: TripProgress | null;
};

// ──────────────────────────────────────────────────────────────
// Context builders
// ──────────────────────────────────────────────────────────────

function summarizeTraffic(t?: TrafficOverlay | null) {
  if (!t) return null;
  const counts: Record<string, number> = {};
  for (const it of t.items ?? []) {
    const k = `${it.type ?? "unknown"}:${it.severity ?? "unknown"}`;
    counts[k] = (counts[k] ?? 0) + 1;
  }
  return {
    traffic_key: t.traffic_key,
    total: (t.items ?? []).length,
    counts,
    sample: (t.items ?? []).slice(0, 4).map((x) => ({
      id: x.id,
      type: x.type ?? "unknown",
      severity: x.severity ?? "unknown",
      headline: (x.headline ?? "").slice(0, 80),
    })),
  };
}

function summarizeHazards(h?: HazardOverlay | null) {
  if (!h) return null;
  const counts: Record<string, number> = {};
  for (const it of h.items ?? []) {
    const k = `${it.kind ?? "unknown"}:${it.severity ?? "unknown"}`;
    counts[k] = (counts[k] ?? 0) + 1;
  }
  return {
    hazards_key: h.hazards_key,
    total: (h.items ?? []).length,
    counts,
    sample: (h.items ?? []).slice(0, 4).map((x) => ({
      id: x.id,
      kind: x.kind ?? "unknown",
      severity: x.severity ?? "unknown",
      title: (x.title ?? "").slice(0, 80),
    })),
  };
}

function buildContext(args: GuideBootstrap): GuideContext {
  const { planId, label, stops, navpack, corridor, traffic, hazards, manifest, progress } = args;

  const route_key = navpack?.primary?.route_key ?? null;
  const geometry = navpack?.primary?.geometry ?? null;
  const bbox = navpack?.primary?.bbox ?? corridor?.bbox ?? null;
  const corridor_key = corridor?.corridor_key ?? (manifest?.corridor_key ?? null);

  const manifest_route_key = manifest?.route_key ?? null;
  const offline_stale = !!(manifest_route_key && route_key && manifest_route_key !== route_key);

  return {
    plan_id: planId ?? null,
    label: label ?? null,
    profile: navpack?.req?.profile ?? "drive",
    route_key,
    corridor_key,
    geometry: geometry ?? null,
    bbox: bbox ?? null,
    stops: stops ?? [],
    total_distance_m: navpack?.primary?.distance_m ?? null,
    total_duration_s: navpack?.primary?.duration_s ?? null,
    manifest_route_key,
    offline_stale,
    progress: progress ?? null,
    traffic_summary: summarizeTraffic(traffic),
    hazards_summary: summarizeHazards(hazards),
  };
}

// ──────────────────────────────────────────────────────────────
// Wire payload building
// ──────────────────────────────────────────────────────────────

/**
 * Extract compact extra fields from a PlaceItem's extra dict.
 * These are the fields the backend now populates from Overpass
 * (phone, website, opening_hours, fuel_types, socket_types, etc).
 * We pick them out explicitly so the LLM sees them.
 */
function pickPlaceExtras(item: PlaceItem | Record<string, any>): Record<string, any> {
  const extra: any = (item as any).extra ?? item;
  const out: Record<string, any> = {};

  // Contact & hours
  if (extra.phone) out.phone = String(extra.phone).slice(0, 40);
  if (extra.website) out.website = String(extra.website).slice(0, 120);
  if (extra.opening_hours) out.opening_hours = String(extra.opening_hours).slice(0, 50);
  if (extra.address) out.address = String(extra.address).slice(0, 60);

  // Fuel station specifics
  if (Array.isArray(extra.fuel_types) && extra.fuel_types.length > 0) {
    out.fuel_types = extra.fuel_types;
  }

  // EV charging specifics
  if (Array.isArray(extra.socket_types) && extra.socket_types.length > 0) {
    out.socket_types = extra.socket_types;
  }

  // Camping amenities
  if (extra.free === true) out.free = true;
  if (extra.has_water === true) out.has_water = true;
  if (extra.has_toilets === true) out.has_toilets = true;
  if (extra.powered_sites === true) out.powered_sites = true;

  return out;
}

function rankedToWire(places: RankedPlace[]): WirePlace[] {
  return places.map((p) => {
    // Pull website from extra if not on the RankedPlace directly
    const extra: any = (p as any).extra ?? {};
    const website =
      (p as any).website ??
      extra.website ??
      extra["contact:website"] ??
      null;

    return {
      id: p.id,
      name: p.name,
      lat: p.lat,
      lng: p.lng,
      category: p.category,
      dist_km: p.dist_km,
      ahead: p.ahead,
      locality: p.locality,
      hours: p.hours,
      phone: p.phone,
      website: website ? String(website).slice(0, 120) : null,
    };
  });
}

/**
 * Trim a tool result for the wire payload.
 *
 * IMPORTANT: We now include rich extra fields (phone, website,
 * opening_hours, fuel_types, socket_types, camping amenities)
 * so the LLM can make informed recommendations and emit
 * structured actions (web/call buttons) from tool result data.
 */
function trimToolResultForWire(tr: GuideToolResult): GuideToolResult {
  if (!tr.ok) return tr;
  const result = tr.result as any;

  if (tr.tool === "places_search" || tr.tool === "places_corridor") {
    const items = (result?.items ?? []) as any[];
    return {
      ...tr,
      result: {
        ...result,
        items: items.slice(0, WIRE_MAX_ITEMS_PER_RESULT).map((p: any) => {
          const extras = pickPlaceExtras(p);
          return {
            id: p.id,
            name: p.name,
            category: p.category,
            lat: p.lat,
            lng: p.lng,
            ...extras,
          };
        }),
      },
    };
  }

  if (tr.tool === "places_suggest") {
    const clusters = (result?.clusters ?? []) as any[];

    return {
      ...tr,
      result: {
        clusters: clusters.slice(0, 5).map((cl: any) => {
          const rawPack = cl?.places ?? null;
          const rawItems = (rawPack?.items ?? []) as any[];

          let lat = typeof cl?.lat === "number" ? cl.lat : null;
          let lng = typeof cl?.lng === "number" ? cl.lng : null;

          if ((lat == null || lng == null) && rawItems.length > 0) {
            let sumLat = 0;
            let sumLng = 0;
            let n = 0;
            for (const p of rawItems) {
              if (typeof p?.lat === "number" && typeof p?.lng === "number") {
                sumLat += p.lat;
                sumLng += p.lng;
                n++;
              }
            }
            if (n > 0) {
              lat = sumLat / n;
              lng = sumLng / n;
            }
          }

          return {
            idx: cl.idx,
            km_from_start: cl.km_from_start,
            lat: lat ?? 0,
            lng: lng ?? 0,

            places: rawPack
              ? {
                  ...rawPack,
                  items: rawItems.slice(0, 5).map((p: any) => {
                    const extras = pickPlaceExtras(p);
                    return {
                      id: p.id,
                      name: p.name,
                      category: p.category,
                      lat: p.lat,
                      lng: p.lng,
                      ...extras,
                    };
                  }),
                }
              : {
                  places_key: "missing",
                  req: {},
                  provider: "unknown",
                  created_at: nowIso(),
                  algo_version: "unknown",
                  items: [],
                },
          };
        }),
      },
    };
  }

  return tr;
}

/**
 * Build the wire payload for /guide/turn.
 *
 * KEY: Uses intent extraction on the latest user message to pre-filter
 * the full corridor places pack. The LLM sees 30-40 relevant places
 * immediately instead of 0 or 8000.
 */
function buildWireRequest(
  context: GuideContext,
  pack: GuidePack,
  preferredCategories: string[],
  corridorPlaces: PlaceItem[],
  progress: TripProgress | null,
): GuideTurnRequest {
  let latestUserText = "";
  for (let i = pack.thread.length - 1; i >= 0; i--) {
    if (pack.thread[i].role === "user") {
      latestUserText = pack.thread[i].content;
      break;
    }
  }

  let relevantPlaces: WirePlace[] = [];
  if (latestUserText && corridorPlaces.length > 0) {
    const intent = extractIntent(latestUserText);

    if (preferredCategories.length > 0 && intent.categories.length === 0) {
      intent.categories = preferredCategories as any[];
    }

    const ranked = filterAndRankPlaces(corridorPlaces, intent, progress, WIRE_MAX_RELEVANT_PLACES);
    relevantPlaces = rankedToWire(ranked);
  }

  return {
    context,
    thread: pack.thread.slice(-WIRE_MAX_THREAD),
    tool_results: pack.tool_results.slice(-WIRE_MAX_TOOL_RESULTS).map(trimToolResultForWire),
    preferred_categories: preferredCategories,
    relevant_places: relevantPlaces,
  };
}

// ──────────────────────────────────────────────────────────────
// Discovered places extraction
// ──────────────────────────────────────────────────────────────

function extractDiscoveredPlaces(toolResult: GuideToolResult, progress: TripProgress | null): DiscoveredPlace[] {
  const now = nowIso();
  const items: (PlaceItem & { _cluster_km?: number })[] = [];

  if (toolResult.tool === "places_search" || toolResult.tool === "places_corridor") {
    const pack = toolResult.result as PlacesPack;
    if (pack?.items) items.push(...pack.items);
  } else if (toolResult.tool === "places_suggest") {
    const resp = toolResult.result as PlacesSuggestResponse;
    for (const cluster of resp?.clusters ?? []) {
      if (cluster?.places?.items) {
        items.push(...cluster.places.items.map((p) => ({ ...p, _cluster_km: cluster.km_from_start })));
      }
    }
  }

  return items.map((item) => {
    const dist = progress ? haversineKm(progress.user_lat, progress.user_lng, item.lat, item.lng) : null;
    return {
      id: item.id,
      name: item.name,
      lat: item.lat,
      lng: item.lng,
      category: item.category,
      extra: item.extra,
      source_tool_id: toolResult.id,
      discovered_at: now,
      km_from_start: item._cluster_km ?? null,
      distance_from_user_km: dist != null ? Math.round(dist * 10) / 10 : null,
    };
  });
}

function mergeDiscoveries(existing: DiscoveredPlace[], incoming: DiscoveredPlace[]): DiscoveredPlace[] {
  const map = new Map<string, DiscoveredPlace>();
  for (const p of existing) map.set(p.id, p);
  for (const p of incoming) map.set(p.id, p);
  const all = Array.from(map.values());
  if (all.length > MAX_DISCOVERED_PLACES) {
    all.sort((a, b) => (b.discovered_at ?? "").localeCompare(a.discovered_at ?? ""));
    return all.slice(0, MAX_DISCOVERED_PLACES);
  }
  return all;
}

// ──────────────────────────────────────────────────────────────
// Create / Restore guide pack
// ──────────────────────────────────────────────────────────────

export async function createGuidePack(
  args: GuideBootstrap,
): Promise<{ guideKey: string; pack: GuidePack; context: GuideContext }> {
  const context = buildContext(args);
  const schema_version = "guide.v2";
  const algo_version = "guide.llm.v2";

  const fingerprint = JSON.stringify({
    schema_version,
    algo_version,
    planId: args.planId ?? null,
    route_key: context.route_key,
    corridor_key: context.corridor_key,
    seedStops: (args.stops ?? []).map((s) => [s.type ?? "poi", s.name ?? "", s.lat, s.lng]),
  });

  const guideKey = await hashString(fingerprint);

  const existingPack = await getGuidePack(args.planId ?? null, guideKey);
  if (existingPack && existingPack.thread.length > 0) {
    const restored: GuidePack = {
      ...existingPack,
      updated_at: nowIso(),
      last_progress: args.progress ?? existingPack.last_progress ?? null,
    };
    await putGuidePack(args.planId ?? null, guideKey, restored);
    return { guideKey, pack: restored, context };
  }

  const pack: GuidePack = {
    schema_version,
    algo_version,
    created_at: nowIso(),
    updated_at: nowIso(),
    plan_id: args.planId ?? null,
    route_key: context.route_key,
    corridor_key: context.corridor_key,
    manifest_route_key: context.manifest_route_key,
    thread: [],
    tool_calls: [],
    tool_results: [],
    discovered_places: [],
    last_progress: args.progress ?? null,
    resolution_map: {},
    trip_links: {},
  };

  await putGuidePack(args.planId ?? null, guideKey, pack);
  return { guideKey, pack, context };
}

export async function restoreLatestGuidePack(
  planId: string | null,
): Promise<{ guideKey: string; pack: GuidePack } | null> {
  const list = await listGuidePacks(planId);
  if (list.length === 0) return null;
  return { guideKey: list[0].guideKey, pack: list[0].pack };
}

// ──────────────────────────────────────────────────────────────
// Tool execution
// ──────────────────────────────────────────────────────────────

async function execToolCall(call: GuideToolCall, context: GuideContext): Promise<GuideToolResult> {
  const base = call as unknown as { id: string; tool: string; req?: unknown };
  try {
    if ((call as any).tool === "places_search") {
      const res = await placesApi.search((call as any).req);
      return { id: base.id, tool: base.tool as any, ok: true, result: res as any };
    }
    if ((call as any).tool === "places_corridor") {
      const corridorReq = { ...(call as any).req };
      if (context.geometry && !corridorReq.geometry) {
        corridorReq.geometry = context.geometry;
        corridorReq.buffer_km = corridorReq.buffer_km ?? 15;
      }
      const res = await placesApi.corridor(corridorReq);
      return { id: base.id, tool: base.tool as any, ok: true, result: res as any };
    }
    if ((call as any).tool === "places_suggest") {
      const res = await placesApi.suggest((call as any).req);
      return { id: base.id, tool: base.tool as any, ok: true, result: res as any };
    }
    return { id: base.id, tool: base.tool as any, ok: false, result: { error: "unknown tool" } as any };
  } catch (e: any) {
    return { id: base.id, tool: base.tool as any, ok: false, result: { error: e?.message ?? String(e) } as any };
  }
}

// ──────────────────────────────────────────────────────────────
// Send message (tool loop)
// ──────────────────────────────────────────────────────────────

export async function guideSendMessage(args: {
  planId?: string | null;
  guideKey: string;
  pack: GuidePack;
  context: GuideContext;
  userText: string;
  preferredCategories?: string[];
  maxSteps?: number;
  progress?: TripProgress | null;
  /** Full corridor places from IDB — used for intent-based pre-filtering */
  corridorPlaces?: PlaceItem[];
}): Promise<{ pack: GuidePack; assistantText: string }> {
  const {
    planId,
    guideKey,
    userText,
    preferredCategories = [],
    maxSteps = 4,
    progress,
    corridorPlaces = [],
  } = args;

  const context: GuideContext = {
    ...args.context,
    progress: progress ?? args.context.progress ?? null,
  };

  let pack: GuidePack = {
    ...args.pack,
    updated_at: nowIso(),
    thread: [...args.pack.thread, { role: "user", content: userText }],
    last_progress: progress ?? args.pack.last_progress ?? null,
  };

  await putGuidePack(planId ?? null, guideKey, pack);

  let assistantText = "";
  let steps = 0;

  while (steps < maxSteps) {
    steps++;

    const turnReq = buildWireRequest(context, pack, preferredCategories, corridorPlaces, progress ?? null);
    const turn: GuideTurnResponse = await guideApi.turn(turnReq);

    assistantText = turn.assistant ?? "";

    // Store structured actions directly on the assistant message so the
    // frontend can render them as pills without parsing markdown.
    const actions: GuideAction[] = Array.isArray(turn.actions) ? turn.actions : [];

    const assistantMsg: GuideMsg = {
      role: "assistant",
      content: assistantText,
      resolved_tool_id: null,
      actions,
    };

    pack = {
      ...pack,
      updated_at: nowIso(),
      thread: [...pack.thread, assistantMsg],
      tool_calls: [...pack.tool_calls, ...(turn.tool_calls ?? [])],
    };
    await putGuidePack(planId ?? null, guideKey, pack);

    if (turn.done || !turn.tool_calls || turn.tool_calls.length === 0) break;

    const call = turn.tool_calls[0];
    const toolRes = await execToolCall(call, context);

    const newPlaces = extractDiscoveredPlaces(toolRes, progress ?? null);
    const mergedPlaces = mergeDiscoveries(pack.discovered_places, newPlaces);

    const updatedThread = [...pack.thread];
    const lastMsg = updatedThread[updatedThread.length - 1];
    if (lastMsg && lastMsg.role === "assistant") {
      updatedThread[updatedThread.length - 1] = { ...lastMsg, resolved_tool_id: call.id };
    }

    pack = {
      ...pack,
      updated_at: nowIso(),
      thread: updatedThread,
      tool_results: [...pack.tool_results, toolRes],
      discovered_places: mergedPlaces,
    };
    await putGuidePack(planId ?? null, guideKey, pack);
  }

  return { pack, assistantText };
}

===== src/lib/guide/intentMapper.ts =====

// src/lib/guide/intentMapper.ts
"use client";

import type { PlaceCategory } from "@/lib/types/places";
import type { PlaceItem } from "@/lib/types/places";
import type { TripProgress } from "@/lib/types/guide";
import { haversineKm } from "@/lib/guide/tripProgress";

// ──────────────────────────────────────────────────────────────
// Keyword → Category mapping
//
// Each entry: array of keywords/phrases that map to one or more
// PlaceCategory values. Keywords are lowercase, matched as substrings.
// More specific phrases should come first for priority matching.
// ──────────────────────────────────────────────────────────────

type CategoryRule = {
  keywords: string[];
  categories: PlaceCategory[];
  /** Higher = more likely the user explicitly wants this */
  weight: number;
};

const RULES: CategoryRule[] = [
  // ── Fuel ──────────────────────────────────────────────────
  {
    keywords: [
      "fuel", "petrol", "diesel", "lpg", "gas station", "gas stop",
      "servo", "service station", "service stn", "refuel", "fill up",
      "unleaded", "e10", "98", "95", "bp", "shell", "caltex", "ampol",
      "united", "puma", "liberty",
    ],
    categories: ["fuel"],
    weight: 10,
  },

  // ── Camping & accommodation ──────────────────────────────
  {
    keywords: [
      "camp", "camping", "campsite", "camp site", "campground",
      "caravan", "caravan park", "rv park", "motorhome", "camper",
      "glamping", "tent", "swag", "free camp", "freecamp",
      "bush camp", "rest area", "overnight", "sleep rough",
    ],
    categories: ["camp"],
    weight: 10,
  },
  {
    keywords: [
      "hotel", "motel", "accommodation", "accomodation", "stay",
      "sleep", "lodge", "inn", "bnb", "b&b", "airbnb",
      "room", "cabin", "chalet",
    ],
    categories: ["hotel", "motel", "hostel"],
    weight: 9,
  },
  {
    keywords: ["hostel", "backpacker", "backpackers", "dorm"],
    categories: ["hostel"],
    weight: 9,
  },

  // ── Water ─────────────────────────────────────────────────
  {
    keywords: [
      "water", "drinking water", "tap water", "refill water",
      "water tank", "bore water", "potable",
    ],
    categories: ["water"],
    weight: 10,
  },

  // ── Toilets ───────────────────────────────────────────────
  {
    keywords: [
      "toilet", "toilets", "bathroom", "restroom", "rest room",
      "loo", "dunny", "wc", "amenities", "public toilet",
    ],
    categories: ["toilet"],
    weight: 10,
  },

  // ── Food & drink ──────────────────────────────────────────
  {
    keywords: [
      "coffee", "cafe", "café", "espresso", "latte", "barista",
    ],
    categories: ["cafe"],
    weight: 9,
  },
  {
    keywords: [
      "restaurant", "dining", "fine dining", "bistro",
    ],
    categories: ["restaurant"],
    weight: 9,
  },
  {
    keywords: [
      "fast food", "takeaway", "take away", "drive through",
      "drive thru", "maccas", "mcdonalds", "kfc", "hungry jacks",
      "subway", "nandos", "dominos", "pizza",
    ],
    categories: ["fast_food"],
    weight: 9,
  },
  {
    keywords: [
      "food", "eat", "eating", "lunch", "dinner", "breakfast",
      "brunch", "meal", "hungry", "snack", "bakery", "pie",
    ],
    categories: ["cafe", "restaurant", "fast_food"],
    weight: 8,
  },
  {
    keywords: [
      "pub", "beer", "ale", "brewery", "tap house",
    ],
    categories: ["pub"],
    weight: 8,
  },
  {
    keywords: [
      "bar", "cocktail", "wine bar", "drinks", "drink",
    ],
    categories: ["bar", "pub"],
    weight: 8,
  },

  // ── Grocery ───────────────────────────────────────────────
  {
    keywords: [
      "grocery", "groceries", "supermarket", "woolworths", "woolies",
      "coles", "iga", "aldi", "foodworks", "spar", "shops",
      "supplies", "provisions", "food shop",
    ],
    categories: ["grocery"],
    weight: 10,
  },

  // ── Medical ───────────────────────────────────────────────
  {
    keywords: [
      "hospital", "emergency", "er", "a&e", "medical", "doctor",
      "health", "clinic", "urgent care",
    ],
    categories: ["hospital"],
    weight: 10,
  },
  {
    keywords: [
      "pharmacy", "chemist", "drugstore", "medication", "medicine",
      "scripts", "prescription",
    ],
    categories: ["pharmacy"],
    weight: 10,
  },

  // ── Mechanical ────────────────────────────────────────────
  {
    keywords: [
      "mechanic", "garage", "repair", "tyre", "tire", "breakdown",
      "auto repair", "car repair", "workshop", "radiator",
      "battery", "alternator", "oil change",
    ],
    categories: ["mechanic"],
    weight: 10,
  },

  // ── Nature & scenic ───────────────────────────────────────
  {
    keywords: [
      "view", "viewpoint", "lookout", "look out", "scenic",
      "panorama", "vista", "overlook", "scenery",
    ],
    categories: ["viewpoint"],
    weight: 9,
  },
  {
    keywords: [
      "park", "national park", "nature", "hiking", "hike",
      "walk", "walking track", "trail", "bushwalk", "bush walk",
      "reserve", "conservation",
    ],
    categories: ["park"],
    weight: 8,
  },
  {
    keywords: [
      "beach", "surf", "coast", "coastal", "swim", "swimming",
      "ocean", "seaside", "shore",
    ],
    categories: ["beach"],
    weight: 9,
  },
  {
    keywords: [
      "attraction", "tourist", "museum", "gallery", "heritage",
      "monument", "landmark", "historical", "historic",
      "things to do", "see", "sightseeing", "sight seeing",
      "interesting", "worth seeing", "must see",
    ],
    categories: ["attraction", "viewpoint", "park"],
    weight: 7,
  },

  // ── Towns ─────────────────────────────────────────────────
  {
    keywords: [
      "town", "towns", "city", "settlement", "village",
      "next town", "nearest town", "closest town",
    ],
    categories: ["town"],
    weight: 9,
  },

  // ── Broad / "anything" queries ────────────────────────────
  {
    keywords: [
      "stop", "stops", "break", "rest", "pull over",
      "stretch", "stretch legs",
    ],
    categories: ["fuel", "cafe", "toilet", "camp", "town"],
    weight: 5,
  },
  {
    keywords: [
      "anything", "whatever", "what's around", "what's nearby",
      "what's ahead", "options", "suggestions", "suggest",
      "recommend", "what do you suggest", "ideas",
    ],
    categories: ["fuel", "cafe", "restaurant", "camp", "viewpoint", "town", "grocery"],
    weight: 3,
  },
];

// ──────────────────────────────────────────────────────────────
// Intent extraction
// ──────────────────────────────────────────────────────────────

export type ExtractedIntent = {
  /** Matched categories, deduplicated, ordered by weight */
  categories: PlaceCategory[];
  /** Highest weight match (0 if nothing matched) */
  confidence: number;
  /** Whether the user seems to be asking about proximity/distance */
  proximityQuery: boolean;
  /** Rough max distance in km if the user specified one (null otherwise) */
  maxDistanceKm: number | null;
};

/**
 * Extract intent from user text. Returns matched categories and metadata.
 * Uses substring matching — fast and good enough for mobile input.
 */
export function extractIntent(text: string): ExtractedIntent {
  const lower = text.toLowerCase().trim();

  const matched: { categories: PlaceCategory[]; weight: number }[] = [];

  for (const rule of RULES) {
    for (const kw of rule.keywords) {
      if (lower.includes(kw)) {
        matched.push({ categories: rule.categories, weight: rule.weight });
        break; // one match per rule is enough
      }
    }
  }

  // Deduplicate categories, keeping order by weight
  const catSet = new Set<PlaceCategory>();
  const sorted = [...matched].sort((a, b) => b.weight - a.weight);
  for (const m of sorted) {
    for (const c of m.categories) catSet.add(c);
  }

  // Proximity detection
  const proximityWords = [
    "near", "nearby", "nearest", "closest", "close",
    "next", "ahead", "coming up", "within", "around",
    "how far", "distance",
  ];
  const proximityQuery = proximityWords.some((w) => lower.includes(w));

  // Distance extraction: "within 50km", "next 100km", "80 km"
  let maxDistanceKm: number | null = null;
  const distMatch = lower.match(/(\d+)\s*(?:km|kilometer|kilometre|k)\b/i);
  if (distMatch) {
    maxDistanceKm = parseInt(distMatch[1], 10);
    if (maxDistanceKm > 2000) maxDistanceKm = null; // sanity check
  }

  return {
    categories: Array.from(catSet),
    confidence: sorted.length > 0 ? sorted[0].weight : 0,
    proximityQuery,
    maxDistanceKm,
  };
}

// ──────────────────────────────────────────────────────────────
// Place filtering & ranking
// ──────────────────────────────────────────────────────────────

/** A place with computed relevance metadata for the LLM */
export type RankedPlace = {
  id: string;
  name: string;
  lat: number;
  lng: number;
  category: PlaceCategory;
  /** Distance from user in km (null if no GPS) */
  dist_km: number | null;
  /** Estimated km along route from start (null if can't compute) */
  route_km: number | null;
  /** Is this place ahead of the user on the route? */
  ahead: boolean;
  /** Suburb / locality if available */
  locality: string | null;
  /** Opening hours if available */
  hours: string | null;
  /** Phone if available */
  phone: string | null;
};

function extractLocality(p: PlaceItem): string | null {
  const ex: any = p.extra ?? {};
  const tags = (ex?.tags && typeof ex.tags === "object") ? ex.tags : ex;
  return tags?.["addr:suburb"] || tags?.["addr:city"] || tags?.["addr:town"] || null;
}

function extractHours(p: PlaceItem): string | null {
  const ex: any = p.extra ?? {};
  const tags = (ex?.tags && typeof ex.tags === "object") ? ex.tags : ex;
  return tags?.opening_hours || null;
}

function extractPhone(p: PlaceItem): string | null {
  const ex: any = p.extra ?? {};
  const tags = (ex?.tags && typeof ex.tags === "object") ? ex.tags : ex;
  return tags?.phone || null;
}

/**
 * Filter, rank, and trim places for LLM injection.
 *
 * @param items - Full corridor places (up to 8000)
 * @param intent - Extracted intent from user message
 * @param progress - Current trip progress (for ahead-only filtering + distance)
 * @param maxResults - Cap on returned places (default 40)
 */
export function filterAndRankPlaces(
  items: PlaceItem[],
  intent: ExtractedIntent,
  progress: TripProgress | null,
  maxResults: number = 40,
): RankedPlace[] {
  // Step 1: Category filter
  let filtered: PlaceItem[];
  if (intent.categories.length > 0) {
    const catSet = new Set(intent.categories);
    filtered = items.filter((p) => catSet.has(p.category));
  } else {
    // No specific intent — return a diverse sample
    filtered = items;
  }

  // Step 2: Compute distance + ahead status
  const ranked: RankedPlace[] = filtered.map((p) => {
    let dist_km: number | null = null;
    let ahead = true; // default assume ahead if no progress

    if (progress) {
      dist_km = Math.round(
        haversineKm(progress.user_lat, progress.user_lng, p.lat, p.lng) * 10,
      ) / 10;

      // Simple ahead heuristic: if the place is roughly in the direction of travel
      // For now, use a simpler approach: places within 10km behind are OK,
      // but places clearly behind (using route leg comparison) are deprioritized.
      // Since we don't have per-place route_km, we use a bearing-based heuristic:
      // if user has heading, places behind bearing ±120° are "behind"
      if (progress.user_heading != null && dist_km > 5) {
        const bearing = bearingDeg(
          progress.user_lat, progress.user_lng,
          p.lat, p.lng,
        );
        const diff = Math.abs(angleDiff(progress.user_heading, bearing));
        if (diff > 120) {
          ahead = false;
        }
      }
    }

    return {
      id: p.id,
      name: p.name,
      lat: p.lat,
      lng: p.lng,
      category: p.category,
      dist_km,
      route_km: null, // we don't have this without per-place projection
      ahead,
      locality: extractLocality(p),
      hours: extractHours(p),
      phone: extractPhone(p),
    };
  });

  // Step 3: Distance filter (if user specified "within X km")
  let candidates = ranked;
  if (intent.maxDistanceKm != null && progress) {
    candidates = candidates.filter(
      (p) => p.dist_km != null && p.dist_km <= intent.maxDistanceKm!,
    );
  }

  // Step 4: Sort — ahead first, then by distance
  candidates.sort((a, b) => {
    // Ahead places first
    if (a.ahead && !b.ahead) return -1;
    if (!a.ahead && b.ahead) return 1;
    // Then by distance (nearest first)
    const da = a.dist_km ?? 9999;
    const db = b.dist_km ?? 9999;
    return da - db;
  });

  // Step 5: If no specific categories matched and we have too many, diversify
  if (intent.categories.length === 0 && candidates.length > maxResults) {
    return diverseSample(candidates, maxResults);
  }

  return candidates.slice(0, maxResults);
}

/**
 * When no specific category is requested, return a diverse sample
 * covering multiple categories rather than all being the same type.
 */
function diverseSample(places: RankedPlace[], limit: number): RankedPlace[] {
  const buckets = new Map<string, RankedPlace[]>();
  for (const p of places) {
    const cat = p.category;
    if (!buckets.has(cat)) buckets.set(cat, []);
    buckets.get(cat)!.push(p);
  }

  const result: RankedPlace[] = [];
  const catKeys = Array.from(buckets.keys());

  // Round-robin through categories, taking nearest first from each
  let round = 0;
  while (result.length < limit && round < 20) {
    for (const cat of catKeys) {
      const bucket = buckets.get(cat)!;
      if (round < bucket.length) {
        result.push(bucket[round]);
        if (result.length >= limit) break;
      }
    }
    round++;
  }

  return result;
}

// ──────────────────────────────────────────────────────────────
// Geo helpers
// ──────────────────────────────────────────────────────────────

const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

function bearingDeg(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const dLng = (lng2 - lng1) * DEG2RAD;
  const y = Math.sin(dLng) * Math.cos(lat2 * DEG2RAD);
  const x =
    Math.cos(lat1 * DEG2RAD) * Math.sin(lat2 * DEG2RAD) -
    Math.sin(lat1 * DEG2RAD) * Math.cos(lat2 * DEG2RAD) * Math.cos(dLng);
  return ((Math.atan2(y, x) * RAD2DEG) + 360) % 360;
}

function angleDiff(a: number, b: number): number {
  let d = b - a;
  while (d > 180) d -= 360;
  while (d < -180) d += 360;
  return d;
}

===== src/lib/guide/tripProgress.ts =====

// src/lib/guide/tripProgress.ts
"use client";

import type { TripStop } from "@/lib/types/trip";
import type { NavPack, NavLeg } from "@/lib/types/navigation";
import type { RoamPosition } from "@/lib/native/geolocation";
import type { TripProgress } from "@/lib/types/guide";

// ──────────────────────────────────────────────────────────────
// Geo utilities
// ──────────────────────────────────────────────────────────────

const DEG2RAD = Math.PI / 180;
const EARTH_R_KM = 6371;

/** Haversine distance in km between two lat/lng points */
export function haversineKm(
  lat1: number,
  lng1: number,
  lat2: number,
  lng2: number,
): number {
  const dLat = (lat2 - lat1) * DEG2RAD;
  const dLng = (lng2 - lng1) * DEG2RAD;
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1 * DEG2RAD) *
      Math.cos(lat2 * DEG2RAD) *
      Math.sin(dLng / 2) ** 2;
  return EARTH_R_KM * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/** Proximity threshold in km — if user is within this distance of a stop, mark visited */
const VISIT_PROXIMITY_KM = 0.5; // 500m

// ──────────────────────────────────────────────────────────────
// Current leg detection
// ──────────────────────────────────────────────────────────────

/**
 * Find which leg the user is currently on by checking which consecutive
 * stop pair the user is closest to (minimum "excess distance" heuristic).
 *
 * excess = dist(user, stop_i) + dist(user, stop_i+1) - dist(stop_i, stop_i+1)
 * The leg with minimum excess is the one the user is on or nearest to.
 */
function findCurrentLeg(
  userLat: number,
  userLng: number,
  stops: TripStop[],
): { legIdx: number; nearestStopIdx: number } {
  if (stops.length < 2) {
    return { legIdx: 0, nearestStopIdx: 0 };
  }

  let bestLeg = 0;
  let bestExcess = Infinity;

  for (let i = 0; i < stops.length - 1; i++) {
    const s1 = stops[i];
    const s2 = stops[i + 1];

    const dUser1 = haversineKm(userLat, userLng, s1.lat, s1.lng);
    const dUser2 = haversineKm(userLat, userLng, s2.lat, s2.lng);
    const dStops = haversineKm(s1.lat, s1.lng, s2.lat, s2.lng);

    // Excess: how much further the user is from the straight line between stops
    const excess = dUser1 + dUser2 - dStops;

    if (excess < bestExcess) {
      bestExcess = excess;
      bestLeg = i;
    }
  }

  // Nearest stop: compare user to the two stops of the best leg
  const s1 = stops[bestLeg];
  const s2 = stops[bestLeg + 1];
  const d1 = haversineKm(userLat, userLng, s1.lat, s1.lng);
  const d2 = haversineKm(userLat, userLng, s2.lat, s2.lng);

  const nearestStopIdx = d1 <= d2 ? bestLeg : bestLeg + 1;

  return { legIdx: bestLeg, nearestStopIdx };
}

// ──────────────────────────────────────────────────────────────
// km from start estimation
// ──────────────────────────────────────────────────────────────

/**
 * Estimate km from route start using leg distances from navpack.
 * Sum completed legs + interpolate within current leg.
 */
function estimateKmFromStart(
  legIdx: number,
  userLat: number,
  userLng: number,
  stops: TripStop[],
  legs: NavLeg[],
): { kmFromStart: number; totalKm: number } {
  let totalKm = 0;
  for (const leg of legs) {
    totalKm += leg.distance_m / 1000;
  }

  // Sum completed legs
  let kmFromStart = 0;
  for (let i = 0; i < legIdx && i < legs.length; i++) {
    kmFromStart += legs[i].distance_m / 1000;
  }

  // Interpolate within current leg
  if (legIdx < legs.length && legIdx < stops.length - 1) {
    const legStart = stops[legIdx];
    const legEnd = stops[legIdx + 1];

    const legLenKm = legs[legIdx].distance_m / 1000;
    const straightLineKm = haversineKm(
      legStart.lat,
      legStart.lng,
      legEnd.lat,
      legEnd.lng,
    );

    if (straightLineKm > 0.01) {
      // How far along this leg is the user (as a fraction of straight-line distance)
      const dFromStart = haversineKm(
        userLat,
        userLng,
        legStart.lat,
        legStart.lng,
      );
      const fraction = Math.min(1, Math.max(0, dFromStart / straightLineKm));
      kmFromStart += fraction * legLenKm;
    }
  }

  return { kmFromStart, totalKm };
}

// ──────────────────────────────────────────────────────────────
// Visited stop detection
// ──────────────────────────────────────────────────────────────

/**
 * Update the visited set: add any stop the user is within proximity of.
 * This is sticky — once visited, always visited.
 */
function updateVisitedStops(
  userLat: number,
  userLng: number,
  stops: TripStop[],
  prevVisited: string[],
): string[] {
  const visited = new Set(prevVisited);

  for (const stop of stops) {
    const id = stop.id;
    if (!id) continue;
    if (visited.has(id)) continue;

    const d = haversineKm(userLat, userLng, stop.lat, stop.lng);
    if (d <= VISIT_PROXIMITY_KM) {
      visited.add(id);
    }
  }

  return Array.from(visited);
}

// ──────────────────────────────────────────────────────────────
// Main: compute trip progress
// ──────────────────────────────────────────────────────────────

export type ComputeProgressArgs = {
  position: RoamPosition;
  stops: TripStop[];
  navpack: NavPack | null;
  prevProgress: TripProgress | null;
};

/**
 * Compute the user's current progress along the trip.
 *
 * Pure function (no side effects). Call this when:
 * - Page boots with GPS fix
 * - Before sending a guide message (to inject latest position)
 * - Periodically for the progress bar
 */
export function computeTripProgress(args: ComputeProgressArgs): TripProgress {
  const { position, stops, navpack, prevProgress } = args;

  const userLat = position.lat;
  const userLng = position.lng;

  // Find current leg and nearest stop
  const { legIdx, nearestStopIdx } = findCurrentLeg(userLat, userLng, stops);

  // Estimate km from start
  const legs = navpack?.primary?.legs ?? [];
  const { kmFromStart, totalKm } = estimateKmFromStart(
    legIdx,
    userLat,
    userLng,
    stops,
    legs,
  );

  // Update visited stops (sticky set)
  const prevVisited = prevProgress?.visited_stop_ids ?? [];
  const visitedStopIds = updateVisitedStops(
    userLat,
    userLng,
    stops,
    prevVisited,
  );

  // Use navpack total if available, otherwise use haversine sum
  const routeTotalKm =
    navpack?.primary?.distance_m != null
      ? navpack.primary.distance_m / 1000
      : totalKm;

  const kmRemaining = Math.max(0, routeTotalKm - kmFromStart);

  // Local time
  const now = new Date();
  let timezone = "Australia/Brisbane";
  try {
    timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch {
    // fallback
  }

  return {
    user_lat: userLat,
    user_lng: userLng,
    user_accuracy_m: position.accuracy,
    user_heading: position.heading,
    user_speed_mps: position.speed,

    current_stop_idx: nearestStopIdx,
    current_leg_idx: legIdx,

    visited_stop_ids: visitedStopIds,

    km_from_start: Math.round(kmFromStart * 10) / 10,
    km_remaining: Math.round(kmRemaining * 10) / 10,
    total_km: Math.round(routeTotalKm * 10) / 10,

    local_time_iso: now.toISOString(),
    timezone,

    updated_at: now.toISOString(),
  };
}

/**
 * Compute distance from a position to each stop, returning sorted by distance.
 * Useful for the UI to show "nearest stops" or for the LLM context.
 */
export function stopsWithDistances(
  userLat: number,
  userLng: number,
  stops: TripStop[],
): Array<TripStop & { distance_km: number }> {
  return stops
    .map((s) => ({
      ...s,
      distance_km:
        Math.round(haversineKm(userLat, userLng, s.lat, s.lng) * 10) / 10,
    }))
    .sort((a, b) => a.distance_km - b.distance_km);
}

===== src/lib/hooks/useActiveNavigation.ts =====

// src/hooks/useActiveNavigation.ts
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  type ActiveNavState,
  type ActiveNavConfig,
  DEFAULT_NAV_CONFIG,
  initialActiveNavState,
  startNavigation,
  stopNavigation,
  resetAfterReroute,
  updateActiveNav,
  buildFlatSteps,
} from "@/lib/nav/activeNav";
import {
  type VoiceState,
  initialVoiceState,
  shouldSpeak,
  applyAnnouncement,
  speak,
  cancelSpeech,
  speakFatigueWarning,
} from "@/lib/nav/voice";
import {
  type FatigueState,
  initialFatigueState,
  updateFatigue,
  fatigueEscalated,
} from "@/lib/nav/fatigue";
import {
  startBackgroundTracking,
  stopBackgroundTracking,
  isBackgroundTracking,
} from "@/lib/native/backgroundLocation";
import { haptic } from "@/lib/native/haptics";
import { decodePolyline6 } from "@/lib/nav/polyline6";
import type { NavPack } from "@/lib/types/navigation";
import type { RoamPosition } from "@/lib/native/geolocation";

// ──────────────────────────────────────────────────────────────
// Hook return type
// ──────────────────────────────────────────────────────────────

export type ActiveNavigationHook = {
  /** Current navigation state (position on route, ETA, etc.) */
  nav: ActiveNavState;
  /** Whether active navigation is running */
  isActive: boolean;
  /** Whether voice is muted */
  isMuted: boolean;
  /** Start active navigation — requests background GPS permission */
  start: () => Promise<void>;
  /** Stop active navigation — clears GPS watch */
  stop: () => void;
  /** Toggle voice mute */
  toggleMute: () => void;
  /** Reset after a corridor reroute with a new navpack */
  applyReroute: (newNavpack: NavPack) => void;
  /** Last GPS position from the navigation stream */
  lastPosition: RoamPosition | null;
};

// ──────────────────────────────────────────────────────────────
// Hook
// ──────────────────────────────────────────────────────────────

export function useActiveNavigation(
  navpack: NavPack | null,
  config: ActiveNavConfig = DEFAULT_NAV_CONFIG,
): ActiveNavigationHook {
  const [nav, setNav] = useState<ActiveNavState>(initialActiveNavState);
  const [lastPosition, setLastPosition] = useState<RoamPosition | null>(null);
  const [isMuted, setIsMuted] = useState(false);

  // Refs for values that change every tick (avoid stale closures)
  const navRef = useRef(nav);
  navRef.current = nav;
  const voiceRef = useRef<VoiceState>(initialVoiceState());
  const lastTickRef = useRef<number>(0);
  const navpackRef = useRef(navpack);
  navpackRef.current = navpack;
  const configRef = useRef(config);
  configRef.current = config;
  const isMutedRef = useRef(isMuted);
  isMutedRef.current = isMuted;

  // Precomputed data (expensive, memoize on navpack change)
  const flatSteps = useMemo(() => {
    if (!navpack) return [];
    return buildFlatSteps(navpack);
  }, [navpack]);

  const routeData = useMemo(() => {
    if (!navpack?.primary?.geometry) return { pts: [] as [number, number][], totalM: 0 };
    const decoded = decodePolyline6(navpack.primary.geometry);
    // decodePolyline6 returns [lng, lat][] for GeoJSON compat — we need [lat, lng][] for activeNav
    const pts: [number, number][] = decoded.map((p) => [p.lat, p.lng]);
    let totalM = 0;
    for (let i = 1; i < pts.length; i++) {
      const dlat = (pts[i][0] - pts[i - 1][0]) * Math.PI / 180;
      const dlng = (pts[i][1] - pts[i - 1][1]) * Math.PI / 180;
      const a = Math.sin(dlat / 2) ** 2 +
        Math.cos(pts[i - 1][0] * Math.PI / 180) * Math.cos(pts[i][0] * Math.PI / 180) *
        Math.sin(dlng / 2) ** 2;
      totalM += 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    return { pts, totalM };
  }, [navpack]);

  const flatStepsRef = useRef(flatSteps);
  flatStepsRef.current = flatSteps;
  const routeDataRef = useRef(routeData);
  routeDataRef.current = routeData;

  // ── GPS tick handler ──
  const handlePosition = useCallback((pos: RoamPosition) => {
    setLastPosition(pos);

    const currentNav = navRef.current;
    const currentNavpack = navpackRef.current;
    if (!currentNavpack || currentNav.status === "idle") return;

    const now = pos.timestamp || Date.now();
    const dt_s = lastTickRef.current > 0 ? (now - lastTickRef.current) / 1000 : 1;
    lastTickRef.current = now;

    // 1. Update navigation state
    const newNav = updateActiveNav(
      currentNav,
      pos,
      currentNavpack,
      flatStepsRef.current,
      routeDataRef.current.pts,
      routeDataRef.current.totalM,
      configRef.current,
    );

    // 2. Update fatigue
    const prevFatigue = currentNav.fatigue;
    const newFatigue = updateFatigue(prevFatigue, pos.speed, dt_s);
    newNav.fatigue = newFatigue;

    // 3. Check for fatigue escalation → voice + haptic
    if (fatigueEscalated(prevFatigue, newFatigue) && !isMutedRef.current) {
      const mins = Math.round(newFatigue.timeSinceLastRest_s / 60);
      speakFatigueWarning(mins);
      haptic.warning();
    }

    // 4. Check for off-route → haptic
    if (newNav.status === "off_route" && currentNav.status !== "off_route") {
      haptic.error();
    }

    // 5. Check for arrival → haptic
    if (newNav.status === "arrived" && currentNav.status !== "arrived") {
      haptic.success();
    }

    // 6. Voice announcements
    if (!isMutedRef.current) {
      const voiceState = { ...voiceRef.current, muted: false };
      const ann = shouldSpeak(newNav, voiceState, configRef.current);
      if (ann) {
        speak(ann.text);
        voiceRef.current = applyAnnouncement(voiceState, ann);
      }
    }

    setNav(newNav);
  }, []); // No deps — everything accessed via refs

  // ── Start ──
  const start = useCallback(async () => {
    if (!navpackRef.current) return;
    if (isBackgroundTracking()) return;

    // Initialize navigation state
    const initial = startNavigation(navpackRef.current);
    setNav(initial);
    navRef.current = initial;
    voiceRef.current = initialVoiceState();
    lastTickRef.current = 0;

    // Start GPS
    await startBackgroundTracking(handlePosition, (err) => {
      console.warn("[ActiveNav] GPS error:", err);
    });

    // Opening announcement
    const firstStep = navpackRef.current.primary.legs[0]?.steps?.[0];
    if (firstStep) {
      speak(`Starting navigation. ${firstStep.name ? `Head towards ${firstStep.name}.` : "Head out."}`);
    }

    haptic.medium();
  }, [handlePosition]);

  // ── Stop ──
  const stop = useCallback(() => {
    stopBackgroundTracking();
    cancelSpeech();
    setNav((prev) => stopNavigation(prev));
    setLastPosition(null);
    lastTickRef.current = 0;
    haptic.light();
  }, []);

  // ── Toggle mute ──
  const toggleMute = useCallback(() => {
    setIsMuted((m) => {
      const newMuted = !m;
      if (newMuted) cancelSpeech();
      return newMuted;
    });
    haptic.selection();
  }, []);

  // ── Reroute ──
  const applyReroute = useCallback((newNavpack: NavPack) => {
    const current = navRef.current;
    const newState = resetAfterReroute(current, newNavpack);
    setNav(newState);
    navRef.current = newState;
    voiceRef.current = initialVoiceState();
    speak("Route recalculated.");
    haptic.success();
  }, []);

  // ── Cleanup on unmount ──
  useEffect(() => {
    return () => {
      if (isBackgroundTracking()) {
        stopBackgroundTracking();
      }
      cancelSpeech();
    };
  }, []);

  const isActive = nav.status === "navigating" || nav.status === "off_route" || nav.status === "rerouting";

  return {
    nav,
    isActive,
    isMuted,
    start,
    stop,
    toggleMute,
    applyReroute,
    lastPosition,
  };
}

===== src/lib/hooks/useBasemapPack.ts =====

// src/lib/hooks/useBasemapPack.ts
//
// React hook wrapping basemapManager for UI components.
// Provides reactive state for download progress, install status,
// and tile server readiness.

"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { Capacitor } from "@capacitor/core";
import {
  type BasemapStatus,
  type TileServerInfo,
  getBasemapStatus,
  getTileServerInfo,
  downloadBasemap,
  cancelBasemapDownload,
  deleteBasemap,
  initBasemap,
  onBasemapStatusChange,
} from "@/lib/offline/basemapManager";

const DEFAULT_REGION = "australia";

export interface UseBasemapPackReturn {
  /** Current install/download status */
  status: BasemapStatus;
  /** Whether the tile server is running and serving tiles locally */
  serverReady: boolean;
  /** Tile server base URL (e.g. "http://127.0.0.1:8765") or null */
  serverUrl: string | null;
  /** Whether we're on a native platform (iOS/Android) */
  isNative: boolean;
  /** Whether the basemap is fully installed and server running */
  isOfflineReady: boolean;
  /** Start downloading the basemap */
  download: () => Promise<void>;
  /** Cancel an in-progress download */
  cancel: () => Promise<void>;
  /** Delete installed basemap */
  remove: () => Promise<void>;
  /** Re-check status from disk */
  refresh: () => Promise<void>;
}

export function useBasemapPack(region: string = DEFAULT_REGION): UseBasemapPackReturn {
  const [status, setStatus] = useState<BasemapStatus>({
    region,
    state: "not_installed",
    version: null,
    sizeBytes: 0,
    installedAt: null,
    error: null,
    downloadProgress: 0,
    downloadedBytes: 0,
    totalBytes: 0,
  });

  const [serverInfo, setServerInfo] = useState<TileServerInfo>({
    running: false,
    url: null,
    port: 0,
  });

  const isNative = Capacitor.isNativePlatform();
  const initRef = useRef(false);

  // Subscribe to status changes from basemapManager
  useEffect(() => {
    const unsub = onBasemapStatusChange((s) => {
      if (s.region === region) setStatus(s);
    });
    return unsub;
  }, [region]);

  // Init on mount
  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    (async () => {
      try {
        const s = await initBasemap(region);
        setStatus(s);
        setServerInfo(getTileServerInfo());
      } catch (e) {
        console.error("[useBasemapPack] init failed:", e);
      }
    })();
  }, [region]);

  const refresh = useCallback(async () => {
    const s = await getBasemapStatus(region);
    setStatus(s);
    setServerInfo(getTileServerInfo());
  }, [region]);

  const download = useCallback(async () => {
    try {
      await downloadBasemap(region);
      setServerInfo(getTileServerInfo());
    } catch (e: any) {
      // Status is already updated by basemapManager
      console.error("[useBasemapPack] download failed:", e);
    }
  }, [region]);

  const cancel = useCallback(async () => {
    await cancelBasemapDownload(region);
  }, [region]);

  const remove = useCallback(async () => {
    await deleteBasemap(region);
    setServerInfo(getTileServerInfo());
  }, [region]);

  const isOfflineReady = status.state === "installed" && serverInfo.running;

  return {
    status,
    serverReady: serverInfo.running,
    serverUrl: serverInfo.url,
    isNative,
    isOfflineReady,
    download,
    cancel,
    remove,
    refresh,
  };
}

===== src/lib/hooks/useBundleBuilder.ts =====

// src/lib/hooks/useBundleBuilder.ts
//
// React hook wrapping buildPlanBundle with phase/error/progress state.
// Used by /new page and invite redemption flow.
//
"use client";

import { useCallback, useRef, useState } from "react";
import {
  buildPlanBundle,
  phaseLabel,
  type BuildPhase,
  type BuildPlanBundleArgs,
  type BuildPlanBundleResult,
} from "@/lib/offline/buildPlanBundle";
import { haptic } from "@/lib/native/haptics";

export function useBundleBuilder() {
  const [phase, setPhase] = useState<BuildPhase>("idle");
  const [error, setError] = useState<string | null>(null);
  const [building, setBuilding] = useState(false);
  const [result, setResult] = useState<BuildPlanBundleResult | null>(null);
  const abortRef = useRef(false);

  const statusText = phaseLabel(phase, error);
  const isReady = phase === "ready" && result !== null;

  /**
   * Reset all state back to idle.
   */
  const reset = useCallback(() => {
    setPhase("idle");
    setError(null);
    setBuilding(false);
    setResult(null);
    abortRef.current = false;
  }, []);

  /**
   * Run the full bundle build pipeline.
   * Returns the result on success, throws on failure.
   */
  const build = useCallback(
    async (args: Omit<BuildPlanBundleArgs, "onPhase">): Promise<BuildPlanBundleResult> => {
      abortRef.current = false;
      setError(null);
      setPhase("idle");
      setResult(null);
      setBuilding(true);

      try {
        const res = await buildPlanBundle({
          ...args,
          onPhase: (p) => {
            if (!abortRef.current) setPhase(p);
          },
        });

        if (abortRef.current) throw new Error("Build cancelled");

        setResult(res);
        setPhase("ready");
        haptic.success();
        return res;
      } catch (e: any) {
        const msg = e?.message ?? "Failed to build offline bundle";
        setError(msg);
        setPhase("error");
        haptic.error();
        throw e;
      } finally {
        setBuilding(false);
      }
    },
    [],
  );

  /**
   * Cancel a running build (best-effort — network requests in flight
   * will still complete, but state updates stop).
   */
  const cancel = useCallback(() => {
    abortRef.current = true;
    setBuilding(false);
    setPhase("idle");
    setError(null);
  }, []);

  return {
    /** Current build phase */
    phase,
    /** Human-readable status text */
    statusText,
    /** Error message if phase === "error" */
    error,
    /** True while pipeline is running */
    building,
    /** True when build completed successfully */
    isReady,
    /** Result from last successful build */
    result,
    /** Run the pipeline */
    build,
    /** Reset to idle */
    reset,
    /** Cancel a running build */
    cancel,
  };
}

===== src/lib/hooks/useMapNavigationMode.ts =====

// src/hooks/useMapNavigationMode.ts
"use client";

import { useCallback, useEffect, useRef } from "react";
import type { Map as MLMap } from "maplibre-gl";
import type { RoamPosition } from "@/lib/native/geolocation";
import type { BBox4 } from "@/lib/types/geo";

// ──────────────────────────────────────────────────────────────
// Types
// ──────────────────────────────────────────────────────────────

export type MapNavMode = {
  /** Enable/disable navigation camera tracking */
  setActive: (active: boolean) => void;
  /** Zoom out to see full route bbox */
  showOverview: () => void;
  /** Re-center on user and resume tracking */
  recenter: () => void;
  /** Whether camera is currently in user-tracking mode (vs overview/manual) */
  isTracking: boolean;
};

type Opts = {
  mapRef: React.RefObject<MLMap | null>;
  position: RoamPosition | null;
  active: boolean;
  bbox: BBox4 | null;
};

// ──────────────────────────────────────────────────────────────
// Constants
// ──────────────────────────────────────────────────────────────

/** Zoom level during navigation tracking */
const NAV_ZOOM = 16;
/** Pitch for the slight 3D effect during nav */
const NAV_PITCH = 50;
/** Duration for smooth camera easing (ms) */
const EASE_DURATION = 600;
/** Fast ease for position updates (ms) */
const TRACK_DURATION = 1000;
/** If user manually pans, pause tracking for this long (ms) */
const MANUAL_PAN_COOLDOWN_MS = 8000;

// ──────────────────────────────────────────────────────────────
// Hook
// ──────────────────────────────────────────────────────────────

export function useMapNavigationMode({ mapRef, position, active, bbox }: Opts): MapNavMode {
  const isTrackingRef = useRef(true);
  const lastManualInteraction = useRef(0);
  const isActiveRef = useRef(active);
  isActiveRef.current = active;

  // ── Detect user manual interaction → pause tracking ──
  useEffect(() => {
    const map = mapRef.current;
    if (!map || !active) return;

    const onMoveStart = (e: any) => {
      // If the move was triggered programmatically (by us), ignore
      if (e.originalEvent) {
        // User-initiated pan/zoom/rotate
        lastManualInteraction.current = Date.now();
        isTrackingRef.current = false;
      }
    };

    map.on("movestart", onMoveStart);
    return () => {
      map.off("movestart", onMoveStart);
    };
  }, [mapRef, active]);

  // ── Enter/exit navigation camera mode ──
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    if (active) {
      // Enter nav mode: set pitch, disable compass rotation
      map.easeTo({
        pitch: NAV_PITCH,
        duration: EASE_DURATION,
      });
      isTrackingRef.current = true;
    } else {
      // Exit nav mode: reset to flat, north-up
      map.easeTo({
        pitch: 0,
        bearing: 0,
        duration: EASE_DURATION,
      });
      isTrackingRef.current = false;

      // Refit to route bbox
      if (bbox) {
        setTimeout(() => {
          try {
            map.fitBounds(
              [
                [bbox.minLng, bbox.minLat],
                [bbox.maxLng, bbox.maxLat],
              ],
              { padding: 60, duration: EASE_DURATION },
            );
          } catch {}
        }, EASE_DURATION + 50);
      }
    }
  }, [mapRef, active, bbox]);

  // ── Track user position ──
  useEffect(() => {
    const map = mapRef.current;
    if (!map || !active || !position) return;

    // If user manually panned, wait for cooldown
    const timeSinceManual = Date.now() - lastManualInteraction.current;
    if (timeSinceManual < MANUAL_PAN_COOLDOWN_MS) {
      // Still in manual mode — just update the user-is-tracking flag
      // After cooldown expires, we'll resume tracking
      const remaining = MANUAL_PAN_COOLDOWN_MS - timeSinceManual;
      const timer = setTimeout(() => {
        isTrackingRef.current = true;
      }, remaining);
      return () => clearTimeout(timer);
    }

    if (!isTrackingRef.current) {
      isTrackingRef.current = true;
    }

    // Compute bearing from heading (if available and moving)
    const bearing = position.heading != null && position.speed != null && position.speed > 1
      ? position.heading
      : map.getBearing(); // keep current bearing if stationary

    // Adaptive zoom: zoom out slightly at high speed
    let zoom = NAV_ZOOM;
    if (position.speed != null) {
      const kph = position.speed * 3.6;
      if (kph > 110) zoom = 14;
      else if (kph > 80) zoom = 14.5;
      else if (kph > 50) zoom = 15;
      else if (kph > 20) zoom = 15.5;
    }

    // Offset center slightly below screen center so the route ahead is more visible
    // In heading-up mode with pitch, the camera naturally shows more ahead
    map.easeTo({
      center: [position.lng, position.lat],
      bearing,
      zoom,
      pitch: NAV_PITCH,
      duration: TRACK_DURATION,
      easing: (t: number) => t, // linear for smooth tracking
    });
  }, [mapRef, active, position]);

  // ── Overview: zoom out to full route ──
  const showOverview = useCallback(() => {
    const map = mapRef.current;
    if (!map || !bbox) return;

    isTrackingRef.current = false;
    lastManualInteraction.current = Date.now();

    map.easeTo({ pitch: 0, bearing: 0, duration: EASE_DURATION / 2 });

    setTimeout(() => {
      try {
        map.fitBounds(
          [
            [bbox.minLng, bbox.minLat],
            [bbox.maxLng, bbox.maxLat],
          ],
          { padding: 60, duration: EASE_DURATION },
        );
      } catch {}
    }, EASE_DURATION / 2 + 50);
  }, [mapRef, bbox]);

  // ── Recenter: snap back to user ──
  const recenter = useCallback(() => {
    const map = mapRef.current;
    if (!map || !position) return;

    lastManualInteraction.current = 0;
    isTrackingRef.current = true;

    const bearing =
      position.heading != null && position.speed != null && position.speed > 1
        ? position.heading
        : 0;

    map.easeTo({
      center: [position.lng, position.lat],
      bearing,
      zoom: NAV_ZOOM,
      pitch: NAV_PITCH,
      duration: EASE_DURATION,
    });
  }, [mapRef, position]);

  // ── Imperative activation ──
  const setActive = useCallback(
    (a: boolean) => {
      // This is handled by the active prop reactively,
      // but exposed for programmatic control if needed
      isTrackingRef.current = a;
      if (a && position) {
        recenter();
      }
    },
    [recenter, position],
  );

  return {
    setActive,
    showOverview,
    recenter,
    isTracking: isTrackingRef.current,
  };
}

===== src/lib/hooks/usePlanSync.ts =====

// src/lib/hooks/usePlanSync.ts
"use client";

import { useCallback, useEffect, useState } from "react";
import { planSync } from "@/lib/offline/planSync";
import { getPendingCount } from "@/lib/offline/syncQueue";
import { networkMonitor } from "@/lib/offline/networkMonitor";

/**
 * Hook for components that need to interact with the sync system.
 *
 * Provides:
 *   - online: current network status
 *   - pendingCount: number of queued sync ops
 *   - syncing: true while drain is in progress
 *   - forceDrain: manually trigger a queue drain
 *   - createInvite: create an invite code for a plan
 *   - redeemInvite: redeem an invite code
 */
export function usePlanSync() {
  const [online, setOnline] = useState(networkMonitor.online);
  const [syncing, setSyncing] = useState(false);
  const [pendingCount, setPendingCount] = useState(0);

  // Subscribe to network changes
  useEffect(() => {
    const unsub = networkMonitor.subscribe((isOnline) => setOnline(isOnline));
    return unsub;
  }, []);

  // Subscribe to sync events + refresh pending count
  useEffect(() => {
    const refreshCount = () => {
      getPendingCount().then(setPendingCount).catch(() => {});
    };

    refreshCount();

    const unsub = planSync.subscribe((event) => {
      if (event === "drain_start") setSyncing(true);
      if (event === "drain_end" || event === "error") {
        setSyncing(false);
        refreshCount();
      }
      if (event === "pull_complete") refreshCount();
    });

    // Also refresh count periodically when online
    const interval = setInterval(refreshCount, 10_000);

    return () => {
      unsub();
      clearInterval(interval);
    };
  }, []);

  const forceDrain = useCallback(async () => {
    await planSync.drainQueue();
  }, []);

  const createInvite = useCallback(async (planId: string) => {
    return planSync.createInviteCode(planId);
  }, []);

  const redeemInvite = useCallback(async (code: string) => {
    return planSync.redeemInviteCode(code);
  }, []);

  return {
    online,
    syncing,
    pendingCount,
    forceDrain,
    createInvite,
    redeemInvite,
  };
}

===== src/lib/native/appLifecycle.ts =====

// src/lib/native/appLifecycle.ts
"use client";

import { isNative, hasPlugin } from "./platform";

type LifecycleListener = (state: "foreground" | "background") => void;

const _listeners = new Set<LifecycleListener>();

/**
 * Subscribe to app foreground/background transitions.
 *
 * On native: uses Capacitor App plugin.
 * On web: uses visibilitychange event.
 *
 * Returns unsubscribe function.
 *
 * Usage:
 *   const unsub = onAppStateChange((state) => {
 *     if (state === "foreground") planSync.drainQueue();
 *   });
 */
export function onAppStateChange(fn: LifecycleListener): () => void {
  _listeners.add(fn);
  return () => _listeners.delete(fn);
}

function _emit(state: "foreground" | "background") {
  for (const fn of _listeners) {
    try {
      fn(state);
    } catch (e) {
      console.error("[AppLifecycle] listener error", e);
    }
  }
}

let _initialized = false;

/**
 * Initialize lifecycle listeners. Call once at boot.
 */
export async function initAppLifecycle(): Promise<void> {
  if (_initialized) return;
  _initialized = true;

  if (isNative && hasPlugin("App")) {
    try {
      const { App } = await import("@capacitor/app");

      // Foreground (app resumed)
      await App.addListener("appStateChange", ({ isActive }) => {
        _emit(isActive ? "foreground" : "background");
      });

      // Back button (Android) — prevent accidental exit
      await App.addListener("backButton", ({ canGoBack }) => {
        if (canGoBack) {
          window.history.back();
        }
        // Don't exit app — user must use the system gesture
      });
    } catch (e) {
      console.warn("[AppLifecycle] native init failed", e);
      _setupWebFallback();
    }
  } else {
    _setupWebFallback();
  }
}

function _setupWebFallback() {
  if (typeof document === "undefined") return;
  document.addEventListener("visibilitychange", () => {
    _emit(document.hidden ? "background" : "foreground");
  });
}

===== src/lib/native/backgroundLocation.ts =====

// src/lib/native/backgroundLocation.ts
//
// Background-capable GPS tracking for active navigation.
//
// This wraps @capacitor/geolocation specifically for the active navigation
// use case where we need continuous position updates even when the screen
// is off or the user switches to Spotify.
//
// Different from useGeolocation hook:
//   - useGeolocation is for general map centering (foreground only)
//   - backgroundLocation is for active TBT navigation (background-capable)
//
// iOS requirements (in Info.plist):
//   NSLocationAlwaysAndWhenInUseUsageDescription
//   UIBackgroundModes: ["location", "audio"]
//
// Android requirements (in AndroidManifest.xml):
//   ACCESS_FINE_LOCATION, ACCESS_BACKGROUND_LOCATION,
//   FOREGROUND_SERVICE, FOREGROUND_SERVICE_LOCATION

import { Geolocation } from "@capacitor/geolocation";
import { isNative } from "./platform";
import type { RoamPosition } from "./geolocation";

let watchId: string | null = null;
let lastPosition: RoamPosition | null = null;

export type PositionCallback = (pos: RoamPosition) => void;
export type ErrorCallback = (err: any) => void;

/**
 * Start continuous background-capable GPS tracking.
 *
 * Calls onPosition every ~1 second with high-accuracy GPS data.
 * On iOS, this keeps GPS alive in the background if Info.plist
 * is configured correctly.
 *
 * Safe to call multiple times — if already tracking, does nothing.
 */
export async function startBackgroundTracking(
  onPosition: PositionCallback,
  onError?: ErrorCallback,
): Promise<void> {
  if (watchId !== null) return; // already tracking

  // Check permissions first
  try {
    const status = await Geolocation.checkPermissions();
    if (status.location !== "granted" && status.coarseLocation !== "granted") {
      const req = await Geolocation.requestPermissions();
      if (req.location !== "granted" && req.coarseLocation !== "granted") {
        onError?.(new Error("Location permission denied"));
        return;
      }
    }
  } catch (e) {
    onError?.(e);
    return;
  }

  try {
    watchId = await Geolocation.watchPosition(
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
      (position, err) => {
        if (err) {
          onError?.(err);
          return;
        }
        if (!position) return;

        const rp: RoamPosition = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy ?? 999,
          altitude: position.coords.altitude ?? null,
          altitudeAccuracy: position.coords.altitudeAccuracy ?? null,
          heading: position.coords.heading ?? null,
          speed: position.coords.speed ?? null,
          timestamp: position.timestamp,
        };

        lastPosition = rp;
        onPosition(rp);
      },
    );
  } catch (e) {
    onError?.(e);
  }
}

/**
 * Stop background GPS tracking.
 * Safe to call multiple times or when not tracking.
 */
export async function stopBackgroundTracking(): Promise<void> {
  if (watchId !== null) {
    try {
      await Geolocation.clearWatch({ id: watchId });
    } catch {
      // ignore — watch may already be cleared
    }
    watchId = null;
  }
  lastPosition = null;
}

/**
 * Whether we're currently tracking in background mode.
 */
export function isBackgroundTracking(): boolean {
  return watchId !== null;
}

/**
 * Get the last known position from background tracking.
 * Returns null if not tracking or no position received yet.
 */
export function getLastBackgroundPosition(): RoamPosition | null {
  return lastPosition;
}

===== src/lib/native/browser.ts =====

// src/lib/native/browser.ts
"use client";

import { isNative, hasPlugin } from "./platform";

/**
 * Open a URL in the native in-app browser.
 *
 * Better than opening the system browser for OAuth because:
 *   - User stays in the app context
 *   - Redirect back is seamless
 *   - No app switch animation jank
 *
 * Falls back to window.open on web.
 */
export async function openInAppBrowser(url: string): Promise<void> {
  if (isNative && hasPlugin("Browser")) {
    try {
      const { Browser } = await import("@capacitor/browser");
      await Browser.open({
        url,
        presentationStyle: "popover",
        toolbarColor: "#0a0a0a",
      });
      return;
    } catch (e) {
      console.warn("[Browser] in-app open failed, falling back", e);
    }
  }

  // Web fallback
  window.open(url, "_blank");
}

/**
 * Close the in-app browser (if open).
 */
export async function closeInAppBrowser(): Promise<void> {
  if (!isNative || !hasPlugin("Browser")) return;
  try {
    const { Browser } = await import("@capacitor/browser");
    await Browser.close();
  } catch {}
}

/**
 * Listen for browser close events (e.g. user dismissed OAuth flow).
 * Returns unsubscribe function.
 */
export async function onBrowserClosed(fn: () => void): Promise<() => void> {
  if (!isNative || !hasPlugin("Browser")) {
    return () => {};
  }

  try {
    const { Browser } = await import("@capacitor/browser");
    const handle = await Browser.addListener("browserFinished", fn);
    return () => handle.remove();
  } catch {
    return () => {};
  }
}

===== src/lib/native/geolocation.ts =====

// src/lib/native/geolocation.ts
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { Geolocation, type Position, type WatchPositionCallback } from "@capacitor/geolocation";
import { Haptics, ImpactStyle } from "@capacitor/haptics";
import { hasPlugin, isNative } from "./platform";

/* ── Types ───────────────────────────────────────────────────────────── */

export type RoamPosition = {
  lat: number;
  lng: number;
  accuracy: number;       // meters
  altitude: number | null;
  altitudeAccuracy: number | null;
  heading: number | null;  // degrees from north (0-360)
  speed: number | null;    // meters/sec
  timestamp: number;       // ms epoch
};

export type GeoState = {
  /** Latest position (null until first fix) */
  position: RoamPosition | null;
  /** True while waiting for first fix */
  loading: boolean;
  /** Permission status */
  permission: "granted" | "denied" | "prompt" | "unknown";
  /** Error message if any */
  error: string | null;
  /** Whether we're actively tracking */
  tracking: boolean;
};

function toRoamPos(p: Position): RoamPosition {
  const c = p.coords;

  return {
    lat: c.latitude,
    lng: c.longitude,
    accuracy: c.accuracy,
    altitude: c.altitude ?? null,
    altitudeAccuracy: c.altitudeAccuracy ?? null,
    heading: c.heading ?? null,
    speed: c.speed ?? null,
    timestamp: p.timestamp,
  };
}


/* ── Permission helper ───────────────────────────────────────────────── */

export async function requestLocationPermission(): Promise<"granted" | "denied" | "prompt"> {
  try {
    const status = await Geolocation.checkPermissions();
    if (status.location === "granted" || status.coarseLocation === "granted") {
      return "granted";
    }
    if (status.location === "denied") {
      return "denied";
    }
    // Prompt
    const req = await Geolocation.requestPermissions();
    if (req.location === "granted" || req.coarseLocation === "granted") {
      return "granted";
    }
    return "denied";
  } catch {
    return "denied";
  }
}

/* ── One-shot position ───────────────────────────────────────────────── */

export async function getCurrentPosition(): Promise<RoamPosition> {
  const pos = await Geolocation.getCurrentPosition({
    enableHighAccuracy: true,
    timeout: 15000,
  });
  return toRoamPos(pos);
}

/* ── Hook: useGeolocation ────────────────────────────────────────────── */

/**
 * Live geolocation tracking hook.
 *
 * Usage:
 *   const { position, loading, error, startTracking, stopTracking } = useGeolocation();
 *
 * Options:
 *   autoStart: begin tracking on mount (default false)
 *   highAccuracy: GPS-level accuracy (default true, uses more battery)
 *   hapticOnFix: vibrate on first fix (default true on native)
 */
export function useGeolocation(opts?: {
  autoStart?: boolean;
  highAccuracy?: boolean;
  hapticOnFix?: boolean;
}) {
  const autoStart = opts?.autoStart ?? false;
  const highAccuracy = opts?.highAccuracy ?? true;
  const hapticOnFix = opts?.hapticOnFix ?? isNative;

  const [state, setState] = useState<GeoState>({
    position: null,
    loading: false,
    permission: "unknown",
    error: null,
    tracking: false,
  });

  const watchIdRef = useRef<string | null>(null);
  const gotFirstFix = useRef(false);

  const startTracking = useCallback(async () => {
    // Already tracking
    if (watchIdRef.current) return;

    setState((s) => ({ ...s, loading: true, error: null }));

    // Check permission
    const perm = await requestLocationPermission();
    if (perm === "denied") {
      setState((s) => ({
        ...s,
        loading: false,
        permission: "denied",
        error: "Location permission denied. Enable it in device settings.",
      }));
      return;
    }

    setState((s) => ({ ...s, permission: "granted" }));
    gotFirstFix.current = false;

    try {
      const id = await Geolocation.watchPosition(
        { enableHighAccuracy: highAccuracy },
        (pos, err) => {
          if (err) {
            setState((s) => ({ ...s, error: err.message, loading: false }));
            return;
          }
          if (!pos) return;

          const rp = toRoamPos(pos);

          // Haptic buzz on first fix
          if (!gotFirstFix.current && hapticOnFix && hasPlugin("Haptics")) {
            gotFirstFix.current = true;
            Haptics.impact({ style: ImpactStyle.Light }).catch(() => {});
          }

          setState((s) => ({
            ...s,
            position: rp,
            loading: false,
            tracking: true,
            error: null,
          }));
        },
      );

      watchIdRef.current = id;
      setState((s) => ({ ...s, tracking: true }));
    } catch (e: any) {
      setState((s) => ({
        ...s,
        loading: false,
        error: e?.message ?? "Failed to start location tracking",
      }));
    }
  }, [highAccuracy, hapticOnFix]);

  const stopTracking = useCallback(async () => {
    if (watchIdRef.current) {
      try {
        await Geolocation.clearWatch({ id: watchIdRef.current });
      } catch {}
      watchIdRef.current = null;
    }
    setState((s) => ({ ...s, tracking: false, loading: false }));
  }, []);

  // Auto-start
  useEffect(() => {
    if (autoStart) startTracking();
    return () => {
      stopTracking();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return {
    ...state,
    startTracking,
    stopTracking,
  };
}

===== src/lib/native/haptics.ts =====

// src/lib/native/haptics.ts
"use client";

import { isNative, hasPlugin } from "./platform";

type VibratePattern = number | number[];

function vibrate(pattern: VibratePattern) {
  if (typeof navigator !== "undefined" && typeof navigator.vibrate === "function") {
    try {
      navigator.vibrate(pattern);
    } catch {
      // ignore
    }
  }
}

async function impact(style: "Light" | "Medium" | "Heavy", fallback: VibratePattern) {
  if (!isNative || !hasPlugin("Haptics")) {
    vibrate(fallback);
    return;
  }
  try {
    const { Haptics, ImpactStyle } = await import("@capacitor/haptics");
    const map = {
      Light: ImpactStyle.Light,
      Medium: ImpactStyle.Medium,
      Heavy: ImpactStyle.Heavy,
    } as const;
    await Haptics.impact({ style: map[style] });
  } catch {
    vibrate(fallback);
  }
}

async function notify(type: "Success" | "Warning" | "Error", fallback: VibratePattern) {
  if (!isNative || !hasPlugin("Haptics")) {
    vibrate(fallback);
    return;
  }
  try {
    const { Haptics, NotificationType } = await import("@capacitor/haptics");
    const map = {
      Success: NotificationType.Success,
      Warning: NotificationType.Warning,
      Error: NotificationType.Error,
    } as const;
    await Haptics.notification({ type: map[type] });
  } catch {
    vibrate(fallback);
  }
}

async function selectionTick(fallback: VibratePattern) {
  if (!isNative || !hasPlugin("Haptics")) {
    vibrate(fallback);
    return;
  }
  try {
    const { Haptics } = await import("@capacitor/haptics");
    await Haptics.selectionChanged();
  } catch {
    vibrate(fallback);
  }
}

/**
 * Preferred modern API
 * (plus a couple of legacy aliases so old callsites don't crash)
 */
export const haptic = {
  /** Light tap — tab press, list item selection, button confirm */
  async tap() {
    await impact("Light", 10);
  },

  /** ✅ legacy alias: some older callsites use haptic.light() */
  async light() {
    await impact("Light", 10);
  },

  /** Medium impact — map marker placed, stop added */
  async medium() {
    await impact("Medium", 20);
  },

  /** Heavy impact — long press confirmed, major action */
  async heavy() {
    await impact("Heavy", 40);
  },

  /** Success — route calculated, bundle ready, sync complete */
  async success() {
    await notify("Success", [10, 50, 20]);
  },

  /** Warning — hazard nearby, entering dead zone */
  async warning() {
    await notify("Warning", [15, 30, 15]);
  },

  /** ✅ legacy-ish alias some codebases use */
  async warn() {
    await notify("Warning", [15, 30, 15]);
  },

  /** Error — permission denied, offline with no bundle */
  async error() {
    await notify("Error", [20, 40, 20, 40, 20]);
  },

  /** Selection tick — drag reorder, toggle switch, filter chip */
  async selection() {
    await selectionTick(5);
  },
};

/**
 * Legacy API (backwards compatible with older code)
 */
export const haptics = {
  light: haptic.tap,
  medium: haptic.medium,
  heavy: haptic.heavy,
  success: haptic.success,
  error: haptic.error,
  selection: haptic.selection,
};


===== src/lib/native/index.ts =====

// src/lib/native/index.ts

export { isNative, isWeb, isIOS, isAndroid, platform, hasPlugin } from "./platform";
export { useGeolocation, getCurrentPosition, requestLocationPermission, type RoamPosition } from "./geolocation";
export { configureStatusBar, hideStatusBar, showStatusBar } from "./statusBar";
export { useKeepAwake } from "./keepAwake";
export { nativeShare } from "./share";
export { notify, roamNotify, requestNotificationPermission, onNotificationTap, initNotificationTapListener } from "./notifications";
export { configureKeyboard, hideKeyboard } from "./keyboard";
export { lockPortrait, unlockOrientation } from "./orientation";
export { initAppLifecycle, onAppStateChange } from "./appLifecycle";
export { haptic } from "./haptics";
export { hideSplash, showSplash } from "./splash";
export { openInAppBrowser, closeInAppBrowser, onBrowserClosed } from "./browser";

===== src/lib/native/keepAwake.ts =====

// src/lib/native/keepAwake.ts
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { isNative } from "./platform";

/**
 * Keeps the screen awake during active navigation.
 *
 * Uses @capacitor-community/keep-awake on native,
 * and the Screen Wake Lock API on modern browsers.
 *
 * Usage:
 *   const { isAwake, enable, disable } = useKeepAwake();
 *   // or auto-enable:
 *   const { isAwake } = useKeepAwake({ auto: true });
 */
export function useKeepAwake(opts?: { auto?: boolean }) {
  const [isAwake, setIsAwake] = useState(false);
  const wakeLockRef = useRef<any>(null);

  const enable = useCallback(async () => {
    if (isAwake) return;

    try {
      if (isNative) {
        const { KeepAwake } = await import("@capacitor-community/keep-awake");
        await KeepAwake.keepAwake();
      } else if ("wakeLock" in navigator) {
        wakeLockRef.current = await (navigator as any).wakeLock.request("screen");
      }
      setIsAwake(true);
    } catch (e) {
      console.warn("[KeepAwake] failed to enable", e);
    }
  }, [isAwake]);

  const disable = useCallback(async () => {
    if (!isAwake) return;

    try {
      if (isNative) {
        const { KeepAwake } = await import("@capacitor-community/keep-awake");
        await KeepAwake.allowSleep();
      } else if (wakeLockRef.current) {
        await wakeLockRef.current.release();
        wakeLockRef.current = null;
      }
      setIsAwake(false);
    } catch (e) {
      console.warn("[KeepAwake] failed to disable", e);
    }
  }, [isAwake]);

  useEffect(() => {
    if (opts?.auto) enable();
    return () => {
      disable();
    };
  }, []);

  return { isAwake, enable, disable };
}


===== src/lib/native/keyboard.ts =====

// src/lib/native/keyboard.ts
"use client";

import { isNative, hasPlugin, isIOS } from "./platform";

/**
 * Configure keyboard behavior for mobile-first UX.
 *
 * - iOS: keyboard pushes content up (accessoryBarVisible for done button)
 * - Android: resize mode so content scrolls naturally
 * - Scroll active input into view when keyboard opens
 *
 * Call once at app boot.
 */
export async function configureKeyboard(): Promise<void> {
  if (!isNative || !hasPlugin("Keyboard")) return;

  try {
    const { Keyboard, KeyboardResize } = await import("@capacitor/keyboard");

    // iOS: show the "Done" bar above keyboard for dismissal
    if (isIOS) {
      await Keyboard.setAccessoryBarVisible({ isVisible: true });
    }

    // Resize behavior: "body" mode resizes the WebView so content
    // scrolls naturally without manual offset calculations.
    await Keyboard.setResizeMode({ mode: KeyboardResize.Body });

    // Scroll focused input into view when keyboard opens
    await Keyboard.setScroll({ isDisabled: false });

    // Optional: listen for keyboard events to add CSS class
    await Keyboard.addListener("keyboardWillShow", (info) => {
      document.documentElement.style.setProperty(
        "--roam-keyboard-h",
        `${info.keyboardHeight}px`,
      );
      document.documentElement.classList.add("keyboard-open");
    });

    await Keyboard.addListener("keyboardWillHide", () => {
      document.documentElement.style.setProperty("--roam-keyboard-h", "0px");
      document.documentElement.classList.remove("keyboard-open");
    });
  } catch (e) {
    console.warn("[Keyboard] config failed", e);
  }
}

/**
 * Programmatically hide the keyboard.
 */
export async function hideKeyboard(): Promise<void> {
  if (!isNative || !hasPlugin("Keyboard")) return;
  try {
    const { Keyboard } = await import("@capacitor/keyboard");
    await Keyboard.hide();
  } catch {}
}

===== src/lib/native/notifications.ts =====

// src/lib/native/notifications.ts
"use client";

import { hasPlugin, isNative } from "./platform";

/* ── Types ───────────────────────────────────────────────────────────── */

type NotifyOpts = {
  id?: number;
  title: string;
  body: string;
  /** Optional: schedule for the future (ms from now) */
  delayMs?: number;
  /** Extra data (retrievable when notification is tapped) */
  extra?: Record<string, string>;
};

/* ── Permission ──────────────────────────────────────────────────────── */

let _permissionGranted = false;

export async function requestNotificationPermission(): Promise<boolean> {
  if (!isNative || !hasPlugin("LocalNotifications")) {
    // Web: use Notification API
    if (typeof Notification !== "undefined") {
      const perm = await Notification.requestPermission();
      _permissionGranted = perm === "granted";
      return _permissionGranted;
    }
    return false;
  }

  try {
    const { LocalNotifications } = await import("@capacitor/local-notifications");
    const result = await LocalNotifications.requestPermissions();
    _permissionGranted = result.display === "granted";
    return _permissionGranted;
  } catch {
    return false;
  }
}

/* ── Send notification ───────────────────────────────────────────────── */

let _nextId = 1;

export async function notify(opts: NotifyOpts): Promise<void> {
  const id = opts.id ?? _nextId++;

  if (isNative && hasPlugin("LocalNotifications")) {
    try {
      const { LocalNotifications } = await import("@capacitor/local-notifications");

      if (!_permissionGranted) {
        await requestNotificationPermission();
      }

      const scheduleAt = opts.delayMs
        ? new Date(Date.now() + opts.delayMs)
        : undefined;

      await LocalNotifications.schedule({
        notifications: [
          {
            id,
            title: opts.title,
            body: opts.body,
            schedule: scheduleAt ? { at: scheduleAt } : undefined,
            extra: opts.extra,
          },
        ],
      });
      return;
    } catch (e) {
      console.warn("[Notifications] native schedule failed", e);
    }
  }

  // Web fallback
  if (typeof Notification !== "undefined" && Notification.permission === "granted") {
    new Notification(opts.title, { body: opts.body });
  }
}

/* ── Listen for notification taps ────────────────────────────────────── */

type TapHandler = (extra: Record<string, string>) => void;
let _tapHandler: TapHandler | null = null;

export function onNotificationTap(handler: TapHandler) {
  _tapHandler = handler;
}

/**
 * Initialize notification tap listener. Call once at boot.
 */
export async function initNotificationTapListener(): Promise<void> {
  if (!isNative || !hasPlugin("LocalNotifications")) return;

  try {
    const { LocalNotifications } = await import("@capacitor/local-notifications");

    await LocalNotifications.addListener(
      "localNotificationActionPerformed",
      (action) => {
        const extra = (action.notification?.extra as Record<string, string>) ?? {};
        _tapHandler?.(extra);
      },
    );
  } catch {}
}

/* ── Convenience: common Roam notifications ──────────────────────────── */

export const roamNotify = {
  bundleReady(planLabel?: string) {
    notify({
      title: "Bundle ready",
      body: planLabel
        ? `"${planLabel}" is downloaded and ready for offline use.`
        : "Your trip is downloaded and ready for offline use.",
      extra: { type: "bundle_ready" },
    });
  },

  hazardAlert(description: string) {
    notify({
      title: "⚠️ Hazard ahead",
      body: description,
      extra: { type: "hazard" },
    });
  },

  syncComplete(count: number) {
    if (count <= 0) return;
    notify({
      title: "Sync complete",
      body: `${count} change${count > 1 ? "s" : ""} synced to cloud.`,
      extra: { type: "sync" },
    });
  },
};

===== src/lib/native/orientation.ts =====

// src/lib/native/orientation.ts
"use client";

import { isNative, hasPlugin } from "./platform";

/**
 * Lock screen to portrait orientation.
 * Mobile-first, one-handed UI — portrait is the only supported mode.
 *
 * Call once at app boot.
 */
export async function lockPortrait(): Promise<void> {
  if (!isNative || !hasPlugin("ScreenOrientation")) return;

  try {
    const { ScreenOrientation } = await import("@capacitor/screen-orientation");
    await ScreenOrientation.lock({ orientation: "portrait" });
  } catch (e) {
    console.warn("[Orientation] lock failed", e);
  }
}

/**
 * Unlock orientation (e.g. if you ever want landscape for map).
 */
export async function unlockOrientation(): Promise<void> {
  if (!isNative || !hasPlugin("ScreenOrientation")) return;

  try {
    const { ScreenOrientation } = await import("@capacitor/screen-orientation");
    await ScreenOrientation.unlock();
  } catch (e) {
    console.warn("[Orientation] unlock failed", e);
  }
}

===== src/lib/native/platform.ts =====

// src/lib/native/platform.ts

import { Capacitor } from "@capacitor/core";

/** True when running inside the Capacitor native shell (iOS/Android) */
export const isNative = Capacitor.isNativePlatform();

/** "ios" | "android" | "web" */
export const platform = Capacitor.getPlatform() as "ios" | "android" | "web";

/** True when running in a real browser (not Capacitor WebView) */
export const isWeb = platform === "web";

/** True on iOS native */
export const isIOS = platform === "ios";

/** True on Android native */
export const isAndroid = platform === "android";

/**
 * Safe plugin check — returns false if plugin isn't available on this platform
 * instead of throwing. Use before calling optional plugin APIs.
 */
export function hasPlugin(name: string): boolean {
  return Capacitor.isPluginAvailable(name);
}

===== src/lib/native/share.ts =====

// src/lib/native/share.ts
"use client";

import { hasPlugin, isNative } from "./platform";

export type ShareOpts = {
  title?: string;
  text?: string;
  url?: string;
};

/**
 * Open the native share sheet (or Web Share API on browsers).
 *
 * Usage:
 *   await nativeShare({
 *     title: "Join my Roam trip!",
 *     text: `Use code ${code} in the Roam app to join.`,
 *   });
 */
export async function nativeShare(opts: ShareOpts): Promise<boolean> {
  // Native Capacitor share
  if (isNative && hasPlugin("Share")) {
    try {
      const { Share } = await import("@capacitor/share");
      await Share.share({
        title: opts.title,
        text: opts.text,
        url: opts.url,
        dialogTitle: opts.title,
      });
      return true;
    } catch (e: any) {
      // User cancelled
      if (e?.message?.includes("cancel") || e?.message?.includes("dismiss")) return false;
      console.warn("[Share] native share failed", e);
    }
  }

  // Web Share API fallback
  if (typeof navigator !== "undefined" && navigator.share) {
    try {
      await navigator.share({
        title: opts.title,
        text: opts.text,
        url: opts.url,
      });
      return true;
    } catch {
      return false; // user cancelled
    }
  }

  // Last resort: copy to clipboard
  const text = [opts.title, opts.text, opts.url].filter(Boolean).join("\n");
  if (typeof navigator !== "undefined" && navigator.clipboard) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {}
  }

  return false;
}